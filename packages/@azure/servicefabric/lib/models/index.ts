/*
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for
 * license information.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is
 * regenerated.
 */

import { ServiceClientOptions } from "ms-rest-js";
import * as msRest from "ms-rest-js";


/**
 * @interface
 * An interface representing AadMetadata.
 * Azure Active Directory metadata used for secured connection to cluster.
 *
 */
export interface AadMetadata {
  /**
   * @member {string} [authority] The AAD authority url.
   */
  authority?: string;
  /**
   * @member {string} [client] The AAD client application Id.
   */
  client?: string;
  /**
   * @member {string} [cluster] The AAD cluster application Id.
   */
  cluster?: string;
  /**
   * @member {string} [login] The AAD login url.
   */
  login?: string;
  /**
   * @member {string} [redirect] The client application redirect address.
   */
  redirect?: string;
  /**
   * @member {string} [tenant] The AAD tenant Id.
   */
  tenant?: string;
}

/**
 * @interface
 * An interface representing AadMetadataObject.
 * Azure Active Directory metadata object used for secured connection to
 * cluster.
 *
 */
export interface AadMetadataObject {
  /**
   * @member {string} [type] The client authentication method.
   */
  type?: string;
  /**
   * @member {AadMetadata} [metadata] Azure Active Directory metadata used for
   * secured connection to cluster.
   */
  metadata?: AadMetadata;
}

/**
 * @interface
 * An interface representing AnalysisEventMetadata.
 * Metadata about an Analysis Event.
 *
 */
export interface AnalysisEventMetadata {
  /**
   * @member {string} [delay] The analysis delay.
   */
  delay?: string;
  /**
   * @member {string} [duration] The duration of analysis.
   */
  duration?: string;
}

/**
 * Contains the possible cases for FabricEvent.
 */
export type FabricEventUnion = FabricEvent | ApplicationEventUnion | ClusterEventUnion | ContainerInstanceEvent | NodeEventUnion | PartitionEventUnion | ReplicaEventUnion | ServiceEventUnion;

/**
 * @interface
 * An interface representing FabricEvent.
 * Represents the base for all Fabric Events.
 *
 */
export interface FabricEvent {
  /**
   * @member {string} kind Polymorphic Discriminator
   */
  kind: "FabricEvent";
  /**
   * @member {string} eventInstanceId The identifier for the FabricEvent
   * instance.
   */
  eventInstanceId: string;
  /**
   * @member {Date} timeStamp The time event was logged.
   */
  timeStamp: Date;
  /**
   * @member {boolean} [hasCorrelatedEvents] Shows there is existing related
   * events available.
   */
  hasCorrelatedEvents?: boolean;
}

/**
 * Contains the possible cases for ApplicationEvent.
 */
export type ApplicationEventUnion = ApplicationEvent | ApplicationCreatedEvent | ApplicationDeletedEvent | ApplicationHealthReportCreatedEvent | ApplicationHealthReportExpiredEvent | ApplicationUpgradeCompleteEvent | ApplicationUpgradeDomainCompleteEvent | ApplicationUpgradeRollbackCompleteEvent | ApplicationUpgradeRollbackStartEvent | ApplicationUpgradeStartEvent | DeployedApplicationHealthReportCreatedEvent | DeployedApplicationHealthReportExpiredEvent | ProcessDeactivatedEvent | ContainerDeactivatedEvent | DeployedServiceHealthReportCreatedEvent | DeployedServiceHealthReportExpiredEvent | ChaosRestartCodePackageFaultScheduledEvent | ChaosRestartCodePackageFaultCompletedEvent;

/**
 * @interface
 * An interface representing ApplicationEvent.
 * Represents the base for all Application Events.
 *
 */
export interface ApplicationEvent {
  /**
   * @member {string} kind Polymorphic Discriminator
   */
  kind: "ApplicationEvent";
  /**
   * @member {string} eventInstanceId The identifier for the FabricEvent
   * instance.
   */
  eventInstanceId: string;
  /**
   * @member {Date} timeStamp The time event was logged.
   */
  timeStamp: Date;
  /**
   * @member {boolean} [hasCorrelatedEvents] Shows there is existing related
   * events available.
   */
  hasCorrelatedEvents?: boolean;
  /**
   * @member {string} applicationId The identity of the application. This is an
   * encoded representation of the application name. This is used in the REST
   * APIs to identify the application resource.
   * Starting in version 6.0, hierarchical names are delimited with the "\~"
   * character. For example, if the application name is "fabric:/myapp/app1",
   * the application identity would be "myapp\~app1" in 6.0+ and "myapp/app1"
   * in previous versions.
   */
  applicationId: string;
}

/**
 * @interface
 * An interface representing EntityHealthState.
 * A base type for the health state of various entities in the cluster. It
 * contains the aggregated health state.
 *
 */
export interface EntityHealthState {
  /**
   * @member {HealthState} [aggregatedHealthState] The health state of a
   * Service Fabric entity such as Cluster, Node, Application, Service,
   * Partition, Replica etc. Possible values include: 'Invalid', 'Ok',
   * 'Warning', 'Error', 'Unknown'
   */
  aggregatedHealthState?: HealthState;
}

/**
 * @interface
 * An interface representing ServiceHealthState.
 * Represents the health state of a service, which contains the service
 * identifier and its aggregated health state.
 *
 * @extends EntityHealthState
 */
export interface ServiceHealthState extends EntityHealthState {
  /**
   * @member {string} [serviceName] Name of the service whose health state is
   * represented by this object.
   */
  serviceName?: string;
}

/**
 * @interface
 * An interface representing DeployedApplicationHealthState.
 * Represents the health state of a deployed application, which contains the
 * entity identifier and the aggregated health state.
 *
 * @extends EntityHealthState
 */
export interface DeployedApplicationHealthState extends EntityHealthState {
  /**
   * @member {string} [nodeName] Name of the node on which the service package
   * is deployed.
   */
  nodeName?: string;
  /**
   * @member {string} [applicationName] The name of the application, including
   * the 'fabric:' URI scheme.
   */
  applicationName?: string;
}

/**
 * @interface
 * An interface representing EntityHealth.
 * Health information common to all entities in the cluster. It contains the
 * aggregated health state, health events and unhealthy evaluation.
 *
 */
export interface EntityHealth {
  /**
   * @member {HealthState} [aggregatedHealthState] The HealthState representing
   * the aggregated health state of the entity computed by Health Manager.
   * The health evaluation of the entity reflects all events reported on the
   * entity and its children (if any).
   * The aggregation is done by applying the desired health policy. Possible
   * values include: 'Invalid', 'Ok', 'Warning', 'Error', 'Unknown'
   */
  aggregatedHealthState?: HealthState;
  /**
   * @member {HealthEvent[]} [healthEvents] The list of health events reported
   * on the entity.
   */
  healthEvents?: HealthEvent[];
  /**
   * @member {HealthEvaluationWrapper[]} [unhealthyEvaluations] The unhealthy
   * evaluations that show why the current aggregated health state was returned
   * by Health Manager.
   */
  unhealthyEvaluations?: HealthEvaluationWrapper[];
  /**
   * @member {HealthStatistics} [healthStatistics] Shows the health statistics
   * for all children types of the queried entity.
   */
  healthStatistics?: HealthStatistics;
}

/**
 * @interface
 * An interface representing ApplicationHealth.
 * Represents the health of the application. Contains the application
 * aggregated health state and the service and deployed application health
 * states.
 *
 * @extends EntityHealth
 */
export interface ApplicationHealth extends EntityHealth {
  /**
   * @member {string} [name] The name of the application, including the
   * 'fabric:' URI scheme.
   */
  name?: string;
  /**
   * @member {ServiceHealthState[]} [serviceHealthStates] Service health states
   * as found in the health store.
   */
  serviceHealthStates?: ServiceHealthState[];
  /**
   * @member {DeployedApplicationHealthState[]}
   * [deployedApplicationHealthStates] Deployed application health states as
   * found in the health store.
   */
  deployedApplicationHealthStates?: DeployedApplicationHealthState[];
}

/**
 * Contains the possible cases for HealthEvaluation.
 */
export type HealthEvaluationUnion = HealthEvaluation | ApplicationHealthEvaluation | ApplicationsHealthEvaluation | ApplicationTypeApplicationsHealthEvaluation | DeltaNodesCheckHealthEvaluation | DeployedApplicationHealthEvaluation | DeployedApplicationsHealthEvaluation | DeployedServicePackageHealthEvaluation | DeployedServicePackagesHealthEvaluation | EventHealthEvaluation | NodeHealthEvaluation | NodesHealthEvaluation | PartitionHealthEvaluation | PartitionsHealthEvaluation | ReplicaHealthEvaluation | ReplicasHealthEvaluation | ServiceHealthEvaluation | ServicesHealthEvaluation | SystemApplicationHealthEvaluation | UpgradeDomainDeltaNodesCheckHealthEvaluation | UpgradeDomainNodesHealthEvaluation;

/**
 * @interface
 * An interface representing HealthEvaluation.
 * Represents a health evaluation which describes the data and the algorithm
 * used by health manager to evaluate the health of an entity.
 *
 */
export interface HealthEvaluation {
  /**
   * @member {string} kind Polymorphic Discriminator
   */
  kind: "HealthEvaluation";
  /**
   * @member {HealthState} [aggregatedHealthState] The health state of a
   * Service Fabric entity such as Cluster, Node, Application, Service,
   * Partition, Replica etc. Possible values include: 'Invalid', 'Ok',
   * 'Warning', 'Error', 'Unknown'
   */
  aggregatedHealthState?: HealthState;
  /**
   * @member {string} [description] Description of the health evaluation, which
   * represents a summary of the evaluation process.
   */
  description?: string;
}

/**
 * @interface
 * An interface representing HealthEvaluationWrapper.
 * Wrapper object for health evaluation.
 *
 */
export interface HealthEvaluationWrapper {
  /**
   * @member {HealthEvaluationUnion} [healthEvaluation] Represents a health
   * evaluation which describes the data and the algorithm used by health
   * manager to evaluate the health of an entity.
   */
  healthEvaluation?: HealthEvaluationUnion;
}

/**
 * @interface
 * An interface representing ApplicationHealthEvaluation.
 * Represents health evaluation for an application, containing information
 * about the data and the algorithm used by the health store to evaluate
 * health.
 *
 */
export interface ApplicationHealthEvaluation {
  /**
   * @member {string} kind Polymorphic Discriminator
   */
  kind: "Application";
  /**
   * @member {HealthState} [aggregatedHealthState] The health state of a
   * Service Fabric entity such as Cluster, Node, Application, Service,
   * Partition, Replica etc. Possible values include: 'Invalid', 'Ok',
   * 'Warning', 'Error', 'Unknown'
   */
  aggregatedHealthState?: HealthState;
  /**
   * @member {string} [description] Description of the health evaluation, which
   * represents a summary of the evaluation process.
   */
  description?: string;
  /**
   * @member {string} [applicationName] The name of the application, including
   * the 'fabric:' URI scheme.
   */
  applicationName?: string;
  /**
   * @member {HealthEvaluationWrapper[]} [unhealthyEvaluations] List of
   * unhealthy evaluations that led to the current aggregated health state of
   * the application. The types of the unhealthy evaluations can be
   * DeployedApplicationsHealthEvaluation, ServicesHealthEvaluation or
   * EventHealthEvaluation.
   */
  unhealthyEvaluations?: HealthEvaluationWrapper[];
}

/**
 * @interface
 * An interface representing ServiceTypeHealthPolicy.
 * Represents the health policy used to evaluate the health of services
 * belonging to a service type.
 *
 */
export interface ServiceTypeHealthPolicy {
  /**
   * @member {number} [maxPercentUnhealthyPartitionsPerService] The maximum
   * allowed percentage of unhealthy partitions per service. Allowed values are
   * Byte values from zero to 100
   *
   * The percentage represents the maximum tolerated percentage of partitions
   * that can be unhealthy before the service is considered in error.
   * If the percentage is respected but there is at least one unhealthy
   * partition, the health is evaluated as Warning.
   * The percentage is calculated by dividing the number of unhealthy
   * partitions over the total number of partitions in the service.
   * The computation rounds up to tolerate one failure on small numbers of
   * partitions. Default percentage is zero. Default value: 0 .
   */
  maxPercentUnhealthyPartitionsPerService?: number;
  /**
   * @member {number} [maxPercentUnhealthyReplicasPerPartition] The maximum
   * allowed percentage of unhealthy replicas per partition. Allowed values are
   * Byte values from zero to 100.
   *
   * The percentage represents the maximum tolerated percentage of replicas
   * that can be unhealthy before the partition is considered in error.
   * If the percentage is respected but there is at least one unhealthy
   * replica, the health is evaluated as Warning.
   * The percentage is calculated by dividing the number of unhealthy replicas
   * over the total number of replicas in the partition.
   * The computation rounds up to tolerate one failure on small numbers of
   * replicas. Default percentage is zero. Default value: 0 .
   */
  maxPercentUnhealthyReplicasPerPartition?: number;
  /**
   * @member {number} [maxPercentUnhealthyServices] The maximum maximum allowed
   * percentage of unhealthy services. Allowed values are Byte values from zero
   * to 100.
   *
   * The percentage represents the maximum tolerated percentage of services
   * that can be unhealthy before the application is considered in error.
   * If the percentage is respected but there is at least one unhealthy
   * service, the health is evaluated as Warning.
   * This is calculated by dividing the number of unhealthy services of the
   * specific service type over the total number of services of the specific
   * service type.
   * The computation rounds up to tolerate one failure on small numbers of
   * services. Default percentage is zero. Default value: 0 .
   */
  maxPercentUnhealthyServices?: number;
}

/**
 * @interface
 * An interface representing ServiceTypeHealthPolicyMapItem.
 * Defines an item in ServiceTypeHealthPolicyMap.
 *
 */
export interface ServiceTypeHealthPolicyMapItem {
  /**
   * @member {string} key The key of the service type health policy map item.
   * This is the name of the service type.
   */
  key: string;
  /**
   * @member {ServiceTypeHealthPolicy} value The value of the service type
   * health policy map item. This is the ServiceTypeHealthPolicy for this
   * service type.
   */
  value: ServiceTypeHealthPolicy;
}

/**
 * @interface
 * An interface representing ApplicationHealthPolicy.
 * Defines a health policy used to evaluate the health of an application or one
 * of its children entities.
 *
 */
export interface ApplicationHealthPolicy {
  /**
   * @member {boolean} [considerWarningAsError] Indicates whether warnings are
   * treated with the same severity as errors. Default value: false .
   */
  considerWarningAsError?: boolean;
  /**
   * @member {number} [maxPercentUnhealthyDeployedApplications] The maximum
   * allowed percentage of unhealthy deployed applications. Allowed values are
   * Byte values from zero to 100.
   * The percentage represents the maximum tolerated percentage of deployed
   * applications that can be unhealthy before the application is considered in
   * error.
   * This is calculated by dividing the number of unhealthy deployed
   * applications over the number of nodes where the application is currently
   * deployed on in the cluster.
   * The computation rounds up to tolerate one failure on small numbers of
   * nodes. Default percentage is zero. Default value: 0 .
   */
  maxPercentUnhealthyDeployedApplications?: number;
  /**
   * @member {ServiceTypeHealthPolicy} [defaultServiceTypeHealthPolicy] The
   * health policy used by default to evaluate the health of a service type.
   */
  defaultServiceTypeHealthPolicy?: ServiceTypeHealthPolicy;
  /**
   * @member {ServiceTypeHealthPolicyMapItem[]} [serviceTypeHealthPolicyMap]
   * The map with service type health policy per service type name. The map is
   * empty by default.
   */
  serviceTypeHealthPolicyMap?: ServiceTypeHealthPolicyMapItem[];
}

/**
 * @interface
 * An interface representing ApplicationHealthPolicyMapItem.
 * Defines an item in ApplicationHealthPolicyMap.
 *
 */
export interface ApplicationHealthPolicyMapItem {
  /**
   * @member {string} key The key of the application health policy map item.
   * This is the name of the application.
   */
  key: string;
  /**
   * @member {ApplicationHealthPolicy} value The value of the application
   * health policy map item. This is the ApplicationHealthPolicy for this
   * application.
   */
  value: ApplicationHealthPolicy;
}

/**
 * @interface
 * An interface representing ApplicationHealthPolicies.
 * Defines the application health policy map used to evaluate the health of an
 * application or one of its children entities.
 *
 */
export interface ApplicationHealthPolicies {
  /**
   * @member {ApplicationHealthPolicyMapItem[]} [applicationHealthPolicyMap]
   * The wrapper that contains the map with application health policies used to
   * evaluate specific applications in the cluster.
   */
  applicationHealthPolicyMap?: ApplicationHealthPolicyMapItem[];
}

/**
 * @interface
 * An interface representing ApplicationHealthState.
 * Represents the health state of an application, which contains the
 * application identifier and the aggregated health state.
 *
 * @extends EntityHealthState
 */
export interface ApplicationHealthState extends EntityHealthState {
  /**
   * @member {string} [name] The name of the application, including the
   * 'fabric:' URI scheme.
   */
  name?: string;
}

/**
 * @interface
 * An interface representing EntityHealthStateChunk.
 * A base type for the health state chunk of various entities in the cluster.
 * It contains the aggregated health state.
 *
 */
export interface EntityHealthStateChunk {
  /**
   * @member {HealthState} [healthState] The health state of a Service Fabric
   * entity such as Cluster, Node, Application, Service, Partition, Replica
   * etc. Possible values include: 'Invalid', 'Ok', 'Warning', 'Error',
   * 'Unknown'
   */
  healthState?: HealthState;
}

/**
 * @interface
 * An interface representing ReplicaHealthStateChunk.
 * Represents the health state chunk of a stateful service replica or a
 * stateless service instance.
 * The replica health state contains the replica ID and its aggregated health
 * state.
 *
 * @extends EntityHealthStateChunk
 */
export interface ReplicaHealthStateChunk extends EntityHealthStateChunk {
  /**
   * @member {string} [replicaOrInstanceId] Id of a stateful service replica or
   * a stateless service instance. This ID is used in the queries that apply to
   * both stateful and stateless services. It is used by Service Fabric to
   * uniquely identify a replica of a partition of a stateful service or an
   * instance of a stateless service partition. It is unique within a partition
   * and does not change for the lifetime of the replica or the instance. If a
   * stateful replica gets dropped and another replica gets created on the same
   * node for the same partition, it will get a different value for the ID. If
   * a stateless instance is failed over on the same or different node it will
   * get a different value for the ID.
   */
  replicaOrInstanceId?: string;
}

/**
 * @interface
 * An interface representing ReplicaHealthStateChunkList.
 * The list of replica health state chunks that respect the input filters in
 * the chunk query. Returned by get cluster health state chunks query.
 *
 */
export interface ReplicaHealthStateChunkList {
  /**
   * @member {ReplicaHealthStateChunk[]} [items] The list of replica health
   * state chunks that respect the input filters in the chunk query.
   */
  items?: ReplicaHealthStateChunk[];
}

/**
 * @interface
 * An interface representing PartitionHealthStateChunk.
 * Represents the health state chunk of a partition, which contains the
 * partition ID, its aggregated health state and any replicas that respect the
 * filters in the cluster health chunk query description.
 *
 * @extends EntityHealthStateChunk
 */
export interface PartitionHealthStateChunk extends EntityHealthStateChunk {
  /**
   * @member {string} [partitionId] The Id of the partition.
   */
  partitionId?: string;
  /**
   * @member {ReplicaHealthStateChunkList} [replicaHealthStateChunks] The list
   * of replica health state chunks belonging to the partition that respect the
   * filters in the cluster health chunk query description.
   */
  replicaHealthStateChunks?: ReplicaHealthStateChunkList;
}

/**
 * @interface
 * An interface representing PartitionHealthStateChunkList.
 * The list of partition health state chunks that respect the input filters in
 * the chunk query description.
 * Returned by get cluster health state chunks query as part of the parent
 * application hierarchy.
 *
 */
export interface PartitionHealthStateChunkList {
  /**
   * @member {PartitionHealthStateChunk[]} [items] The list of partition health
   * state chunks that respect the input filters in the chunk query.
   */
  items?: PartitionHealthStateChunk[];
}

/**
 * @interface
 * An interface representing ServiceHealthStateChunk.
 * Represents the health state chunk of a service, which contains the service
 * name, its aggregated health state and any partitions that respect the
 * filters in the cluster health chunk query description.
 *
 * @extends EntityHealthStateChunk
 */
export interface ServiceHealthStateChunk extends EntityHealthStateChunk {
  /**
   * @member {string} [serviceName] The name of the service whose health state
   * chunk is provided in this object.
   */
  serviceName?: string;
  /**
   * @member {PartitionHealthStateChunkList} [partitionHealthStateChunks] The
   * list of partition health state chunks belonging to the service that
   * respect the filters in the cluster health chunk query description.
   */
  partitionHealthStateChunks?: PartitionHealthStateChunkList;
}

/**
 * @interface
 * An interface representing ServiceHealthStateChunkList.
 * The list of service health state chunks that respect the input filters in
 * the chunk query. Returned by get cluster health state chunks query.
 *
 */
export interface ServiceHealthStateChunkList {
  /**
   * @member {ServiceHealthStateChunk[]} [items] The list of service health
   * state chunks that respect the input filters in the chunk query.
   */
  items?: ServiceHealthStateChunk[];
}

/**
 * @interface
 * An interface representing DeployedServicePackageHealthStateChunk.
 * Represents the health state chunk of a deployed service package, which
 * contains the service manifest name and the service package aggregated health
 * state.
 *
 * @extends EntityHealthStateChunk
 */
export interface DeployedServicePackageHealthStateChunk extends EntityHealthStateChunk {
  /**
   * @member {string} [serviceManifestName] The name of the service manifest.
   */
  serviceManifestName?: string;
  /**
   * @member {string} [servicePackageActivationId] The ActivationId of a
   * deployed service package. If ServicePackageActivationMode specified at the
   * time of creating the service
   * is 'SharedProcess' (or if it is not specified, in which case it defaults
   * to 'SharedProcess'), then value of ServicePackageActivationId
   * is always an empty string.
   */
  servicePackageActivationId?: string;
}

/**
 * @interface
 * An interface representing DeployedServicePackageHealthStateChunkList.
 * The list of deployed service package health state chunks that respect the
 * input filters in the chunk query. Returned by get cluster health state
 * chunks query.
 *
 */
export interface DeployedServicePackageHealthStateChunkList {
  /**
   * @member {DeployedServicePackageHealthStateChunk[]} [items] The list of
   * deployed service package health state chunks that respect the input
   * filters in the chunk query.
   */
  items?: DeployedServicePackageHealthStateChunk[];
}

/**
 * @interface
 * An interface representing DeployedApplicationHealthStateChunk.
 * Represents the health state chunk of a deployed application, which contains
 * the node where the application is deployed, the aggregated health state and
 * any deployed service packages that respect the chunk query description
 * filters.
 *
 * @extends EntityHealthStateChunk
 */
export interface DeployedApplicationHealthStateChunk extends EntityHealthStateChunk {
  /**
   * @member {string} [nodeName] The name of node where the application is
   * deployed.
   */
  nodeName?: string;
  /**
   * @member {DeployedServicePackageHealthStateChunkList}
   * [deployedServicePackageHealthStateChunks] The list of deployed service
   * package health state chunks belonging to the deployed application that
   * respect the filters in the cluster health chunk query description.
   */
  deployedServicePackageHealthStateChunks?: DeployedServicePackageHealthStateChunkList;
}

/**
 * @interface
 * An interface representing DeployedApplicationHealthStateChunkList.
 * The list of deployed application health state chunks that respect the input
 * filters in the chunk query. Returned by get cluster health state chunks
 * query.
 *
 */
export interface DeployedApplicationHealthStateChunkList {
  /**
   * @member {DeployedApplicationHealthStateChunk[]} [items] The list of
   * deployed application health state chunks that respect the input filters in
   * the chunk query.
   */
  items?: DeployedApplicationHealthStateChunk[];
}

/**
 * @interface
 * An interface representing ApplicationHealthStateChunk.
 * Represents the health state chunk of a application.
 * The application health state chunk contains the application name, its
 * aggregated health state and any children services and deployed applications
 * that respect the filters in cluster health chunk query description.
 *
 * @extends EntityHealthStateChunk
 */
export interface ApplicationHealthStateChunk extends EntityHealthStateChunk {
  /**
   * @member {string} [applicationName] The name of the application, including
   * the 'fabric:' URI scheme.
   */
  applicationName?: string;
  /**
   * @member {string} [applicationTypeName] The application type name as
   * defined in the application manifest.
   */
  applicationTypeName?: string;
  /**
   * @member {ServiceHealthStateChunkList} [serviceHealthStateChunks] The list
   * of service health state chunks in the cluster that respect the filters in
   * the cluster health chunk query description.
   */
  serviceHealthStateChunks?: ServiceHealthStateChunkList;
  /**
   * @member {DeployedApplicationHealthStateChunkList}
   * [deployedApplicationHealthStateChunks] The list of deployed application
   * health state chunks in the cluster that respect the filters in the cluster
   * health chunk query description.
   */
  deployedApplicationHealthStateChunks?: DeployedApplicationHealthStateChunkList;
}

/**
 * @interface
 * An interface representing EntityHealthStateChunkList.
 * A base type for the list of health state chunks found in the cluster. It
 * contains the total number of health states that match the input filters.
 *
 */
export interface EntityHealthStateChunkList {
  /**
   * @member {number} [totalCount] Total number of entity health state objects
   * that match the specified filters from the cluster health chunk query
   * description.
   */
  totalCount?: number;
}

/**
 * @interface
 * An interface representing ApplicationHealthStateChunkList.
 * The list of application health state chunks in the cluster that respect the
 * input filters in the chunk query. Returned by get cluster health state
 * chunks query.
 *
 * @extends EntityHealthStateChunkList
 */
export interface ApplicationHealthStateChunkList extends EntityHealthStateChunkList {
  /**
   * @member {ApplicationHealthStateChunk[]} [items] The list of application
   * health state chunks that respect the input filters in the chunk query.
   */
  items?: ApplicationHealthStateChunk[];
}

/**
 * @interface
 * An interface representing ReplicaHealthStateFilter.
 * Defines matching criteria to determine whether a replica should be included
 * as a child of a partition in the cluster health chunk.
 * The replicas are only returned if the parent entities match a filter
 * specified in the cluster health chunk query description. The parent
 * partition, service and application must be included in the cluster health
 * chunk.
 * One filter can match zero, one or multiple replicas, depending on its
 * properties.
 *
 */
export interface ReplicaHealthStateFilter {
  /**
   * @member {string} [replicaOrInstanceIdFilter] Id of the stateful service
   * replica or stateless service instance that matches the filter. The filter
   * is applied only to the specified replica, if it exists.
   * If the replica doesn't exist, no replica is returned in the cluster health
   * chunk based on this filter.
   * If the replica exists, it is included in the cluster health chunk if it
   * respects the other filter properties.
   * If not specified, all replicas that match the parent filters (if any) are
   * taken into consideration and matched against the other filter members,
   * like health state filter.
   */
  replicaOrInstanceIdFilter?: string;
  /**
   * @member {number} [healthStateFilter] The filter for the health state of
   * the replicas. It allows selecting replicas if they match the desired
   * health states.
   * The possible values are integer value of one of the following health
   * states. Only replicas that match the filter are returned. All replicas are
   * used to evaluate the parent partition aggregated health state.
   * If not specified, default value is None, unless the replica ID is
   * specified. If the filter has default value and replica ID is specified,
   * the matching replica is returned.
   * The state values are flag-based enumeration, so the value could be a
   * combination of these values obtained using bitwise 'OR' operator.
   * For example, if the provided value is 6, it matches replicas with
   * HealthState value of OK (2) and Warning (4).
   *
   * - Default - Default value. Matches any HealthState. The value is zero.
   * - None - Filter that doesn't match any HealthState value. Used in order to
   * return no results on a given collection of states. The value is 1.
   * - Ok - Filter that matches input with HealthState value Ok. The value is
   * 2.
   * - Warning - Filter that matches input with HealthState value Warning. The
   * value is 4.
   * - Error - Filter that matches input with HealthState value Error. The
   * value is 8.
   * - All - Filter that matches input with any HealthState value. The value is
   * 65535. Default value: 0 .
   */
  healthStateFilter?: number;
}

/**
 * @interface
 * An interface representing PartitionHealthStateFilter.
 * Defines matching criteria to determine whether a partition should be
 * included as a child of a service in the cluster health chunk.
 * The partitions are only returned if the parent entities match a filter
 * specified in the cluster health chunk query description. The parent service
 * and application must be included in the cluster health chunk.
 * One filter can match zero, one or multiple partitions, depending on its
 * properties.
 *
 */
export interface PartitionHealthStateFilter {
  /**
   * @member {string} [partitionIdFilter] ID of the partition that matches the
   * filter. The filter is applied only to the specified partition, if it
   * exists.
   * If the partition doesn't exist, no partition is returned in the cluster
   * health chunk based on this filter.
   * If the partition exists, it is included in the cluster health chunk if it
   * respects the other filter properties.
   * If not specified, all partitions that match the parent filters (if any)
   * are taken into consideration and matched against the other filter members,
   * like health state filter.
   */
  partitionIdFilter?: string;
  /**
   * @member {number} [healthStateFilter] The filter for the health state of
   * the partitions. It allows selecting partitions if they match the desired
   * health states.
   * The possible values are integer value of one of the following health
   * states. Only partitions that match the filter are returned. All partitions
   * are used to evaluate the cluster aggregated health state.
   * If not specified, default value is None, unless the partition ID is
   * specified. If the filter has default value and partition ID is specified,
   * the matching partition is returned.
   * The state values are flag-based enumeration, so the value could be a
   * combination of these values obtained using bitwise 'OR' operator.
   * For example, if the provided value is 6, it matches partitions with
   * HealthState value of OK (2) and Warning (4).
   *
   * - Default - Default value. Matches any HealthState. The value is zero.
   * - None - Filter that doesn't match any HealthState value. Used in order to
   * return no results on a given collection of states. The value is 1.
   * - Ok - Filter that matches input with HealthState value Ok. The value is
   * 2.
   * - Warning - Filter that matches input with HealthState value Warning. The
   * value is 4.
   * - Error - Filter that matches input with HealthState value Error. The
   * value is 8.
   * - All - Filter that matches input with any HealthState value. The value is
   * 65535. Default value: 0 .
   */
  healthStateFilter?: number;
  /**
   * @member {ReplicaHealthStateFilter[]} [replicaFilters] Defines a list of
   * filters that specify which replicas to be included in the returned cluster
   * health chunk as children of the parent partition. The replicas are
   * returned only if the parent partition matches a filter.
   * If the list is empty, no replicas are returned. All the replicas are used
   * to evaluate the parent partition aggregated health state, regardless of
   * the input filters.
   * The partition filter may specify multiple replica filters.
   * For example, it can specify a filter to return all replicas with health
   * state Error and another filter to always include a replica identified by
   * its replica id.
   */
  replicaFilters?: ReplicaHealthStateFilter[];
}

/**
 * @interface
 * An interface representing ServiceHealthStateFilter.
 * Defines matching criteria to determine whether a service should be included
 * as a child of an application in the cluster health chunk.
 * The services are only returned if the parent application matches a filter
 * specified in the cluster health chunk query description.
 * One filter can match zero, one or multiple services, depending on its
 * properties.
 *
 */
export interface ServiceHealthStateFilter {
  /**
   * @member {string} [serviceNameFilter] The name of the service that matches
   * the filter. The filter is applied only to the specified service, if it
   * exists.
   * If the service doesn't exist, no service is returned in the cluster health
   * chunk based on this filter.
   * If the service exists, it is included as the application's child if the
   * health state matches the other filter properties.
   * If not specified, all services that match the parent filters (if any) are
   * taken into consideration and matched against the other filter members,
   * like health state filter.
   */
  serviceNameFilter?: string;
  /**
   * @member {number} [healthStateFilter] The filter for the health state of
   * the services. It allows selecting services if they match the desired
   * health states.
   * The possible values are integer value of one of the following health
   * states. Only services that match the filter are returned. All services are
   * used to evaluate the cluster aggregated health state.
   * If not specified, default value is None, unless the service name is
   * specified. If the filter has default value and service name is specified,
   * the matching service is returned.
   * The state values are flag-based enumeration, so the value could be a
   * combination of these values obtained using bitwise 'OR' operator.
   * For example, if the provided value is 6, it matches services with
   * HealthState value of OK (2) and Warning (4).
   *
   * - Default - Default value. Matches any HealthState. The value is zero.
   * - None - Filter that doesn't match any HealthState value. Used in order to
   * return no results on a given collection of states. The value is 1.
   * - Ok - Filter that matches input with HealthState value Ok. The value is
   * 2.
   * - Warning - Filter that matches input with HealthState value Warning. The
   * value is 4.
   * - Error - Filter that matches input with HealthState value Error. The
   * value is 8.
   * - All - Filter that matches input with any HealthState value. The value is
   * 65535. Default value: 0 .
   */
  healthStateFilter?: number;
  /**
   * @member {PartitionHealthStateFilter[]} [partitionFilters] Defines a list
   * of filters that specify which partitions to be included in the returned
   * cluster health chunk as children of the service. The partitions are
   * returned only if the parent service matches a filter.
   * If the list is empty, no partitions are returned. All the partitions are
   * used to evaluate the parent service aggregated health state, regardless of
   * the input filters.
   * The service filter may specify multiple partition filters.
   * For example, it can specify a filter to return all partitions with health
   * state Error and another filter to always include a partition identified by
   * its partition ID.
   */
  partitionFilters?: PartitionHealthStateFilter[];
}

/**
 * @interface
 * An interface representing DeployedServicePackageHealthStateFilter.
 * Defines matching criteria to determine whether a deployed service package
 * should be included as a child of a deployed application in the cluster
 * health chunk.
 * The deployed service packages are only returned if the parent entities match
 * a filter specified in the cluster health chunk query description. The parent
 * deployed application and its parent application must be included in the
 * cluster health chunk.
 * One filter can match zero, one or multiple deployed service packages,
 * depending on its properties.
 *
 */
export interface DeployedServicePackageHealthStateFilter {
  /**
   * @member {string} [serviceManifestNameFilter] The name of the service
   * manifest which identifies the deployed service packages that matches the
   * filter.
   * If specified, the filter is applied only to the specified deployed service
   * packages, if any.
   * If no deployed service packages with specified manifest name exist,
   * nothing is returned in the cluster health chunk based on this filter.
   * If any deployed service package exists, they are included in the cluster
   * health chunk if it respects the other filter properties.
   * If not specified, all deployed service packages that match the parent
   * filters (if any) are taken into consideration and matched against the
   * other filter members, like health state filter.
   */
  serviceManifestNameFilter?: string;
  /**
   * @member {string} [servicePackageActivationIdFilter] The activation ID of a
   * deployed service package that matches the filter.
   * If not specified, the filter applies to all deployed service packages that
   * match the other parameters.
   * If specified, the filter matches only the deployed service package with
   * the specified activation ID.
   */
  servicePackageActivationIdFilter?: string;
  /**
   * @member {number} [healthStateFilter] The filter for the health state of
   * the deployed service packages. It allows selecting deployed service
   * packages if they match the desired health states.
   * The possible values are integer value of one of the following health
   * states. Only deployed service packages that match the filter are returned.
   * All deployed service packages are used to evaluate the parent deployed
   * application aggregated health state.
   * If not specified, default value is None, unless the deployed service
   * package ID is specified. If the filter has default value and deployed
   * service package ID is specified, the matching deployed service package is
   * returned.
   * The state values are flag-based enumeration, so the value could be a
   * combination of these values obtained using bitwise 'OR' operator.
   * For example, if the provided value is 6, it matches deployed service
   * packages with HealthState value of OK (2) and Warning (4).
   *
   * - Default - Default value. Matches any HealthState. The value is zero.
   * - None - Filter that doesn't match any HealthState value. Used in order to
   * return no results on a given collection of states. The value is 1.
   * - Ok - Filter that matches input with HealthState value Ok. The value is
   * 2.
   * - Warning - Filter that matches input with HealthState value Warning. The
   * value is 4.
   * - Error - Filter that matches input with HealthState value Error. The
   * value is 8.
   * - All - Filter that matches input with any HealthState value. The value is
   * 65535. Default value: 0 .
   */
  healthStateFilter?: number;
}

/**
 * @interface
 * An interface representing DeployedApplicationHealthStateFilter.
 * Defines matching criteria to determine whether a deployed application should
 * be included as a child of an application in the cluster health chunk.
 * The deployed applications are only returned if the parent application
 * matches a filter specified in the cluster health chunk query description.
 * One filter can match zero, one or multiple deployed applications, depending
 * on its properties.
 *
 */
export interface DeployedApplicationHealthStateFilter {
  /**
   * @member {string} [nodeNameFilter] The name of the node where the
   * application is deployed in order to match the filter.
   * If specified, the filter is applied only to the application deployed on
   * the specified node.
   * If the application is not deployed on the node with the specified name, no
   * deployed application is returned in the cluster health chunk based on this
   * filter.
   * Otherwise, the deployed application is included in the cluster health
   * chunk if it respects the other filter properties.
   * If not specified, all deployed applications that match the parent filters
   * (if any) are taken into consideration and matched against the other filter
   * members, like health state filter.
   */
  nodeNameFilter?: string;
  /**
   * @member {number} [healthStateFilter] The filter for the health state of
   * the deployed applications. It allows selecting deployed applications if
   * they match the desired health states.
   * The possible values are integer value of one of the following health
   * states. Only deployed applications that match the filter are returned. All
   * deployed applications are used to evaluate the cluster aggregated health
   * state.
   * If not specified, default value is None, unless the node name is
   * specified. If the filter has default value and node name is specified, the
   * matching deployed application is returned.
   * The state values are flag-based enumeration, so the value could be a
   * combination of these values obtained using bitwise 'OR' operator.
   * For example, if the provided value is 6, it matches deployed applications
   * with HealthState value of OK (2) and Warning (4).
   *
   * - Default - Default value. Matches any HealthState. The value is zero.
   * - None - Filter that doesn't match any HealthState value. Used in order to
   * return no results on a given collection of states. The value is 1.
   * - Ok - Filter that matches input with HealthState value Ok. The value is
   * 2.
   * - Warning - Filter that matches input with HealthState value Warning. The
   * value is 4.
   * - Error - Filter that matches input with HealthState value Error. The
   * value is 8.
   * - All - Filter that matches input with any HealthState value. The value is
   * 65535. Default value: 0 .
   */
  healthStateFilter?: number;
  /**
   * @member {DeployedServicePackageHealthStateFilter[]}
   * [deployedServicePackageFilters] Defines a list of filters that specify
   * which deployed service packages to be included in the returned cluster
   * health chunk as children of the parent deployed application. The deployed
   * service packages are returned only if the parent deployed application
   * matches a filter.
   * If the list is empty, no deployed service packages are returned. All the
   * deployed service packages are used to evaluate the parent deployed
   * application aggregated health state, regardless of the input filters.
   * The deployed application filter may specify multiple deployed service
   * package filters.
   * For example, it can specify a filter to return all deployed service
   * packages with health state Error and another filter to always include a
   * deployed service package on a node.
   */
  deployedServicePackageFilters?: DeployedServicePackageHealthStateFilter[];
}

/**
 * @interface
 * An interface representing ApplicationHealthStateFilter.
 * Defines matching criteria to determine whether a application should be
 * included in the cluster health chunk.
 * One filter can match zero, one or multiple applications, depending on its
 * properties.
 *
 */
export interface ApplicationHealthStateFilter {
  /**
   * @member {string} [applicationNameFilter] The name of the application that
   * matches the filter, as a fabric uri. The filter is applied only to the
   * specified application, if it exists.
   * If the application doesn't exist, no application is returned in the
   * cluster health chunk based on this filter.
   * If the application exists, it is included in the cluster health chunk if
   * it respects the other filter properties.
   * If not specified, all applications are matched against the other filter
   * members, like health state filter.
   */
  applicationNameFilter?: string;
  /**
   * @member {string} [applicationTypeNameFilter] The name of the application
   * type that matches the filter.
   * If specified, the filter is applied only to applications of the selected
   * application type, if any exists.
   * If no applications of the specified application type exists, no
   * application is returned in the cluster health chunk based on this filter.
   * Each application of the specified application type is included in the
   * cluster health chunk if it respects the other filter properties.
   * If not specified, all applications are matched against the other filter
   * members, like health state filter.
   */
  applicationTypeNameFilter?: string;
  /**
   * @member {number} [healthStateFilter] The filter for the health state of
   * the applications. It allows selecting applications if they match the
   * desired health states.
   * The possible values are integer value of one of the following health
   * states. Only applications that match the filter are returned. All
   * applications are used to evaluate the cluster aggregated health state.
   * If not specified, default value is None, unless the application name or
   * the application type name are specified. If the filter has default value
   * and application name is specified, the matching application is returned.
   * The state values are flag-based enumeration, so the value could be a
   * combination of these values obtained using bitwise 'OR' operator.
   * For example, if the provided value is 6, it matches applications with
   * HealthState value of OK (2) and Warning (4).
   *
   * - Default - Default value. Matches any HealthState. The value is zero.
   * - None - Filter that doesn't match any HealthState value. Used in order to
   * return no results on a given collection of states. The value is 1.
   * - Ok - Filter that matches input with HealthState value Ok. The value is
   * 2.
   * - Warning - Filter that matches input with HealthState value Warning. The
   * value is 4.
   * - Error - Filter that matches input with HealthState value Error. The
   * value is 8.
   * - All - Filter that matches input with any HealthState value. The value is
   * 65535. Default value: 0 .
   */
  healthStateFilter?: number;
  /**
   * @member {ServiceHealthStateFilter[]} [serviceFilters] Defines a list of
   * filters that specify which services to be included in the returned cluster
   * health chunk as children of the application. The services are returned
   * only if the parent application matches a filter.
   * If the list is empty, no services are returned. All the services are used
   * to evaluate the parent application aggregated health state, regardless of
   * the input filters.
   * The application filter may specify multiple service filters.
   * For example, it can specify a filter to return all services with health
   * state Error and another filter to always include a service identified by
   * its service name.
   */
  serviceFilters?: ServiceHealthStateFilter[];
  /**
   * @member {DeployedApplicationHealthStateFilter[]}
   * [deployedApplicationFilters] Defines a list of filters that specify which
   * deployed applications to be included in the returned cluster health chunk
   * as children of the application. The deployed applications are returned
   * only if the parent application matches a filter.
   * If the list is empty, no deployed applications are returned. All the
   * deployed applications are used to evaluate the parent application
   * aggregated health state, regardless of the input filters.
   * The application filter may specify multiple deployed application filters.
   * For example, it can specify a filter to return all deployed applications
   * with health state Error and another filter to always include a deployed
   * application on a specified node.
   */
  deployedApplicationFilters?: DeployedApplicationHealthStateFilter[];
}

/**
 * @interface
 * An interface representing ApplicationParameter.
 * Describes an application parameter override to be applied when creating or
 * upgrading an application.
 *
 */
export interface ApplicationParameter {
  /**
   * @member {string} key The name of the parameter.
   */
  key: string;
  /**
   * @member {string} value The value of the parameter.
   */
  value: string;
}

/**
 * @interface
 * An interface representing ApplicationInfo.
 * Information about a Service Fabric application.
 *
 */
export interface ApplicationInfo {
  /**
   * @member {string} [id] The identity of the application. This is an encoded
   * representation of the application name. This is used in the REST APIs to
   * identify the application resource.
   * Starting in version 6.0, hierarchical names are delimited with the "\~"
   * character. For example, if the application name is "fabric:/myapp/app1",
   * the application identity would be "myapp\~app1" in 6.0+ and "myapp/app1"
   * in previous versions.
   */
  id?: string;
  /**
   * @member {string} [name] The name of the application, including the
   * 'fabric:' URI scheme.
   */
  name?: string;
  /**
   * @member {string} [typeName] The application type name as defined in the
   * application manifest.
   */
  typeName?: string;
  /**
   * @member {string} [typeVersion] The version of the application type as
   * defined in the application manifest.
   */
  typeVersion?: string;
  /**
   * @member {ApplicationStatus} [status] The status of the application.
   * Possible values include: 'Invalid', 'Ready', 'Upgrading', 'Creating',
   * 'Deleting', 'Failed'
   */
  status?: ApplicationStatus;
  /**
   * @member {ApplicationParameter[]} [parameters] List of application
   * parameters with overridden values from their default values specified in
   * the application manifest.
   */
  parameters?: ApplicationParameter[];
  /**
   * @member {HealthState} [healthState] The health state of a Service Fabric
   * entity such as Cluster, Node, Application, Service, Partition, Replica
   * etc. Possible values include: 'Invalid', 'Ok', 'Warning', 'Error',
   * 'Unknown'
   */
  healthState?: HealthState;
  /**
   * @member {ApplicationDefinitionKind} [applicationDefinitionKind] The
   * mechanism used to define a Service Fabric application. Possible values
   * include: 'Invalid', 'ServiceFabricApplicationDescription', 'Compose'
   */
  applicationDefinitionKind?: ApplicationDefinitionKind;
}

/**
 * @interface
 * An interface representing ApplicationMetricDescription.
 * Describes capacity information for a custom resource balancing metric. This
 * can be used to limit the total consumption of this metric by the services of
 * this application.
 *
 */
export interface ApplicationMetricDescription {
  /**
   * @member {string} [name] The name of the metric.
   */
  name?: string;
  /**
   * @member {number} [maximumCapacity] The maximum node capacity for Service
   * Fabric application.
   * This is the maximum Load for an instance of this application on a single
   * node. Even if the capacity of node is greater than this value, Service
   * Fabric will limit the total load of services within the application on
   * each node to this value.
   * If set to zero, capacity for this metric is unlimited on each node.
   * When creating a new application with application capacity defined, the
   * product of MaximumNodes and this value must always be smaller than or
   * equal to TotalApplicationCapacity.
   * When updating existing application with application capacity, the product
   * of MaximumNodes and this value must always be smaller than or equal to
   * TotalApplicationCapacity.
   */
  maximumCapacity?: number;
  /**
   * @member {number} [reservationCapacity] The node reservation capacity for
   * Service Fabric application.
   * This is the amount of load which is reserved on nodes which have instances
   * of this application.
   * If MinimumNodes is specified, then the product of these values will be the
   * capacity reserved in the cluster for the application.
   * If set to zero, no capacity is reserved for this metric.
   * When setting application capacity or when updating application capacity;
   * this value must be smaller than or equal to MaximumCapacity for each
   * metric.
   */
  reservationCapacity?: number;
  /**
   * @member {number} [totalApplicationCapacity] The total metric capacity for
   * Service Fabric application.
   * This is the total metric capacity for this application in the cluster.
   * Service Fabric will try to limit the sum of loads of services within the
   * application to this value.
   * When creating a new application with application capacity defined, the
   * product of MaximumNodes and MaximumCapacity must always be smaller than or
   * equal to this value.
   */
  totalApplicationCapacity?: number;
}

/**
 * @interface
 * An interface representing ApplicationLoadInfo.
 * Load Information about a Service Fabric application.
 *
 */
export interface ApplicationLoadInfo {
  /**
   * @member {string} [id] The identity of the application. This is an encoded
   * representation of the application name. This is used in the REST APIs to
   * identify the application resource.
   * Starting in version 6.0, hierarchical names are delimited with the "\~"
   * character. For example, if the application name is "fabric:/myapp/app1",
   * the application identity would be "myapp\~app1" in 6.0+ and "myapp/app1"
   * in previous versions.
   */
  id?: string;
  /**
   * @member {number} [minimumNodes] The minimum number of nodes for this
   * application.
   * It is the number of nodes where Service Fabric will reserve Capacity in
   * the cluster which equals to ReservedLoad * MinimumNodes for this
   * Application instance.
   * For applications that do not have application capacity defined this value
   * will be zero.
   */
  minimumNodes?: number;
  /**
   * @member {number} [maximumNodes] The maximum number of nodes where this
   * application can be instantiated.
   * It is the number of nodes this application is allowed to span.
   * For applications that do not have application capacity defined this value
   * will be zero.
   */
  maximumNodes?: number;
  /**
   * @member {number} [nodeCount] The number of nodes on which this application
   * is instantiated.
   * For applications that do not have application capacity defined this value
   * will be zero.
   */
  nodeCount?: number;
  /**
   * @member {ApplicationMetricDescription[]}
   * [applicationLoadMetricInformation] List of application capacity metric
   * description.
   */
  applicationLoadMetricInformation?: ApplicationMetricDescription[];
}

/**
 * @interface
 * An interface representing ApplicationNameInfo.
 * Information about the application name.
 *
 */
export interface ApplicationNameInfo {
  /**
   * @member {string} [id] The identity of the application. This is an encoded
   * representation of the application name. This is used in the REST APIs to
   * identify the application resource.
   * Starting in version 6.0, hierarchical names are delimited with the "\~"
   * character. For example, if the application name is "fabric:/myapp/app1",
   * the application identity would be "myapp\~app1" in 6.0+ and "myapp/app1"
   * in previous versions.
   */
  id?: string;
  /**
   * @member {string} [name] The name of the application, including the
   * 'fabric:' URI scheme.
   */
  name?: string;
}

/**
 * @interface
 * An interface representing ApplicationsHealthEvaluation.
 * Represents health evaluation for applications, containing health evaluations
 * for each unhealthy application that impacted current aggregated health
 * state.
 *
 */
export interface ApplicationsHealthEvaluation {
  /**
   * @member {string} kind Polymorphic Discriminator
   */
  kind: "Applications";
  /**
   * @member {HealthState} [aggregatedHealthState] The health state of a
   * Service Fabric entity such as Cluster, Node, Application, Service,
   * Partition, Replica etc. Possible values include: 'Invalid', 'Ok',
   * 'Warning', 'Error', 'Unknown'
   */
  aggregatedHealthState?: HealthState;
  /**
   * @member {string} [description] Description of the health evaluation, which
   * represents a summary of the evaluation process.
   */
  description?: string;
  /**
   * @member {number} [maxPercentUnhealthyApplications] Maximum allowed
   * percentage of unhealthy applications from the ClusterHealthPolicy.
   */
  maxPercentUnhealthyApplications?: number;
  /**
   * @member {number} [totalCount] Total number of applications from the health
   * store.
   */
  totalCount?: number;
  /**
   * @member {HealthEvaluationWrapper[]} [unhealthyEvaluations] List of
   * unhealthy evaluations that led to the aggregated health state. Includes
   * all the unhealthy ApplicationHealthEvaluation that impacted the aggregated
   * health.
   */
  unhealthyEvaluations?: HealthEvaluationWrapper[];
}

/**
 * @interface
 * An interface representing ApplicationTypeApplicationsHealthEvaluation.
 * Represents health evaluation for applications of a particular application
 * type. The application type applications evaluation can be returned when
 * cluster health evaluation returns unhealthy aggregated health state, either
 * Error or Warning. It contains health evaluations for each unhealthy
 * application of the included application type that impacted current
 * aggregated health state.
 *
 */
export interface ApplicationTypeApplicationsHealthEvaluation {
  /**
   * @member {string} kind Polymorphic Discriminator
   */
  kind: "ApplicationTypeApplications";
  /**
   * @member {HealthState} [aggregatedHealthState] The health state of a
   * Service Fabric entity such as Cluster, Node, Application, Service,
   * Partition, Replica etc. Possible values include: 'Invalid', 'Ok',
   * 'Warning', 'Error', 'Unknown'
   */
  aggregatedHealthState?: HealthState;
  /**
   * @member {string} [description] Description of the health evaluation, which
   * represents a summary of the evaluation process.
   */
  description?: string;
  /**
   * @member {string} [applicationTypeName] The application type name as
   * defined in the application manifest.
   */
  applicationTypeName?: string;
  /**
   * @member {number} [maxPercentUnhealthyApplications] Maximum allowed
   * percentage of unhealthy applications for the application type, specified
   * as an entry in ApplicationTypeHealthPolicyMap.
   */
  maxPercentUnhealthyApplications?: number;
  /**
   * @member {number} [totalCount] Total number of applications of the
   * application type found in the health store.
   */
  totalCount?: number;
  /**
   * @member {HealthEvaluationWrapper[]} [unhealthyEvaluations] List of
   * unhealthy evaluations that led to the aggregated health state. Includes
   * all the unhealthy ApplicationHealthEvaluation of this application type
   * that impacted the aggregated health.
   */
  unhealthyEvaluations?: HealthEvaluationWrapper[];
}

/**
 * @interface
 * An interface representing ApplicationTypeHealthPolicyMapItem.
 * Defines an item in ApplicationTypeHealthPolicyMap.
 *
 */
export interface ApplicationTypeHealthPolicyMapItem {
  /**
   * @member {string} key The key of the application type health policy map
   * item. This is the name of the application type.
   */
  key: string;
  /**
   * @member {number} value The value of the application type health policy map
   * item.
   * The max percent unhealthy applications allowed for the application type.
   * Must be between zero and 100.
   */
  value: number;
}

/**
 * @interface
 * An interface representing ApplicationTypeInfo.
 * Information about an application type.
 *
 */
export interface ApplicationTypeInfo {
  /**
   * @member {string} [name] The application type name as defined in the
   * application manifest.
   */
  name?: string;
  /**
   * @member {string} [version] The version of the application type as defined
   * in the application manifest.
   */
  version?: string;
  /**
   * @member {ApplicationParameter[]} [defaultParameterList] List of
   * application type parameters that can be overridden when creating or
   * updating the application.
   */
  defaultParameterList?: ApplicationParameter[];
  /**
   * @member {ApplicationTypeStatus} [status] The status of the application
   * type. Possible values include: 'Invalid', 'Provisioning', 'Available',
   * 'Unprovisioning', 'Failed'
   */
  status?: ApplicationTypeStatus;
  /**
   * @member {string} [statusDetails] Additional detailed information about the
   * status of the application type.
   */
  statusDetails?: string;
  /**
   * @member {ApplicationTypeDefinitionKind} [applicationTypeDefinitionKind]
   * The mechanism used to define a Service Fabric application type. Possible
   * values include: 'Invalid', 'ServiceFabricApplicationPackage', 'Compose'
   */
  applicationTypeDefinitionKind?: ApplicationTypeDefinitionKind;
}

/**
 * @interface
 * An interface representing PagedApplicationTypeInfoList.
 * The list of application types that are provisioned or being provisioned in
 * the cluster. The list is paged when all of the results cannot fit in a
 * single message. The next set of results can be obtained by executing the
 * same query with the continuation token provided in this list.
 *
 */
export interface PagedApplicationTypeInfoList {
  /**
   * @member {string} [continuationToken] The continuation token parameter is
   * used to obtain next set of results. The continuation token is included in
   * the response of the API when the results from the system do not fit in a
   * single response. When this value is passed to the next API call, the API
   * returns next set of results. If there are no further results, then the
   * continuation token is not included in the response.
   */
  continuationToken?: string;
  /**
   * @member {ApplicationTypeInfo[]} [items] List of application type
   * information.
   */
  items?: ApplicationTypeInfo[];
}

/**
 * @interface
 * An interface representing ApplicationTypeManifest.
 * Contains the manifest describing an application type registered in a Service
 * Fabric cluster.
 *
 */
export interface ApplicationTypeManifest {
  /**
   * @member {string} [manifest] The XML manifest as a string.
   */
  manifest?: string;
}

/**
 * @interface
 * An interface representing MonitoringPolicyDescription.
 * Describes the parameters for monitoring an upgrade in Monitored mode.
 *
 */
export interface MonitoringPolicyDescription {
  /**
   * @member {FailureAction} [failureAction] The compensating action to perform
   * when a Monitored upgrade encounters monitoring policy or health policy
   * violations.
   * Invalid indicates the failure action is invalid. Rollback specifies that
   * the upgrade will start rolling back automatically.
   * Manual indicates that the upgrade will switch to UnmonitoredManual upgrade
   * mode. Possible values include: 'Invalid', 'Rollback', 'Manual'
   */
  failureAction?: FailureAction;
  /**
   * @member {string} [healthCheckWaitDurationInMilliseconds] The amount of
   * time to wait after completing an upgrade domain before applying health
   * policies. It is first interpreted as a string representing an ISO 8601
   * duration. If that fails, then it is interpreted as a number representing
   * the total number of milliseconds.
   */
  healthCheckWaitDurationInMilliseconds?: string;
  /**
   * @member {string} [healthCheckStableDurationInMilliseconds] The amount of
   * time that the application or cluster must remain healthy before the
   * upgrade proceeds to the next upgrade domain. It is first interpreted as a
   * string representing an ISO 8601 duration. If that fails, then it is
   * interpreted as a number representing the total number of milliseconds.
   */
  healthCheckStableDurationInMilliseconds?: string;
  /**
   * @member {string} [healthCheckRetryTimeoutInMilliseconds] The amount of
   * time to retry health evaluation when the application or cluster is
   * unhealthy before FailureAction is executed. It is first interpreted as a
   * string representing an ISO 8601 duration. If that fails, then it is
   * interpreted as a number representing the total number of milliseconds.
   */
  healthCheckRetryTimeoutInMilliseconds?: string;
  /**
   * @member {string} [upgradeTimeoutInMilliseconds] The amount of time the
   * overall upgrade has to complete before FailureAction is executed. It is
   * first interpreted as a string representing an ISO 8601 duration. If that
   * fails, then it is interpreted as a number representing the total number of
   * milliseconds.
   */
  upgradeTimeoutInMilliseconds?: string;
  /**
   * @member {string} [upgradeDomainTimeoutInMilliseconds] The amount of time
   * each upgrade domain has to complete before FailureAction is executed. It
   * is first interpreted as a string representing an ISO 8601 duration. If
   * that fails, then it is interpreted as a number representing the total
   * number of milliseconds.
   */
  upgradeDomainTimeoutInMilliseconds?: string;
}

/**
 * @interface
 * An interface representing ApplicationUpgradeDescription.
 * Describes the parameters for an application upgrade. Note that upgrade
 * description replaces the existing application description. This means that
 * if the parameters are not specified, the existing parameters on the
 * applications will be overwritten with the empty parameters list. This would
 * result in the application using the default value of the parameters from the
 * application manifest. If you do not want to change any existing parameter
 * values, please get the application parameters first using the
 * GetApplicationInfo query and then supply those values as Parameters in this
 * ApplicationUpgradeDescription.
 *
 */
export interface ApplicationUpgradeDescription {
  /**
   * @member {string} name The name of the target application, including the
   * 'fabric:' URI scheme.
   */
  name: string;
  /**
   * @member {string} targetApplicationTypeVersion The target application type
   * version (found in the application manifest) for the application upgrade.
   */
  targetApplicationTypeVersion: string;
  /**
   * @member {ApplicationParameter[]} parameters List of application parameters
   * with overridden values from their default values specified in the
   * application manifest.
   */
  parameters: ApplicationParameter[];
  /**
   * @member {UpgradeKind} upgradeKind The kind of upgrade out of the following
   * possible values. Possible values include: 'Invalid', 'Rolling'. Default
   * value: 'Rolling' .
   */
  upgradeKind: UpgradeKind;
  /**
   * @member {UpgradeMode} [rollingUpgradeMode] The mode used to monitor health
   * during a rolling upgrade. The values are UnmonitoredAuto,
   * UnmonitoredManual, and Monitored. Possible values include: 'Invalid',
   * 'UnmonitoredAuto', 'UnmonitoredManual', 'Monitored'. Default value:
   * 'UnmonitoredAuto' .
   */
  rollingUpgradeMode?: UpgradeMode;
  /**
   * @member {number} [upgradeReplicaSetCheckTimeoutInSeconds] The maximum
   * amount of time to block processing of an upgrade domain and prevent loss
   * of availability when there are unexpected issues. When this timeout
   * expires, processing of the upgrade domain will proceed regardless of
   * availability loss issues. The timeout is reset at the start of each
   * upgrade domain. Valid values are between 0 and 42949672925 inclusive.
   * (unsigned 32-bit integer).
   */
  upgradeReplicaSetCheckTimeoutInSeconds?: number;
  /**
   * @member {boolean} [forceRestart] If true, then processes are forcefully
   * restarted during upgrade even when the code version has not changed (the
   * upgrade only changes configuration or data).
   */
  forceRestart?: boolean;
  /**
   * @member {MonitoringPolicyDescription} [monitoringPolicy] Describes the
   * parameters for monitoring an upgrade in Monitored mode.
   */
  monitoringPolicy?: MonitoringPolicyDescription;
  /**
   * @member {ApplicationHealthPolicy} [applicationHealthPolicy] Defines a
   * health policy used to evaluate the health of an application or one of its
   * children entities.
   */
  applicationHealthPolicy?: ApplicationHealthPolicy;
}

/**
 * @interface
 * An interface representing UpgradeDomainInfo.
 * Information about an upgrade domain.
 *
 */
export interface UpgradeDomainInfo {
  /**
   * @member {string} [name] The name of the upgrade domain
   */
  name?: string;
  /**
   * @member {UpgradeDomainState} [state] The state of the upgrade domain.
   * Possible values include: 'Invalid', 'Pending', 'InProgress', 'Completed'
   */
  state?: UpgradeDomainState;
}

/**
 * Contains the possible cases for SafetyCheck.
 */
export type SafetyCheckUnion = SafetyCheck | PartitionSafetyCheckUnion | SeedNodeSafetyCheck;

/**
 * @interface
 * An interface representing SafetyCheck.
 * Represents a safety check performed by service fabric before continuing with
 * the operations. These checks ensure the availability of the service and the
 * reliability of the state.
 *
 */
export interface SafetyCheck {
  /**
   * @member {string} kind Polymorphic Discriminator
   */
  kind: "SafetyCheck";
}

/**
 * @interface
 * An interface representing SafetyCheckWrapper.
 * A wrapper for the safety check object. Safety checks are performed by
 * service fabric before continuing with the operations. These checks ensure
 * the availability of the service and the reliability of the state.
 *
 */
export interface SafetyCheckWrapper {
  /**
   * @member {SafetyCheckUnion} [safetyCheck] Represents a safety check
   * performed by service fabric before continuing with the operations. These
   * checks ensure the availability of the service and the reliability of the
   * state.
   */
  safetyCheck?: SafetyCheckUnion;
}

/**
 * @interface
 * An interface representing NodeUpgradeProgressInfo.
 * Information about the upgrading node and its status
 *
 */
export interface NodeUpgradeProgressInfo {
  /**
   * @member {string} [nodeName] The name of a Service Fabric node.
   */
  nodeName?: string;
  /**
   * @member {NodeUpgradePhase} [upgradePhase] The state of the upgrading node.
   * Possible values include: 'Invalid', 'PreUpgradeSafetyCheck', 'Upgrading',
   * 'PostUpgradeSafetyCheck'
   */
  upgradePhase?: NodeUpgradePhase;
  /**
   * @member {SafetyCheckWrapper[]} [pendingSafetyChecks] List of pending
   * safety checks
   */
  pendingSafetyChecks?: SafetyCheckWrapper[];
}

/**
 * @interface
 * An interface representing CurrentUpgradeDomainProgressInfo.
 * Information about the current in-progress upgrade domain.
 *
 */
export interface CurrentUpgradeDomainProgressInfo {
  /**
   * @member {string} [domainName] The name of the upgrade domain
   */
  domainName?: string;
  /**
   * @member {NodeUpgradeProgressInfo[]} [nodeUpgradeProgressList] List of
   * upgrading nodes and their statuses
   */
  nodeUpgradeProgressList?: NodeUpgradeProgressInfo[];
}

/**
 * @interface
 * An interface representing FailureUpgradeDomainProgressInfo.
 * Information about the upgrade domain progress at the time of upgrade
 * failure.
 *
 */
export interface FailureUpgradeDomainProgressInfo {
  /**
   * @member {string} [domainName] The name of the upgrade domain
   */
  domainName?: string;
  /**
   * @member {NodeUpgradeProgressInfo[]} [nodeUpgradeProgressList] List of
   * upgrading nodes and their statuses
   */
  nodeUpgradeProgressList?: NodeUpgradeProgressInfo[];
}

/**
 * @interface
 * An interface representing ApplicationUpgradeProgressInfo.
 * Describes the parameters for an application upgrade.
 *
 */
export interface ApplicationUpgradeProgressInfo {
  /**
   * @member {string} [name] The name of the target application, including the
   * 'fabric:' URI scheme.
   */
  name?: string;
  /**
   * @member {string} [typeName] The application type name as defined in the
   * application manifest.
   */
  typeName?: string;
  /**
   * @member {string} [targetApplicationTypeVersion] The target application
   * type version (found in the application manifest) for the application
   * upgrade.
   */
  targetApplicationTypeVersion?: string;
  /**
   * @member {UpgradeDomainInfo[]} [upgradeDomains] List of upgrade domains and
   * their statuses.
   */
  upgradeDomains?: UpgradeDomainInfo[];
  /**
   * @member {UpgradeState} [upgradeState] The state of the upgrade domain.
   * Possible values include: 'Invalid', 'RollingBackInProgress',
   * 'RollingBackCompleted', 'RollingForwardPending',
   * 'RollingForwardInProgress', 'RollingForwardCompleted', 'Failed'
   */
  upgradeState?: UpgradeState;
  /**
   * @member {string} [nextUpgradeDomain] The name of the next upgrade domain
   * to be processed.
   */
  nextUpgradeDomain?: string;
  /**
   * @member {UpgradeMode} [rollingUpgradeMode] The mode used to monitor health
   * during a rolling upgrade. The values are UnmonitoredAuto,
   * UnmonitoredManual, and Monitored. Possible values include: 'Invalid',
   * 'UnmonitoredAuto', 'UnmonitoredManual', 'Monitored'. Default value:
   * 'UnmonitoredAuto' .
   */
  rollingUpgradeMode?: UpgradeMode;
  /**
   * @member {ApplicationUpgradeDescription} [upgradeDescription] Describes the
   * parameters for an application upgrade. Note that upgrade description
   * replaces the existing application description. This means that if the
   * parameters are not specified, the existing parameters on the applications
   * will be overwritten with the empty parameters list. This would result in
   * the application using the default value of the parameters from the
   * application manifest. If you do not want to change any existing parameter
   * values, please get the application parameters first using the
   * GetApplicationInfo query and then supply those values as Parameters in
   * this ApplicationUpgradeDescription.
   */
  upgradeDescription?: ApplicationUpgradeDescription;
  /**
   * @member {string} [upgradeDurationInMilliseconds] The estimated total
   * amount of time spent processing the overall upgrade.
   */
  upgradeDurationInMilliseconds?: string;
  /**
   * @member {string} [upgradeDomainDurationInMilliseconds] The estimated total
   * amount of time spent processing the current upgrade domain.
   */
  upgradeDomainDurationInMilliseconds?: string;
  /**
   * @member {HealthEvaluationWrapper[]} [unhealthyEvaluations] List of health
   * evaluations that resulted in the current aggregated health state.
   */
  unhealthyEvaluations?: HealthEvaluationWrapper[];
  /**
   * @member {CurrentUpgradeDomainProgressInfo} [currentUpgradeDomainProgress]
   * Information about the current in-progress upgrade domain.
   */
  currentUpgradeDomainProgress?: CurrentUpgradeDomainProgressInfo;
  /**
   * @member {string} [startTimestampUtc] The estimated UTC datetime when the
   * upgrade started.
   */
  startTimestampUtc?: string;
  /**
   * @member {string} [failureTimestampUtc] The estimated UTC datetime when the
   * upgrade failed and FailureAction was executed.
   */
  failureTimestampUtc?: string;
  /**
   * @member {FailureReason} [failureReason] The cause of an upgrade failure
   * that resulted in FailureAction being executed. Possible values include:
   * 'None', 'Interrupted', 'HealthCheck', 'UpgradeDomainTimeout',
   * 'OverallUpgradeTimeout'
   */
  failureReason?: FailureReason;
  /**
   * @member {FailureUpgradeDomainProgressInfo}
   * [upgradeDomainProgressAtFailure] Information about the upgrade domain
   * progress at the time of upgrade failure.
   */
  upgradeDomainProgressAtFailure?: FailureUpgradeDomainProgressInfo;
  /**
   * @member {string} [upgradeStatusDetails] Additional detailed information
   * about the status of the pending upgrade.
   */
  upgradeStatusDetails?: string;
}

/**
 * @interface
 * An interface representing ClusterConfiguration.
 * Information about the standalone cluster configuration.
 *
 */
export interface ClusterConfiguration {
  /**
   * @member {string} [clusterConfiguration] The contents of the cluster
   * configuration file.
   */
  clusterConfiguration?: string;
}

/**
 * Contains the possible cases for ClusterEvent.
 */
export type ClusterEventUnion = ClusterEvent | ClusterHealthReportCreatedEvent | ClusterHealthReportExpiredEvent | ClusterUpgradeCompleteEvent | ClusterUpgradeDomainCompleteEvent | ClusterUpgradeRollbackCompleteEvent | ClusterUpgradeRollbackStartEvent | ClusterUpgradeStartEvent | ChaosStoppedEvent | ChaosStartedEvent;

/**
 * @interface
 * An interface representing ClusterEvent.
 * Represents the base for all Cluster Events.
 *
 */
export interface ClusterEvent {
  /**
   * @member {string} kind Polymorphic Discriminator
   */
  kind: "ClusterEvent";
  /**
   * @member {string} eventInstanceId The identifier for the FabricEvent
   * instance.
   */
  eventInstanceId: string;
  /**
   * @member {Date} timeStamp The time event was logged.
   */
  timeStamp: Date;
  /**
   * @member {boolean} [hasCorrelatedEvents] Shows there is existing related
   * events available.
   */
  hasCorrelatedEvents?: boolean;
}

/**
 * @interface
 * An interface representing NodeId.
 * An internal ID used by Service Fabric to uniquely identify a node. Node Id
 * is deterministically generated from node name.
 *
 */
export interface NodeId {
  /**
   * @member {string} [id] Value of the node Id. This is a 128 bit integer.
   */
  id?: string;
}

/**
 * @interface
 * An interface representing NodeHealthState.
 * Represents the health state of a node, which contains the node identifier
 * and its aggregated health state.
 *
 * @extends EntityHealthState
 */
export interface NodeHealthState extends EntityHealthState {
  /**
   * @member {string} [name] The name of a Service Fabric node.
   */
  name?: string;
  /**
   * @member {NodeId} [id] An internal ID used by Service Fabric to uniquely
   * identify a node. Node Id is deterministically generated from node name.
   */
  id?: NodeId;
}

/**
 * @interface
 * An interface representing ClusterHealth.
 * Represents the health of the cluster.
 * Contains the cluster aggregated health state, the cluster application and
 * node health states as well as the health events and the unhealthy
 * evaluations.
 *
 * @extends EntityHealth
 */
export interface ClusterHealth extends EntityHealth {
  /**
   * @member {NodeHealthState[]} [nodeHealthStates] Cluster node health states
   * as found in the health store.
   */
  nodeHealthStates?: NodeHealthState[];
  /**
   * @member {ApplicationHealthState[]} [applicationHealthStates] Cluster
   * application health states as found in the health store.
   */
  applicationHealthStates?: ApplicationHealthState[];
}

/**
 * @interface
 * An interface representing NodeHealthStateChunk.
 * Represents the health state chunk of a node, which contains the node name
 * and its aggregated health state.
 *
 * @extends EntityHealthStateChunk
 */
export interface NodeHealthStateChunk extends EntityHealthStateChunk {
  /**
   * @member {string} [nodeName] The name of a Service Fabric node.
   */
  nodeName?: string;
}

/**
 * @interface
 * An interface representing NodeHealthStateChunkList.
 * The list of node health state chunks in the cluster that respect the input
 * filters in the chunk query. Returned by get cluster health state chunks
 * query.
 *
 * @extends EntityHealthStateChunkList
 */
export interface NodeHealthStateChunkList extends EntityHealthStateChunkList {
  /**
   * @member {NodeHealthStateChunk[]} [items] The list of node health state
   * chunks that respect the input filters in the chunk query.
   */
  items?: NodeHealthStateChunk[];
}

/**
 * @interface
 * An interface representing ClusterHealthChunk.
 * Represents the health chunk of the cluster.
 * Contains the cluster aggregated health state, and the cluster entities that
 * respect the input filter.
 *
 */
export interface ClusterHealthChunk {
  /**
   * @member {HealthState} [healthState] The HealthState representing the
   * aggregated health state of the cluster computed by Health Manager.
   * The health evaluation of the entity reflects all events reported on the
   * entity and its children (if any).
   * The aggregation is done by applying the desired cluster health policy and
   * the application health policies. Possible values include: 'Invalid', 'Ok',
   * 'Warning', 'Error', 'Unknown'
   */
  healthState?: HealthState;
  /**
   * @member {NodeHealthStateChunkList} [nodeHealthStateChunks] The list of
   * node health state chunks in the cluster that respect the filters in the
   * cluster health chunk query description.
   */
  nodeHealthStateChunks?: NodeHealthStateChunkList;
  /**
   * @member {ApplicationHealthStateChunkList} [applicationHealthStateChunks]
   * The list of application health state chunks in the cluster that respect
   * the filters in the cluster health chunk query description.
   */
  applicationHealthStateChunks?: ApplicationHealthStateChunkList;
}

/**
 * @interface
 * An interface representing NodeHealthStateFilter.
 * Defines matching criteria to determine whether a node should be included in
 * the returned cluster health chunk.
 * One filter can match zero, one or multiple nodes, depending on its
 * properties.
 * Can be specified in the cluster health chunk query description.
 *
 */
export interface NodeHealthStateFilter {
  /**
   * @member {string} [nodeNameFilter] Name of the node that matches the
   * filter. The filter is applied only to the specified node, if it exists.
   * If the node doesn't exist, no node is returned in the cluster health chunk
   * based on this filter.
   * If the node exists, it is included in the cluster health chunk if the
   * health state matches the other filter properties.
   * If not specified, all nodes that match the parent filters (if any) are
   * taken into consideration and matched against the other filter members,
   * like health state filter.
   */
  nodeNameFilter?: string;
  /**
   * @member {number} [healthStateFilter] The filter for the health state of
   * the nodes. It allows selecting nodes if they match the desired health
   * states.
   * The possible values are integer value of one of the following health
   * states. Only nodes that match the filter are returned. All nodes are used
   * to evaluate the cluster aggregated health state.
   * If not specified, default value is None, unless the node name is
   * specified. If the filter has default value and node name is specified, the
   * matching node is returned.
   * The state values are flag-based enumeration, so the value could be a
   * combination of these values obtained using bitwise 'OR' operator.
   * For example, if the provided value is 6, it matches nodes with HealthState
   * value of OK (2) and Warning (4).
   *
   * - Default - Default value. Matches any HealthState. The value is zero.
   * - None - Filter that doesn't match any HealthState value. Used in order to
   * return no results on a given collection of states. The value is 1.
   * - Ok - Filter that matches input with HealthState value Ok. The value is
   * 2.
   * - Warning - Filter that matches input with HealthState value Warning. The
   * value is 4.
   * - Error - Filter that matches input with HealthState value Error. The
   * value is 8.
   * - All - Filter that matches input with any HealthState value. The value is
   * 65535. Default value: 0 .
   */
  healthStateFilter?: number;
}

/**
 * @interface
 * An interface representing ClusterHealthPolicy.
 * Defines a health policy used to evaluate the health of the cluster or of a
 * cluster node.
 *
 */
export interface ClusterHealthPolicy {
  /**
   * @member {boolean} [considerWarningAsError] Indicates whether warnings are
   * treated with the same severity as errors. Default value: false .
   */
  considerWarningAsError?: boolean;
  /**
   * @member {number} [maxPercentUnhealthyNodes] The maximum allowed percentage
   * of unhealthy nodes before reporting an error. For example, to allow 10% of
   * nodes to be unhealthy, this value would be 10.
   *
   * The percentage represents the maximum tolerated percentage of nodes that
   * can be unhealthy before the cluster is considered in error.
   * If the percentage is respected but there is at least one unhealthy node,
   * the health is evaluated as Warning.
   * The percentage is calculated by dividing the number of unhealthy nodes
   * over the total number of nodes in the cluster.
   * The computation rounds up to tolerate one failure on small numbers of
   * nodes. Default percentage is zero.
   *
   * In large clusters, some nodes will always be down or out for repairs, so
   * this percentage should be configured to tolerate that. Default value: 0 .
   */
  maxPercentUnhealthyNodes?: number;
  /**
   * @member {number} [maxPercentUnhealthyApplications] The maximum allowed
   * percentage of unhealthy applications before reporting an error. For
   * example, to allow 10% of applications to be unhealthy, this value would be
   * 10.
   *
   * The percentage represents the maximum tolerated percentage of applications
   * that can be unhealthy before the cluster is considered in error.
   * If the percentage is respected but there is at least one unhealthy
   * application, the health is evaluated as Warning.
   * This is calculated by dividing the number of unhealthy applications over
   * the total number of application instances in the cluster, excluding
   * applications of application types that are included in the
   * ApplicationTypeHealthPolicyMap.
   * The computation rounds up to tolerate one failure on small numbers of
   * applications. Default percentage is zero. Default value: 0 .
   */
  maxPercentUnhealthyApplications?: number;
  /**
   * @member {ApplicationTypeHealthPolicyMapItem[]}
   * [applicationTypeHealthPolicyMap] Defines a map with max percentage
   * unhealthy applications for specific application types.
   * Each entry specifies as key the application type name and as value an
   * integer that represents the MaxPercentUnhealthyApplications percentage
   * used to evaluate the applications of the specified application type.
   *
   * The application type health policy map can be used during cluster health
   * evaluation to describe special application types.
   * The application types included in the map are evaluated against the
   * percentage specified in the map, and not with the global
   * MaxPercentUnhealthyApplications defined in the cluster health policy.
   * The applications of application types specified in the map are not counted
   * against the global pool of applications.
   * For example, if some applications of a type are critical, the cluster
   * administrator can add an entry to the map for that application type
   * and assign it a value of 0% (that is, do not tolerate any failures).
   * All other applications can be evaluated with
   * MaxPercentUnhealthyApplications set to 20% to tolerate some failures out
   * of the thousands of application instances.
   * The application type health policy map is used only if the cluster
   * manifest enables application type health evaluation using the
   * configuration entry for
   * HealthManager/EnableApplicationTypeHealthEvaluation.
   */
  applicationTypeHealthPolicyMap?: ApplicationTypeHealthPolicyMapItem[];
}

/**
 * @interface
 * An interface representing ClusterHealthChunkQueryDescription.
 * The cluster health chunk query description, which can specify the health
 * policies to evaluate cluster health and very expressive filters to select
 * which cluster entities to include in response.
 *
 */
export interface ClusterHealthChunkQueryDescription {
  /**
   * @member {NodeHealthStateFilter[]} [nodeFilters] Defines a list of filters
   * that specify which nodes to be included in the returned cluster health
   * chunk.
   * If no filters are specified, no nodes are returned. All the nodes are used
   * to evaluate the cluster's aggregated health state, regardless of the input
   * filters.
   * The cluster health chunk query may specify multiple node filters.
   * For example, it can specify a filter to return all nodes with health state
   * Error and another filter to always include a node identified by its
   * NodeName.
   */
  nodeFilters?: NodeHealthStateFilter[];
  /**
   * @member {ApplicationHealthStateFilter[]} [applicationFilters] Defines a
   * list of filters that specify which applications to be included in the
   * returned cluster health chunk.
   * If no filters are specified, no applications are returned. All the
   * applications are used to evaluate the cluster's aggregated health state,
   * regardless of the input filters.
   * The cluster health chunk query may specify multiple application filters.
   * For example, it can specify a filter to return all applications with
   * health state Error and another filter to always include applications of a
   * specified application type.
   */
  applicationFilters?: ApplicationHealthStateFilter[];
  /**
   * @member {ClusterHealthPolicy} [clusterHealthPolicy] Defines a health
   * policy used to evaluate the health of the cluster or of a cluster node.
   */
  clusterHealthPolicy?: ClusterHealthPolicy;
  /**
   * @member {ApplicationHealthPolicies} [applicationHealthPolicies] Defines
   * the application health policy map used to evaluate the health of an
   * application or one of its children entities.
   */
  applicationHealthPolicies?: ApplicationHealthPolicies;
}

/**
 * @interface
 * An interface representing ClusterHealthPolicies.
 * Health policies to evaluate cluster health.
 *
 */
export interface ClusterHealthPolicies {
  /**
   * @member {ApplicationHealthPolicyMapItem[]} [applicationHealthPolicyMap]
   * Defines a map that contains specific application health policies for
   * different applications.
   * Each entry specifies as key the application name and as value an
   * ApplicationHealthPolicy used to evaluate the application health.
   * If an application is not specified in the map, the application health
   * evaluation uses the ApplicationHealthPolicy found in its application
   * manifest or the default application health policy (if no health policy is
   * defined in the manifest).
   * The map is empty by default.
   */
  applicationHealthPolicyMap?: ApplicationHealthPolicyMapItem[];
  /**
   * @member {ClusterHealthPolicy} [clusterHealthPolicy] Defines a health
   * policy used to evaluate the health of the cluster or of a cluster node.
   */
  clusterHealthPolicy?: ClusterHealthPolicy;
}

/**
 * @interface
 * An interface representing ClusterManifest.
 * Information about the cluster manifest.
 *
 */
export interface ClusterManifest {
  /**
   * @member {string} [manifest] The contents of the cluster manifest file.
   */
  manifest?: string;
}

/**
 * @interface
 * An interface representing ContainerApiRequestBody.
 * parameters for making container API call.
 *
 */
export interface ContainerApiRequestBody {
  /**
   * @member {string} [httpVerb] HTTP verb of container REST API, defaults to
   * "GET"
   */
  httpVerb?: string;
  /**
   * @member {string} uriPath URI path of container REST API
   */
  uriPath: string;
  /**
   * @member {string} [contentType] Content type of container REST API request,
   * defaults to "application/json"
   */
  contentType?: string;
  /**
   * @member {string} [body] HTTP request body of container REST API
   */
  body?: string;
}

/**
 * @interface
 * An interface representing ContainerApiResult.
 * Container API result.
 *
 */
export interface ContainerApiResult {
  /**
   * @member {number} status HTTP status code returned by the target container
   * API
   */
  status: number;
  /**
   * @member {string} [contentType] HTTP content type
   */
  contentType?: string;
  /**
   * @member {string} [contentEncoding] HTTP content encoding
   */
  contentEncoding?: string;
  /**
   * @member {string} [body] container API result body
   */
  body?: string;
}

/**
 * @interface
 * An interface representing ContainerApiResponse.
 * Response body that wraps container API result.
 *
 */
export interface ContainerApiResponse {
  /**
   * @member {ContainerApiResult} containerApiResult Container API result.
   */
  containerApiResult: ContainerApiResult;
}

/**
 * @interface
 * An interface representing ContainerInstanceEvent.
 * Represents the base for all Container Events.
 *
 */
export interface ContainerInstanceEvent {
  /**
   * @member {string} kind Polymorphic Discriminator
   */
  kind: "ContainerInstanceEvent";
  /**
   * @member {string} eventInstanceId The identifier for the FabricEvent
   * instance.
   */
  eventInstanceId: string;
  /**
   * @member {Date} timeStamp The time event was logged.
   */
  timeStamp: Date;
  /**
   * @member {boolean} [hasCorrelatedEvents] Shows there is existing related
   * events available.
   */
  hasCorrelatedEvents?: boolean;
}

/**
 * @interface
 * An interface representing DeactivationIntentDescription.
 * Describes the intent or reason for deactivating the node.
 *
 */
export interface DeactivationIntentDescription {
  /**
   * @member {DeactivationIntent} [deactivationIntent] Describes the intent or
   * reason for deactivating the node. The possible values are following.
   * Possible values include: 'Pause', 'Restart', 'RemoveData'
   */
  deactivationIntent?: DeactivationIntent;
}

/**
 * @interface
 * An interface representing DeltaNodesCheckHealthEvaluation.
 * Represents health evaluation for delta nodes, containing health evaluations
 * for each unhealthy node that impacted current aggregated health state.
 * Can be returned during cluster upgrade when the aggregated health state of
 * the cluster is Warning or Error.
 *
 */
export interface DeltaNodesCheckHealthEvaluation {
  /**
   * @member {string} kind Polymorphic Discriminator
   */
  kind: "DeltaNodesCheck";
  /**
   * @member {HealthState} [aggregatedHealthState] The health state of a
   * Service Fabric entity such as Cluster, Node, Application, Service,
   * Partition, Replica etc. Possible values include: 'Invalid', 'Ok',
   * 'Warning', 'Error', 'Unknown'
   */
  aggregatedHealthState?: HealthState;
  /**
   * @member {string} [description] Description of the health evaluation, which
   * represents a summary of the evaluation process.
   */
  description?: string;
  /**
   * @member {number} [baselineErrorCount] Number of nodes with aggregated
   * heath state Error in the health store at the beginning of the cluster
   * upgrade.
   */
  baselineErrorCount?: number;
  /**
   * @member {number} [baselineTotalCount] Total number of nodes in the health
   * store at the beginning of the cluster upgrade.
   */
  baselineTotalCount?: number;
  /**
   * @member {number} [maxPercentDeltaUnhealthyNodes] Maximum allowed
   * percentage of delta unhealthy nodes from the ClusterUpgradeHealthPolicy.
   */
  maxPercentDeltaUnhealthyNodes?: number;
  /**
   * @member {number} [totalCount] Total number of nodes in the health store.
   */
  totalCount?: number;
  /**
   * @member {HealthEvaluationWrapper[]} [unhealthyEvaluations] List of
   * unhealthy evaluations that led to the aggregated health state.
   * Includes all the unhealthy NodeHealthEvaluation that impacted the
   * aggregated health.
   */
  unhealthyEvaluations?: HealthEvaluationWrapper[];
}

/**
 * @interface
 * An interface representing DeployedServicePackageHealthState.
 * Represents the health state of a deployed service package, containing the
 * entity identifier and the aggregated health state.
 *
 * @extends EntityHealthState
 */
export interface DeployedServicePackageHealthState extends EntityHealthState {
  /**
   * @member {string} [nodeName] Name of the node on which the service package
   * is deployed.
   */
  nodeName?: string;
  /**
   * @member {string} [applicationName] The name of the application, including
   * the 'fabric:' URI scheme.
   */
  applicationName?: string;
  /**
   * @member {string} [serviceManifestName] Name of the manifest describing the
   * service package.
   */
  serviceManifestName?: string;
  /**
   * @member {string} [servicePackageActivationId] The ActivationId of a
   * deployed service package. If ServicePackageActivationMode specified at the
   * time of creating the service
   * is 'SharedProcess' (or if it is not specified, in which case it defaults
   * to 'SharedProcess'), then value of ServicePackageActivationId
   * is always an empty string.
   */
  servicePackageActivationId?: string;
}

/**
 * @interface
 * An interface representing DeployedApplicationHealth.
 * Information about the health of an application deployed on a Service Fabric
 * node.
 *
 * @extends EntityHealth
 */
export interface DeployedApplicationHealth extends EntityHealth {
  /**
   * @member {string} [name] Name of the application deployed on the node whose
   * health information is described by this object.
   */
  name?: string;
  /**
   * @member {string} [nodeName] Name of the node where this application is
   * deployed.
   */
  nodeName?: string;
  /**
   * @member {DeployedServicePackageHealthState[]}
   * [deployedServicePackageHealthStates] Deployed service package health
   * states for the current deployed application as found in the health store.
   */
  deployedServicePackageHealthStates?: DeployedServicePackageHealthState[];
}

/**
 * @interface
 * An interface representing DeployedApplicationHealthEvaluation.
 * Represents health evaluation for a deployed application, containing
 * information about the data and the algorithm used by the health store to
 * evaluate health.
 *
 */
export interface DeployedApplicationHealthEvaluation {
  /**
   * @member {string} kind Polymorphic Discriminator
   */
  kind: "DeployedApplication";
  /**
   * @member {HealthState} [aggregatedHealthState] The health state of a
   * Service Fabric entity such as Cluster, Node, Application, Service,
   * Partition, Replica etc. Possible values include: 'Invalid', 'Ok',
   * 'Warning', 'Error', 'Unknown'
   */
  aggregatedHealthState?: HealthState;
  /**
   * @member {string} [description] Description of the health evaluation, which
   * represents a summary of the evaluation process.
   */
  description?: string;
  /**
   * @member {string} [nodeName] Name of the node where the application is
   * deployed to.
   */
  nodeName?: string;
  /**
   * @member {string} [applicationName] The name of the application, including
   * the 'fabric:' URI scheme.
   */
  applicationName?: string;
  /**
   * @member {HealthEvaluationWrapper[]} [unhealthyEvaluations] List of
   * unhealthy evaluations that led to the current aggregated health state of
   * the deployed application.
   * The types of the unhealthy evaluations can be
   * DeployedServicePackagesHealthEvaluation or EventHealthEvaluation.
   */
  unhealthyEvaluations?: HealthEvaluationWrapper[];
}

/**
 * @interface
 * An interface representing DeployedApplicationInfo.
 * Information about application deployed on the node.
 *
 */
export interface DeployedApplicationInfo {
  /**
   * @member {string} [id] The identity of the application. This is an encoded
   * representation of the application name. This is used in the REST APIs to
   * identify the application resource.
   * Starting in version 6.0, hierarchical names are delimited with the "\~"
   * character. For example, if the application name is "fabric:/myapp/app1",
   * the application identity would be "myapp\~app1" in 6.0+ and "myapp/app1"
   * in previous versions.
   */
  id?: string;
  /**
   * @member {string} [name] The name of the application, including the
   * 'fabric:' URI scheme.
   */
  name?: string;
  /**
   * @member {string} [typeName] The application type name as defined in the
   * application manifest.
   */
  typeName?: string;
  /**
   * @member {DeployedApplicationStatus} [status] The status of the application
   * deployed on the node. Following are the possible values. Possible values
   * include: 'Invalid', 'Downloading', 'Activating', 'Active', 'Upgrading',
   * 'Deactivating'
   */
  status?: DeployedApplicationStatus;
  /**
   * @member {string} [workDirectory] The work directory of the application on
   * the node. The work directory can be used to store application data.
   */
  workDirectory?: string;
  /**
   * @member {string} [logDirectory] The log directory of the application on
   * the node. The log directory can be used to store application logs.
   */
  logDirectory?: string;
  /**
   * @member {string} [tempDirectory] The temp directory of the application on
   * the node. The code packages belonging to the application are forked with
   * this directory set as their temporary directory.
   */
  tempDirectory?: string;
  /**
   * @member {HealthState} [healthState] The health state of a Service Fabric
   * entity such as Cluster, Node, Application, Service, Partition, Replica
   * etc. Possible values include: 'Invalid', 'Ok', 'Warning', 'Error',
   * 'Unknown'
   */
  healthState?: HealthState;
}

/**
 * @interface
 * An interface representing DeployedApplicationsHealthEvaluation.
 * Represents health evaluation for deployed applications, containing health
 * evaluations for each unhealthy deployed application that impacted current
 * aggregated health state.
 * Can be returned when evaluating application health and the aggregated health
 * state is either Error or Warning.
 *
 */
export interface DeployedApplicationsHealthEvaluation {
  /**
   * @member {string} kind Polymorphic Discriminator
   */
  kind: "DeployedApplications";
  /**
   * @member {HealthState} [aggregatedHealthState] The health state of a
   * Service Fabric entity such as Cluster, Node, Application, Service,
   * Partition, Replica etc. Possible values include: 'Invalid', 'Ok',
   * 'Warning', 'Error', 'Unknown'
   */
  aggregatedHealthState?: HealthState;
  /**
   * @member {string} [description] Description of the health evaluation, which
   * represents a summary of the evaluation process.
   */
  description?: string;
  /**
   * @member {number} [maxPercentUnhealthyDeployedApplications] Maximum allowed
   * percentage of unhealthy deployed applications from the
   * ApplicationHealthPolicy.
   */
  maxPercentUnhealthyDeployedApplications?: number;
  /**
   * @member {number} [totalCount] Total number of deployed applications of the
   * application in the health store.
   */
  totalCount?: number;
  /**
   * @member {HealthEvaluationWrapper[]} [unhealthyEvaluations] List of
   * unhealthy evaluations that led to the aggregated health state. Includes
   * all the unhealthy DeployedApplicationHealthEvaluation that impacted the
   * aggregated health.
   */
  unhealthyEvaluations?: HealthEvaluationWrapper[];
}

/**
 * @interface
 * An interface representing DeployedServicePackageHealth.
 * Information about the health of a service package for a specific application
 * deployed on a Service Fabric node.
 *
 * @extends EntityHealth
 */
export interface DeployedServicePackageHealth extends EntityHealth {
  /**
   * @member {string} [applicationName] The name of the application, including
   * the 'fabric:' URI scheme.
   */
  applicationName?: string;
  /**
   * @member {string} [serviceManifestName] Name of the service manifest.
   */
  serviceManifestName?: string;
  /**
   * @member {string} [nodeName] Name of the node where this service package is
   * deployed.
   */
  nodeName?: string;
}

/**
 * @interface
 * An interface representing DeployedServicePackageHealthEvaluation.
 * Represents health evaluation for a deployed service package, containing
 * information about the data and the algorithm used by health store to
 * evaluate health. The evaluation is returned only when the aggregated health
 * state is either Error or Warning.
 *
 */
export interface DeployedServicePackageHealthEvaluation {
  /**
   * @member {string} kind Polymorphic Discriminator
   */
  kind: "DeployedServicePackage";
  /**
   * @member {HealthState} [aggregatedHealthState] The health state of a
   * Service Fabric entity such as Cluster, Node, Application, Service,
   * Partition, Replica etc. Possible values include: 'Invalid', 'Ok',
   * 'Warning', 'Error', 'Unknown'
   */
  aggregatedHealthState?: HealthState;
  /**
   * @member {string} [description] Description of the health evaluation, which
   * represents a summary of the evaluation process.
   */
  description?: string;
  /**
   * @member {string} [nodeName] The name of a Service Fabric node.
   */
  nodeName?: string;
  /**
   * @member {string} [applicationName] The name of the application, including
   * the 'fabric:' URI scheme.
   */
  applicationName?: string;
  /**
   * @member {string} [serviceManifestName] The name of the service manifest.
   */
  serviceManifestName?: string;
  /**
   * @member {HealthEvaluationWrapper[]} [unhealthyEvaluations] List of
   * unhealthy evaluations that led to the current aggregated health state. The
   * type of the unhealthy evaluations can be EventHealthEvaluation.
   */
  unhealthyEvaluations?: HealthEvaluationWrapper[];
}

/**
 * @interface
 * An interface representing DeployedServicePackagesHealthEvaluation.
 * Represents health evaluation for deployed service packages, containing
 * health evaluations for each unhealthy deployed service package that impacted
 * current aggregated health state. Can be returned when evaluating deployed
 * application health and the aggregated health state is either Error or
 * Warning.
 *
 */
export interface DeployedServicePackagesHealthEvaluation {
  /**
   * @member {string} kind Polymorphic Discriminator
   */
  kind: "DeployedServicePackages";
  /**
   * @member {HealthState} [aggregatedHealthState] The health state of a
   * Service Fabric entity such as Cluster, Node, Application, Service,
   * Partition, Replica etc. Possible values include: 'Invalid', 'Ok',
   * 'Warning', 'Error', 'Unknown'
   */
  aggregatedHealthState?: HealthState;
  /**
   * @member {string} [description] Description of the health evaluation, which
   * represents a summary of the evaluation process.
   */
  description?: string;
  /**
   * @member {number} [totalCount] Total number of deployed service packages of
   * the deployed application in the health store.
   */
  totalCount?: number;
  /**
   * @member {HealthEvaluationWrapper[]} [unhealthyEvaluations] List of
   * unhealthy evaluations that led to the aggregated health state. Includes
   * all the unhealthy DeployedServicePackageHealthEvaluation that impacted the
   * aggregated health.
   */
  unhealthyEvaluations?: HealthEvaluationWrapper[];
}

/**
 * Contains the possible cases for DeployedServiceReplicaInfo.
 */
export type DeployedServiceReplicaInfoUnion = DeployedServiceReplicaInfo | DeployedStatefulServiceReplicaInfo | DeployedStatelessServiceInstanceInfo;

/**
 * @interface
 * An interface representing DeployedServiceReplicaInfo.
 * Information about a Service Fabric service replica deployed on a node.
 *
 */
export interface DeployedServiceReplicaInfo {
  /**
   * @member {string} serviceKind Polymorphic Discriminator
   */
  serviceKind: "DeployedServiceReplicaInfo";
  /**
   * @member {string} [serviceName] The full name of the service with 'fabric:'
   * URI scheme.
   */
  serviceName?: string;
  /**
   * @member {string} [serviceTypeName] Name of the service type as specified
   * in the service manifest.
   */
  serviceTypeName?: string;
  /**
   * @member {string} [serviceManifestName] The name of the service manifest in
   * which this service type is defined.
   */
  serviceManifestName?: string;
  /**
   * @member {string} [codePackageName] The name of the code package that hosts
   * this replica.
   */
  codePackageName?: string;
  /**
   * @member {string} [partitionId] An internal ID used by Service Fabric to
   * uniquely identify a partition. This is a randomly generated GUID when the
   * service was created. The partition ID is unique and does not change for
   * the lifetime of the service. If the same service was deleted and recreated
   * the IDs of its partitions would be different.
   */
  partitionId?: string;
  /**
   * @member {ReplicaStatus} [replicaStatus] The status of a replica of a
   * service. Possible values include: 'Invalid', 'InBuild', 'Standby',
   * 'Ready', 'Down', 'Dropped'
   */
  replicaStatus?: ReplicaStatus;
  /**
   * @member {string} [address] The last address returned by the replica in
   * Open or ChangeRole.
   */
  address?: string;
  /**
   * @member {string} [servicePackageActivationId] The ActivationId of a
   * deployed service package. If ServicePackageActivationMode specified at the
   * time of creating the service
   * is 'SharedProcess' (or if it is not specified, in which case it defaults
   * to 'SharedProcess'), then value of ServicePackageActivationId
   * is always an empty string.
   */
  servicePackageActivationId?: string;
  /**
   * @member {string} [hostProcessId] Host process ID of the process that is
   * hosting the replica. This will be zero if the replica is down. In hyper-v
   * containers this host process ID will be from different kernel.
   */
  hostProcessId?: string;
}

/**
 * @interface
 * An interface representing ReconfigurationInformation.
 * Information about current reconfiguration like phase, type, previous
 * configuration role of replica and reconfiguration start date time.
 *
 */
export interface ReconfigurationInformation {
  /**
   * @member {ReplicaRole} [previousConfigurationRole] Replica role before
   * reconfiguration started. Possible values include: 'Unknown', 'None',
   * 'Primary', 'IdleSecondary', 'ActiveSecondary'
   */
  previousConfigurationRole?: ReplicaRole;
  /**
   * @member {ReconfigurationPhase} [reconfigurationPhase] Current phase of
   * ongoing reconfiguration. If no reconfiguration is taking place then this
   * value will be "None". Possible values include: 'Unknown', 'None',
   * 'Phase0', 'Phase1', 'Phase2', 'Phase3', 'Phase4', 'AbortPhaseZero'
   */
  reconfigurationPhase?: ReconfigurationPhase;
  /**
   * @member {ReconfigurationType} [reconfigurationType] Type of current
   * ongoing reconfiguration. If no reconfiguration is taking place then this
   * value will be "None". Possible values include: 'Unknown', 'SwapPrimary',
   * 'Failover', 'Other'
   */
  reconfigurationType?: ReconfigurationType;
  /**
   * @member {Date} [reconfigurationStartTimeUtc] Start time (in UTC) of the
   * ongoing reconfiguration. If no reconfiguration is taking place then this
   * value will be zero date-time.
   */
  reconfigurationStartTimeUtc?: Date;
}

/**
 * @interface
 * An interface representing DeployedStatefulServiceReplicaInfo.
 * Information about a stateful service replica deployed on a node.
 *
 */
export interface DeployedStatefulServiceReplicaInfo {
  /**
   * @member {string} serviceKind Polymorphic Discriminator
   */
  serviceKind: "Stateful";
  /**
   * @member {string} [serviceName] The full name of the service with 'fabric:'
   * URI scheme.
   */
  serviceName?: string;
  /**
   * @member {string} [serviceTypeName] Name of the service type as specified
   * in the service manifest.
   */
  serviceTypeName?: string;
  /**
   * @member {string} [serviceManifestName] The name of the service manifest in
   * which this service type is defined.
   */
  serviceManifestName?: string;
  /**
   * @member {string} [codePackageName] The name of the code package that hosts
   * this replica.
   */
  codePackageName?: string;
  /**
   * @member {string} [partitionId] An internal ID used by Service Fabric to
   * uniquely identify a partition. This is a randomly generated GUID when the
   * service was created. The partition ID is unique and does not change for
   * the lifetime of the service. If the same service was deleted and recreated
   * the IDs of its partitions would be different.
   */
  partitionId?: string;
  /**
   * @member {ReplicaStatus} [replicaStatus] The status of a replica of a
   * service. Possible values include: 'Invalid', 'InBuild', 'Standby',
   * 'Ready', 'Down', 'Dropped'
   */
  replicaStatus?: ReplicaStatus;
  /**
   * @member {string} [address] The last address returned by the replica in
   * Open or ChangeRole.
   */
  address?: string;
  /**
   * @member {string} [servicePackageActivationId] The ActivationId of a
   * deployed service package. If ServicePackageActivationMode specified at the
   * time of creating the service
   * is 'SharedProcess' (or if it is not specified, in which case it defaults
   * to 'SharedProcess'), then value of ServicePackageActivationId
   * is always an empty string.
   */
  servicePackageActivationId?: string;
  /**
   * @member {string} [hostProcessId] Host process ID of the process that is
   * hosting the replica. This will be zero if the replica is down. In hyper-v
   * containers this host process ID will be from different kernel.
   */
  hostProcessId?: string;
  /**
   * @member {string} [replicaId] Id of a stateful service replica. ReplicaId
   * is used by Service Fabric to uniquely identify a replica of a partition.
   * It is unique within a partition and does not change for the lifetime of
   * the replica. If a replica gets dropped and another replica gets created on
   * the same node for the same partition, it will get a different value for
   * the id. Sometimes the id of a stateless service instance is also referred
   * as a replica id.
   */
  replicaId?: string;
  /**
   * @member {ReplicaRole} [replicaRole] The role of a replica of a stateful
   * service. Possible values include: 'Unknown', 'None', 'Primary',
   * 'IdleSecondary', 'ActiveSecondary'
   */
  replicaRole?: ReplicaRole;
  /**
   * @member {ReconfigurationInformation} [reconfigurationInformation]
   * Information about current reconfiguration like phase, type, previous
   * configuration role of replica and reconfiguration start date time.
   */
  reconfigurationInformation?: ReconfigurationInformation;
}

/**
 * @interface
 * An interface representing DeployedStatelessServiceInstanceInfo.
 * Information about a stateless service instance deployed on a node.
 *
 */
export interface DeployedStatelessServiceInstanceInfo {
  /**
   * @member {string} serviceKind Polymorphic Discriminator
   */
  serviceKind: "Stateless";
  /**
   * @member {string} [serviceName] The full name of the service with 'fabric:'
   * URI scheme.
   */
  serviceName?: string;
  /**
   * @member {string} [serviceTypeName] Name of the service type as specified
   * in the service manifest.
   */
  serviceTypeName?: string;
  /**
   * @member {string} [serviceManifestName] The name of the service manifest in
   * which this service type is defined.
   */
  serviceManifestName?: string;
  /**
   * @member {string} [codePackageName] The name of the code package that hosts
   * this replica.
   */
  codePackageName?: string;
  /**
   * @member {string} [partitionId] An internal ID used by Service Fabric to
   * uniquely identify a partition. This is a randomly generated GUID when the
   * service was created. The partition ID is unique and does not change for
   * the lifetime of the service. If the same service was deleted and recreated
   * the IDs of its partitions would be different.
   */
  partitionId?: string;
  /**
   * @member {ReplicaStatus} [replicaStatus] The status of a replica of a
   * service. Possible values include: 'Invalid', 'InBuild', 'Standby',
   * 'Ready', 'Down', 'Dropped'
   */
  replicaStatus?: ReplicaStatus;
  /**
   * @member {string} [address] The last address returned by the replica in
   * Open or ChangeRole.
   */
  address?: string;
  /**
   * @member {string} [servicePackageActivationId] The ActivationId of a
   * deployed service package. If ServicePackageActivationMode specified at the
   * time of creating the service
   * is 'SharedProcess' (or if it is not specified, in which case it defaults
   * to 'SharedProcess'), then value of ServicePackageActivationId
   * is always an empty string.
   */
  servicePackageActivationId?: string;
  /**
   * @member {string} [hostProcessId] Host process ID of the process that is
   * hosting the replica. This will be zero if the replica is down. In hyper-v
   * containers this host process ID will be from different kernel.
   */
  hostProcessId?: string;
  /**
   * @member {string} [instanceId] Id of a stateless service instance.
   * InstanceId is used by Service Fabric to uniquely identify an instance of a
   * partition of a stateless service. It is unique within a partition and does
   * not change for the lifetime of the instance. If the instance has failed
   * over on the same or different node, it will get a different value for the
   * InstanceId.
   */
  instanceId?: string;
}

/**
 * @interface
 * An interface representing HealthInformation.
 * Represents common health report information. It is included in all health
 * reports sent to health store and in all health events returned by health
 * queries.
 *
 */
export interface HealthInformation {
  /**
   * @member {string} sourceId The source name that identifies the
   * client/watchdog/system component that generated the health information.
   */
  sourceId: string;
  /**
   * @member {string} property The property of the health information. An
   * entity can have health reports for different properties.
   * The property is a string and not a fixed enumeration to allow the reporter
   * flexibility to categorize the state condition that triggers the report.
   * For example, a reporter with SourceId "LocalWatchdog" can monitor the
   * state of the available disk on a node,
   * so it can report "AvailableDisk" property on that node.
   * The same reporter can monitor the node connectivity, so it can report a
   * property "Connectivity" on the same node.
   * In the health store, these reports are treated as separate health events
   * for the specified node.
   *
   * Together with the SourceId, the property uniquely identifies the health
   * information.
   */
  property: string;
  /**
   * @member {HealthState} healthState The health state of a Service Fabric
   * entity such as Cluster, Node, Application, Service, Partition, Replica
   * etc. Possible values include: 'Invalid', 'Ok', 'Warning', 'Error',
   * 'Unknown'
   */
  healthState: HealthState;
  /**
   * @member {string} [timeToLiveInMilliSeconds] The duration for which this
   * health report is valid. This field uses ISO8601 format for specifying the
   * duration.
   * When clients report periodically, they should send reports with higher
   * frequency than time to live.
   * If clients report on transition, they can set the time to live to
   * infinite.
   * When time to live expires, the health event that contains the health
   * information
   * is either removed from health store, if RemoveWhenExpired is true, or
   * evaluated at error, if RemoveWhenExpired false.
   *
   * If not specified, time to live defaults to infinite value.
   */
  timeToLiveInMilliSeconds?: string;
  /**
   * @member {string} [description] The description of the health information.
   * It represents free text used to add human readable information about the
   * report.
   * The maximum string length for the description is 4096 characters.
   * If the provided string is longer, it will be automatically truncated.
   * When truncated, the last characters of the description contain a marker
   * "[Truncated]", and total string size is 4096 characters.
   * The presence of the marker indicates to users that truncation occurred.
   * Note that when truncated, the description has less than 4096 characters
   * from the original string.
   */
  description?: string;
  /**
   * @member {string} [sequenceNumber] The sequence number for this health
   * report as a numeric string.
   * The report sequence number is used by the health store to detect stale
   * reports.
   * If not specified, a sequence number is auto-generated by the health client
   * when a report is added.
   */
  sequenceNumber?: string;
  /**
   * @member {boolean} [removeWhenExpired] Value that indicates whether the
   * report is removed from health store when it expires.
   * If set to true, the report is removed from the health store after it
   * expires.
   * If set to false, the report is treated as an error when expired. The value
   * of this property is false by default.
   * When clients report periodically, they should set RemoveWhenExpired false
   * (default).
   * This way, is the reporter has issues (eg. deadlock) and can't report, the
   * entity is evaluated at error when the health report expires.
   * This flags the entity as being in Error health state.
   */
  removeWhenExpired?: boolean;
}

/**
 * @interface
 * An interface representing HealthEvent.
 * Represents health information reported on a health entity, such as cluster,
 * application or node, with additional metadata added by the Health Manager.
 *
 * @extends HealthInformation
 */
export interface HealthEvent extends HealthInformation {
  /**
   * @member {boolean} [isExpired] Returns true if the health event is expired,
   * otherwise false.
   */
  isExpired?: boolean;
  /**
   * @member {Date} [sourceUtcTimestamp] The date and time when the health
   * report was sent by the source.
   */
  sourceUtcTimestamp?: Date;
  /**
   * @member {Date} [lastModifiedUtcTimestamp] The date and time when the
   * health report was last modified by the health store.
   */
  lastModifiedUtcTimestamp?: Date;
  /**
   * @member {Date} [lastOkTransitionAt] If the current health state is 'Ok',
   * this property returns the time at which the health report was first
   * reported with 'Ok'.
   * For periodic reporting, many reports with the same state may have been
   * generated.
   * This property returns the date and time when the first 'Ok' health report
   * was received.
   *
   * If the current health state is 'Error' or 'Warning', returns the date and
   * time at which the health state was last in 'Ok', before transitioning to a
   * different state.
   *
   * If the health state was never 'Ok', the value will be zero date-time.
   */
  lastOkTransitionAt?: Date;
  /**
   * @member {Date} [lastWarningTransitionAt] If the current health state is
   * 'Warning', this property returns the time at which the health report was
   * first reported with 'Warning'. For periodic reporting, many reports with
   * the same state may have been generated however, this property returns only
   * the date and time at the first 'Warning' health report was received.
   *
   * If the current health state is 'Ok' or 'Error', returns the date and time
   * at which the health state was last in 'Warning', before transitioning to a
   * different state.
   *
   * If the health state was never 'Warning', the value will be zero date-time.
   */
  lastWarningTransitionAt?: Date;
  /**
   * @member {Date} [lastErrorTransitionAt] If the current health state is
   * 'Error', this property returns the time at which the health report was
   * first reported with 'Error'. For periodic reporting, many reports with the
   * same state may have been generated however, this property returns only the
   * date and time at the first 'Error' health report was received.
   *
   * If the current health state is 'Ok' or 'Warning', returns the date and
   * time at which the health state was last in 'Error', before transitioning
   * to a different state.
   *
   * If the health state was never 'Error', the value will be zero date-time.
   */
  lastErrorTransitionAt?: Date;
}

/**
 * @interface
 * An interface representing HealthStateCount.
 * Represents information about how many health entities are in Ok, Warning and
 * Error health state.
 *
 */
export interface HealthStateCount {
  /**
   * @member {number} [okCount] The number of health entities with aggregated
   * health state Ok.
   */
  okCount?: number;
  /**
   * @member {number} [warningCount] The number of health entities with
   * aggregated health state Warning.
   */
  warningCount?: number;
  /**
   * @member {number} [errorCount] The number of health entities with
   * aggregated health state Error.
   */
  errorCount?: number;
}

/**
 * @interface
 * An interface representing EntityKindHealthStateCount.
 * Represents health state count for entities of the specified entity kind.
 *
 */
export interface EntityKindHealthStateCount {
  /**
   * @member {EntityKind} [entityKind] The entity kind for which health states
   * are evaluated. Possible values include: 'Invalid', 'Node', 'Partition',
   * 'Service', 'Application', 'Replica', 'DeployedApplication',
   * 'DeployedServicePackage', 'Cluster'
   */
  entityKind?: EntityKind;
  /**
   * @member {HealthStateCount} [healthStateCount] The health state count for
   * the entities of the specified kind.
   */
  healthStateCount?: HealthStateCount;
}

/**
 * @interface
 * An interface representing HealthStatistics.
 * The health statistics of an entity, returned as part of the health query
 * result when the query description is configured to include statistics.
 * The statistics include health state counts for all children types of the
 * current entity.
 * For example, for cluster, the health statistics include health state counts
 * for nodes, applications, services, partitions, replicas, deployed
 * applications and deployed service packages.
 * For partition, the health statistics include health counts for replicas.
 *
 */
export interface HealthStatistics {
  /**
   * @member {EntityKindHealthStateCount[]} [healthStateCountList] List of
   * health state counts per entity kind, which keeps track of how many
   * children of the queried entity are in Ok, Warning and Error state.
   */
  healthStateCountList?: EntityKindHealthStateCount[];
}

/**
 * @interface
 * An interface representing Epoch.
 * An Epoch is a configuration number for the partition as a whole. When the
 * configuration of the replica set changes, for example when the Primary
 * replica changes, the operations that are replicated from the new Primary
 * replica are said to be a new Epoch from the ones which were sent by the old
 * Primary replica.
 *
 */
export interface Epoch {
  /**
   * @member {string} [configurationVersion] The current configuration number
   * of this Epoch. The configuration number is an increasing value that is
   * updated whenever the configuration of this replica set changes.
   */
  configurationVersion?: string;
  /**
   * @member {string} [dataLossVersion] The current dataloss number of this
   * Epoch. The data loss number property is an increasing value which is
   * updated whenever data loss is suspected, as when loss of a quorum of
   * replicas in the replica set that includes the Primary replica.
   */
  dataLossVersion?: string;
}

/**
 * @interface
 * An interface representing BackupEpoch.
 * An Epoch is a configuration number for the partition as a whole. When the
 * configuration of the replica set changes, for example when the Primary
 * replica changes, the operations that are replicated from the new Primary
 * replica are said to be a new Epoch from the ones which were sent by the old
 * Primary replica.
 *
 */
export interface BackupEpoch {
  /**
   * @member {string} [configurationNumber] The current configuration number of
   * this Epoch. The configuration number is an increasing value that is
   * updated whenever the configuration of this replica set changes.
   */
  configurationNumber?: string;
  /**
   * @member {string} [dataLossNumber] The current dataloss number of this
   * Epoch. The data loss number property is an increasing value which is
   * updated whenever data loss is suspected, as when loss of a quorum of
   * replicas in the replica set that includes the Primary replica.
   */
  dataLossNumber?: string;
}

/**
 * @interface
 * An interface representing EventHealthEvaluation.
 * Represents health evaluation of a HealthEvent that was reported on the
 * entity.
 * The health evaluation is returned when evaluating health of an entity
 * results in Error or Warning.
 *
 */
export interface EventHealthEvaluation {
  /**
   * @member {string} kind Polymorphic Discriminator
   */
  kind: "Event";
  /**
   * @member {HealthState} [aggregatedHealthState] The health state of a
   * Service Fabric entity such as Cluster, Node, Application, Service,
   * Partition, Replica etc. Possible values include: 'Invalid', 'Ok',
   * 'Warning', 'Error', 'Unknown'
   */
  aggregatedHealthState?: HealthState;
  /**
   * @member {string} [description] Description of the health evaluation, which
   * represents a summary of the evaluation process.
   */
  description?: string;
  /**
   * @member {boolean} [considerWarningAsError] Indicates whether warnings are
   * treated with the same severity as errors. The field is specified in the
   * health policy used to evaluate the entity.
   */
  considerWarningAsError?: boolean;
  /**
   * @member {HealthEvent} [unhealthyEvent] Represents health information
   * reported on a health entity, such as cluster, application or node, with
   * additional metadata added by the Health Manager.
   */
  unhealthyEvent?: HealthEvent;
}

/**
 * @interface
 * An interface representing FabricCodeVersionInfo.
 * Information about a Service Fabric code version.
 *
 */
export interface FabricCodeVersionInfo {
  /**
   * @member {string} [codeVersion] The product version of Service Fabric.
   */
  codeVersion?: string;
}

/**
 * @interface
 * An interface representing FabricConfigVersionInfo.
 * Information about a Service Fabric config version.
 *
 */
export interface FabricConfigVersionInfo {
  /**
   * @member {string} [configVersion] The config version of Service Fabric.
   */
  configVersion?: string;
}

/**
 * @interface
 * An interface representing FabricErrorError.
 * Error object containing error code and error message.
 *
 */
export interface FabricErrorError {
  /**
   * @member {FabricErrorCodes} code Defines the fabric error codes that be
   * returned as part of the error object in response to Service Fabric API
   * operations that are not successful. Following are the error code values
   * that can be returned for a specific HTTP status code.
   *
   * - Possible values of the error code for HTTP status code 400 (Bad Request)
   * - "FABRIC_E_INVALID_PARTITION_KEY"
   * - "FABRIC_E_IMAGEBUILDER_VALIDATION_ERROR"
   * - "FABRIC_E_INVALID_ADDRESS"
   * - "FABRIC_E_APPLICATION_NOT_UPGRADING"
   * - "FABRIC_E_APPLICATION_UPGRADE_VALIDATION_ERROR"
   * - "FABRIC_E_FABRIC_NOT_UPGRADING"
   * - "FABRIC_E_FABRIC_UPGRADE_VALIDATION_ERROR"
   * - "FABRIC_E_INVALID_CONFIGURATION"
   * - "FABRIC_E_INVALID_NAME_URI"
   * - "FABRIC_E_PATH_TOO_LONG"
   * - "FABRIC_E_KEY_TOO_LARGE"
   * - "FABRIC_E_SERVICE_AFFINITY_CHAIN_NOT_SUPPORTED"
   * - "FABRIC_E_INVALID_ATOMIC_GROUP"
   * - "FABRIC_E_VALUE_EMPTY"
   * - "FABRIC_E_BACKUP_IS_ENABLED"
   * - "FABRIC_E_RESTORE_SOURCE_TARGET_PARTITION_MISMATCH"
   * - "FABRIC_E_INVALID_FOR_STATELESS_SERVICES"
   * - "FABRIC_E_INVALID_SERVICE_SCALING_POLICY"
   * - "E_INVALIDARG"
   *
   * - Possible values of the error code for HTTP status code 404 (Not Found)
   * - "FABRIC_E_NODE_NOT_FOUND"
   * - "FABRIC_E_APPLICATION_TYPE_NOT_FOUND"
   * - "FABRIC_E_APPLICATION_NOT_FOUND"
   * - "FABRIC_E_SERVICE_TYPE_NOT_FOUND"
   * - "FABRIC_E_SERVICE_DOES_NOT_EXIST"
   * - "FABRIC_E_SERVICE_TYPE_TEMPLATE_NOT_FOUND"
   * - "FABRIC_E_CONFIGURATION_SECTION_NOT_FOUND"
   * - "FABRIC_E_PARTITION_NOT_FOUND"
   * - "FABRIC_E_REPLICA_DOES_NOT_EXIST"
   * - "FABRIC_E_SERVICE_GROUP_DOES_NOT_EXIST"
   * - "FABRIC_E_CONFIGURATION_PARAMETER_NOT_FOUND"
   * - "FABRIC_E_DIRECTORY_NOT_FOUND"
   * - "FABRIC_E_FABRIC_VERSION_NOT_FOUND"
   * - "FABRIC_E_FILE_NOT_FOUND"
   * - "FABRIC_E_NAME_DOES_NOT_EXIST"
   * - "FABRIC_E_PROPERTY_DOES_NOT_EXIST"
   * - "FABRIC_E_ENUMERATION_COMPLETED"
   * - "FABRIC_E_SERVICE_MANIFEST_NOT_FOUND"
   * - "FABRIC_E_KEY_NOT_FOUND"
   * - "FABRIC_E_HEALTH_ENTITY_NOT_FOUND"
   * - "FABRIC_E_BACKUP_NOT_ENABLED"
   * - "FABRIC_E_BACKUP_POLICY_NOT_EXISTING"
   * - "FABRIC_E_FAULT_ANALYSIS_SERVICE_NOT_EXISTING"
   *
   * - Possible values of the error code for HTTP status code 409 (Conflict)
   * - "FABRIC_E_APPLICATION_TYPE_ALREADY_EXISTS"
   * - "FABRIC_E_APPLICATION_ALREADY_EXISTS"
   * - "FABRIC_E_APPLICATION_ALREADY_IN_TARGET_VERSION"
   * - "FABRIC_E_APPLICATION_TYPE_PROVISION_IN_PROGRESS"
   * - "FABRIC_E_APPLICATION_UPGRADE_IN_PROGRESS"
   * - "FABRIC_E_SERVICE_ALREADY_EXISTS"
   * - "FABRIC_E_SERVICE_GROUP_ALREADY_EXISTS"
   * - "FABRIC_E_APPLICATION_TYPE_IN_USE"
   * - "FABRIC_E_FABRIC_ALREADY_IN_TARGET_VERSION"
   * - "FABRIC_E_FABRIC_VERSION_ALREADY_EXISTS"
   * - "FABRIC_E_FABRIC_VERSION_IN_USE"
   * - "FABRIC_E_FABRIC_UPGRADE_IN_PROGRESS"
   * - "FABRIC_E_NAME_ALREADY_EXISTS"
   * - "FABRIC_E_NAME_NOT_EMPTY"
   * - "FABRIC_E_PROPERTY_CHECK_FAILED"
   * - "FABRIC_E_SERVICE_METADATA_MISMATCH"
   * - "FABRIC_E_SERVICE_TYPE_MISMATCH"
   * - "FABRIC_E_HEALTH_STALE_REPORT"
   * - "FABRIC_E_SEQUENCE_NUMBER_CHECK_FAILED"
   * - "FABRIC_E_NODE_HAS_NOT_STOPPED_YET"
   * - "FABRIC_E_INSTANCE_ID_MISMATCH"
   * - "FABRIC_E_BACKUP_IN_PROGRESS"
   * - "FABRIC_E_RESTORE_IN_PROGRESS"
   * - "FABRIC_E_BACKUP_POLICY_ALREADY_EXISTING"
   *
   * - Possible values of the error code for HTTP status code 413 (Request
   * Entity Too Large)
   * - "FABRIC_E_VALUE_TOO_LARGE"
   *
   * - Possible values of the error code for HTTP status code 500 (Internal
   * Server Error)
   * - "FABRIC_E_NODE_IS_UP"
   * - "E_FAIL"
   * - "FABRIC_E_SINGLE_INSTANCE_APPLICATION_ALREADY_EXISTS"
   * - "FABRIC_E_SINGLE_INSTANCE_APPLICATION_NOT_FOUND"
   * - "FABRIC_E_VOLUME_ALREADY_EXISTS"
   * - "ABRIC_E_VOLUME_NOT_FOUND"
   * - "SerializationError"
   *
   * - Possible values of the error code for HTTP status code 503 (Service
   * Unavailable)
   * - "FABRIC_E_NO_WRITE_QUORUM"
   * - "FABRIC_E_NOT_PRIMARY"
   * - "FABRIC_E_NOT_READY"
   * - "FABRIC_E_RECONFIGURATION_PENDING"
   * - "FABRIC_E_SERVICE_OFFLINE"
   * - "E_ABORT"
   * - "FABRIC_E_VALUE_TOO_LARGE"
   *
   * - Possible values of the error code for HTTP status code 504 (Gateway
   * Timeout)
   * - "FABRIC_E_COMMUNICATION_ERROR"
   * - "FABRIC_E_OPERATION_NOT_COMPLETE"
   * - "FABRIC_E_TIMEOUT". Possible values include:
   * 'FABRIC_E_INVALID_PARTITION_KEY',
   * 'FABRIC_E_IMAGEBUILDER_VALIDATION_ERROR', 'FABRIC_E_INVALID_ADDRESS',
   * 'FABRIC_E_APPLICATION_NOT_UPGRADING',
   * 'FABRIC_E_APPLICATION_UPGRADE_VALIDATION_ERROR',
   * 'FABRIC_E_FABRIC_NOT_UPGRADING',
   * 'FABRIC_E_FABRIC_UPGRADE_VALIDATION_ERROR',
   * 'FABRIC_E_INVALID_CONFIGURATION', 'FABRIC_E_INVALID_NAME_URI',
   * 'FABRIC_E_PATH_TOO_LONG', 'FABRIC_E_KEY_TOO_LARGE',
   * 'FABRIC_E_SERVICE_AFFINITY_CHAIN_NOT_SUPPORTED',
   * 'FABRIC_E_INVALID_ATOMIC_GROUP', 'FABRIC_E_VALUE_EMPTY',
   * 'FABRIC_E_NODE_NOT_FOUND', 'FABRIC_E_APPLICATION_TYPE_NOT_FOUND',
   * 'FABRIC_E_APPLICATION_NOT_FOUND', 'FABRIC_E_SERVICE_TYPE_NOT_FOUND',
   * 'FABRIC_E_SERVICE_DOES_NOT_EXIST',
   * 'FABRIC_E_SERVICE_TYPE_TEMPLATE_NOT_FOUND',
   * 'FABRIC_E_CONFIGURATION_SECTION_NOT_FOUND',
   * 'FABRIC_E_PARTITION_NOT_FOUND', 'FABRIC_E_REPLICA_DOES_NOT_EXIST',
   * 'FABRIC_E_SERVICE_GROUP_DOES_NOT_EXIST',
   * 'FABRIC_E_CONFIGURATION_PARAMETER_NOT_FOUND',
   * 'FABRIC_E_DIRECTORY_NOT_FOUND', 'FABRIC_E_FABRIC_VERSION_NOT_FOUND',
   * 'FABRIC_E_FILE_NOT_FOUND', 'FABRIC_E_NAME_DOES_NOT_EXIST',
   * 'FABRIC_E_PROPERTY_DOES_NOT_EXIST', 'FABRIC_E_ENUMERATION_COMPLETED',
   * 'FABRIC_E_SERVICE_MANIFEST_NOT_FOUND', 'FABRIC_E_KEY_NOT_FOUND',
   * 'FABRIC_E_HEALTH_ENTITY_NOT_FOUND',
   * 'FABRIC_E_APPLICATION_TYPE_ALREADY_EXISTS',
   * 'FABRIC_E_APPLICATION_ALREADY_EXISTS',
   * 'FABRIC_E_APPLICATION_ALREADY_IN_TARGET_VERSION',
   * 'FABRIC_E_APPLICATION_TYPE_PROVISION_IN_PROGRESS',
   * 'FABRIC_E_APPLICATION_UPGRADE_IN_PROGRESS',
   * 'FABRIC_E_SERVICE_ALREADY_EXISTS',
   * 'FABRIC_E_SERVICE_GROUP_ALREADY_EXISTS',
   * 'FABRIC_E_APPLICATION_TYPE_IN_USE',
   * 'FABRIC_E_FABRIC_ALREADY_IN_TARGET_VERSION',
   * 'FABRIC_E_FABRIC_VERSION_ALREADY_EXISTS',
   * 'FABRIC_E_FABRIC_VERSION_IN_USE', 'FABRIC_E_FABRIC_UPGRADE_IN_PROGRESS',
   * 'FABRIC_E_NAME_ALREADY_EXISTS', 'FABRIC_E_NAME_NOT_EMPTY',
   * 'FABRIC_E_PROPERTY_CHECK_FAILED', 'FABRIC_E_SERVICE_METADATA_MISMATCH',
   * 'FABRIC_E_SERVICE_TYPE_MISMATCH', 'FABRIC_E_HEALTH_STALE_REPORT',
   * 'FABRIC_E_SEQUENCE_NUMBER_CHECK_FAILED',
   * 'FABRIC_E_NODE_HAS_NOT_STOPPED_YET', 'FABRIC_E_INSTANCE_ID_MISMATCH',
   * 'FABRIC_E_VALUE_TOO_LARGE', 'FABRIC_E_NO_WRITE_QUORUM',
   * 'FABRIC_E_NOT_PRIMARY', 'FABRIC_E_NOT_READY',
   * 'FABRIC_E_RECONFIGURATION_PENDING', 'FABRIC_E_SERVICE_OFFLINE', 'E_ABORT',
   * 'FABRIC_E_COMMUNICATION_ERROR', 'FABRIC_E_OPERATION_NOT_COMPLETE',
   * 'FABRIC_E_TIMEOUT', 'FABRIC_E_NODE_IS_UP', 'E_FAIL',
   * 'FABRIC_E_BACKUP_IS_ENABLED',
   * 'FABRIC_E_RESTORE_SOURCE_TARGET_PARTITION_MISMATCH',
   * 'FABRIC_E_INVALID_FOR_STATELESS_SERVICES', 'FABRIC_E_BACKUP_NOT_ENABLED',
   * 'FABRIC_E_BACKUP_POLICY_NOT_EXISTING',
   * 'FABRIC_E_FAULT_ANALYSIS_SERVICE_NOT_EXISTING',
   * 'FABRIC_E_BACKUP_IN_PROGRESS', 'FABRIC_E_RESTORE_IN_PROGRESS',
   * 'FABRIC_E_BACKUP_POLICY_ALREADY_EXISTING',
   * 'FABRIC_E_INVALID_SERVICE_SCALING_POLICY', 'E_INVALIDARG',
   * 'FABRIC_E_SINGLE_INSTANCE_APPLICATION_ALREADY_EXISTS',
   * 'FABRIC_E_SINGLE_INSTANCE_APPLICATION_NOT_FOUND',
   * 'FABRIC_E_VOLUME_ALREADY_EXISTS', 'FABRIC_E_VOLUME_NOT_FOUND',
   * 'SerializationError'
   */
  code: FabricErrorCodes;
  /**
   * @member {string} [message] Error message.
   */
  message?: string;
}

/**
 * @interface
 * An interface representing FabricError.
 * The REST API operations for Service Fabric return standard HTTP status
 * codes. This type defines the additional information returned from the
 * Service Fabric API operations that are not successful.
 *
 */
export interface FabricError {
  /**
   * @member {FabricErrorError} error Error object containing error code and
   * error message.
   */
  error: FabricErrorError;
}

/**
 * @interface
 * An interface representing ClusterConfigurationUpgradeStatusInfo.
 * Information about a standalone cluster configuration upgrade status.
 *
 */
export interface ClusterConfigurationUpgradeStatusInfo {
  /**
   * @member {UpgradeState} [upgradeState] The state of the upgrade domain.
   * Possible values include: 'Invalid', 'RollingBackInProgress',
   * 'RollingBackCompleted', 'RollingForwardPending',
   * 'RollingForwardInProgress', 'RollingForwardCompleted', 'Failed'
   */
  upgradeState?: UpgradeState;
  /**
   * @member {number} [progressStatus] The cluster manifest version.
   */
  progressStatus?: number;
  /**
   * @member {string} [configVersion] The cluster configuration version.
   */
  configVersion?: string;
  /**
   * @member {string} [details] The cluster upgrade status details.
   */
  details?: string;
}

/**
 * Contains the possible cases for PartitionInformation.
 */
export type PartitionInformationUnion = PartitionInformation | Int64RangePartitionInformation | NamedPartitionInformation | SingletonPartitionInformation;

/**
 * @interface
 * An interface representing PartitionInformation.
 * Information about the partition identity, partitioning scheme and keys
 * supported by it.
 *
 */
export interface PartitionInformation {
  /**
   * @member {string} servicePartitionKind Polymorphic Discriminator
   */
  servicePartitionKind: "PartitionInformation";
  /**
   * @member {string} [id] An internal ID used by Service Fabric to uniquely
   * identify a partition. This is a randomly generated GUID when the service
   * was created. The partition ID is unique and does not change for the
   * lifetime of the service. If the same service was deleted and recreated the
   * IDs of its partitions would be different.
   */
  id?: string;
}

/**
 * @interface
 * An interface representing Int64RangePartitionInformation.
 * Describes the partition information for the integer range that is based on
 * partition schemes.
 *
 */
export interface Int64RangePartitionInformation {
  /**
   * @member {string} servicePartitionKind Polymorphic Discriminator
   */
  servicePartitionKind: "Int64Range";
  /**
   * @member {string} [id] An internal ID used by Service Fabric to uniquely
   * identify a partition. This is a randomly generated GUID when the service
   * was created. The partition ID is unique and does not change for the
   * lifetime of the service. If the same service was deleted and recreated the
   * IDs of its partitions would be different.
   */
  id?: string;
  /**
   * @member {string} [lowKey] Specifies the minimum key value handled by this
   * partition.
   */
  lowKey?: string;
  /**
   * @member {string} [highKey] Specifies the maximum key value handled by this
   * partition.
   */
  highKey?: string;
}

/**
 * @interface
 * An interface representing NamedPartitionInformation.
 * Describes the partition information for the name as a string that is based
 * on partition schemes.
 *
 */
export interface NamedPartitionInformation {
  /**
   * @member {string} servicePartitionKind Polymorphic Discriminator
   */
  servicePartitionKind: "Named";
  /**
   * @member {string} [id] An internal ID used by Service Fabric to uniquely
   * identify a partition. This is a randomly generated GUID when the service
   * was created. The partition ID is unique and does not change for the
   * lifetime of the service. If the same service was deleted and recreated the
   * IDs of its partitions would be different.
   */
  id?: string;
  /**
   * @member {string} [name] Name of the partition.
   */
  name?: string;
}

/**
 * @interface
 * An interface representing NodeDeactivationTaskId.
 * Identity of the task related to deactivation operation on the node.
 *
 */
export interface NodeDeactivationTaskId {
  /**
   * @member {string} [id] Value of the task id.
   */
  id?: string;
  /**
   * @member {NodeDeactivationTaskType} [nodeDeactivationTaskType] The type of
   * the task that performed the node deactivation. Following are the possible
   * values. Possible values include: 'Invalid', 'Infrastructure', 'Repair',
   * 'Client'
   */
  nodeDeactivationTaskType?: NodeDeactivationTaskType;
}

/**
 * @interface
 * An interface representing NodeDeactivationTask.
 * The task representing the deactivation operation on the node.
 *
 */
export interface NodeDeactivationTask {
  /**
   * @member {NodeDeactivationTaskId} [nodeDeactivationTaskId] Identity of the
   * task related to deactivation operation on the node.
   */
  nodeDeactivationTaskId?: NodeDeactivationTaskId;
  /**
   * @member {NodeDeactivationIntent} [nodeDeactivationIntent] The intent or
   * the reason for deactivating the node. Following are the possible values
   * for it. Possible values include: 'Invalid', 'Pause', 'Restart',
   * 'RemoveData', 'RemoveNode'
   */
  nodeDeactivationIntent?: NodeDeactivationIntent;
}

/**
 * @interface
 * An interface representing NodeDeactivationInfo.
 * Information about the node deactivation. This information is valid for a
 * node that is undergoing deactivation or has already been deactivated.
 *
 */
export interface NodeDeactivationInfo {
  /**
   * @member {NodeDeactivationIntent} [nodeDeactivationIntent] The intent or
   * the reason for deactivating the node. Following are the possible values
   * for it. Possible values include: 'Invalid', 'Pause', 'Restart',
   * 'RemoveData', 'RemoveNode'
   */
  nodeDeactivationIntent?: NodeDeactivationIntent;
  /**
   * @member {NodeDeactivationStatus} [nodeDeactivationStatus] The status of
   * node deactivation operation. Following are the possible values. Possible
   * values include: 'None', 'SafetyCheckInProgress', 'SafetyCheckComplete',
   * 'Completed'
   */
  nodeDeactivationStatus?: NodeDeactivationStatus;
  /**
   * @member {NodeDeactivationTask[]} [nodeDeactivationTask] List of tasks
   * representing the deactivation operation on the node.
   */
  nodeDeactivationTask?: NodeDeactivationTask[];
  /**
   * @member {SafetyCheckWrapper[]} [pendingSafetyChecks] List of pending
   * safety checks
   */
  pendingSafetyChecks?: SafetyCheckWrapper[];
}

/**
 * Contains the possible cases for NodeEvent.
 */
export type NodeEventUnion = NodeEvent | NodeAbortedEvent | NodeAbortingEvent | NodeAddedEvent | NodeCloseEvent | NodeClosingEvent | NodeDeactivateCompleteEvent | NodeDeactivateStartEvent | NodeDownEvent | NodeHealthReportCreatedEvent | NodeHealthReportExpiredEvent | NodeOpenedSuccessEvent | NodeOpenFailedEvent | NodeOpeningEvent | NodeRemovedEvent | NodeUpEvent | ChaosRestartNodeFaultCompletedEvent | ChaosRestartNodeFaultScheduledEvent;

/**
 * @interface
 * An interface representing NodeEvent.
 * Represents the base for all Node Events.
 *
 */
export interface NodeEvent {
  /**
   * @member {string} kind Polymorphic Discriminator
   */
  kind: "NodeEvent";
  /**
   * @member {string} eventInstanceId The identifier for the FabricEvent
   * instance.
   */
  eventInstanceId: string;
  /**
   * @member {Date} timeStamp The time event was logged.
   */
  timeStamp: Date;
  /**
   * @member {boolean} [hasCorrelatedEvents] Shows there is existing related
   * events available.
   */
  hasCorrelatedEvents?: boolean;
  /**
   * @member {string} nodeName The name of a Service Fabric node.
   */
  nodeName: string;
}

/**
 * @interface
 * An interface representing NodeHealth.
 * Information about the health of a Service Fabric node.
 *
 * @extends EntityHealth
 */
export interface NodeHealth extends EntityHealth {
  /**
   * @member {string} [name] Name of the node whose health information is
   * described by this object.
   */
  name?: string;
}

/**
 * @interface
 * An interface representing NodeHealthEvaluation.
 * Represents health evaluation for a node, containing information about the
 * data and the algorithm used by health store to evaluate health. The
 * evaluation is returned only when the aggregated health state is either Error
 * or Warning.
 *
 */
export interface NodeHealthEvaluation {
  /**
   * @member {string} kind Polymorphic Discriminator
   */
  kind: "Node";
  /**
   * @member {HealthState} [aggregatedHealthState] The health state of a
   * Service Fabric entity such as Cluster, Node, Application, Service,
   * Partition, Replica etc. Possible values include: 'Invalid', 'Ok',
   * 'Warning', 'Error', 'Unknown'
   */
  aggregatedHealthState?: HealthState;
  /**
   * @member {string} [description] Description of the health evaluation, which
   * represents a summary of the evaluation process.
   */
  description?: string;
  /**
   * @member {string} [nodeName] The name of a Service Fabric node.
   */
  nodeName?: string;
  /**
   * @member {HealthEvaluationWrapper[]} [unhealthyEvaluations] List of
   * unhealthy evaluations that led to the current aggregated health state of
   * the node. The types of the unhealthy evaluations can be
   * EventHealthEvaluation.
   */
  unhealthyEvaluations?: HealthEvaluationWrapper[];
}

/**
 * @interface
 * An interface representing NodeInfo.
 * Information about a node in Service Fabric cluster.
 *
 */
export interface NodeInfo {
  /**
   * @member {string} [name] The name of a Service Fabric node.
   */
  name?: string;
  /**
   * @member {string} [ipAddressOrFQDN] The IP address or fully qualified
   * domain name of the node.
   */
  ipAddressOrFQDN?: string;
  /**
   * @member {string} [type] The type of the node.
   */
  type?: string;
  /**
   * @member {string} [codeVersion] The version of Service Fabric binaries that
   * the node is running.
   */
  codeVersion?: string;
  /**
   * @member {string} [configVersion] The version of Service Fabric cluster
   * manifest that the node is using.
   */
  configVersion?: string;
  /**
   * @member {NodeStatus} [nodeStatus] The status of the node. Possible values
   * include: 'Invalid', 'Up', 'Down', 'Enabling', 'Disabling', 'Disabled',
   * 'Unknown', 'Removed'
   */
  nodeStatus?: NodeStatus;
  /**
   * @member {string} [nodeUpTimeInSeconds] Time in seconds since the node has
   * been in NodeStatus Up. Value zero indicates that the node is not Up.
   */
  nodeUpTimeInSeconds?: string;
  /**
   * @member {HealthState} [healthState] The health state of a Service Fabric
   * entity such as Cluster, Node, Application, Service, Partition, Replica
   * etc. Possible values include: 'Invalid', 'Ok', 'Warning', 'Error',
   * 'Unknown'
   */
  healthState?: HealthState;
  /**
   * @member {boolean} [isSeedNode] Indicates if the node is a seed node or
   * not. Returns true if the node is a seed node, otherwise false. A quorum of
   * seed nodes are required for proper operation of Service Fabric cluster.
   */
  isSeedNode?: boolean;
  /**
   * @member {string} [upgradeDomain] The upgrade domain of the node.
   */
  upgradeDomain?: string;
  /**
   * @member {string} [faultDomain] The fault domain of the node.
   */
  faultDomain?: string;
  /**
   * @member {NodeId} [id] An internal ID used by Service Fabric to uniquely
   * identify a node. Node Id is deterministically generated from node name.
   */
  id?: NodeId;
  /**
   * @member {string} [instanceId] The ID representing the node instance. While
   * the ID of the node is deterministically generated from the node name and
   * remains same across restarts, the InstanceId changes every time node
   * restarts.
   */
  instanceId?: string;
  /**
   * @member {NodeDeactivationInfo} [nodeDeactivationInfo] Information about
   * the node deactivation. This information is valid for a node that is
   * undergoing deactivation or has already been deactivated.
   */
  nodeDeactivationInfo?: NodeDeactivationInfo;
  /**
   * @member {boolean} [isStopped] Indicates if the node is stopped by calling
   * stop node API or not. Returns true if the node is stopped, otherwise
   * false.
   */
  isStopped?: boolean;
  /**
   * @member {string} [nodeDownTimeInSeconds] Time in seconds since the node
   * has been in NodeStatus Down. Value zero indicates node is not NodeStatus
   * Down.
   */
  nodeDownTimeInSeconds?: string;
  /**
   * @member {Date} [nodeUpAt] Date time in UTC when the node came up. If the
   * node has never been up then this value will be zero date time.
   */
  nodeUpAt?: Date;
  /**
   * @member {Date} [nodeDownAt] Date time in UTC when the node went down. If
   * node has never been down then this value will be zero date time.
   */
  nodeDownAt?: Date;
}

/**
 * @interface
 * An interface representing NodeLoadMetricInformation.
 * Represents data structure that contains load information for a certain
 * metric on a node.
 *
 */
export interface NodeLoadMetricInformation {
  /**
   * @member {string} [name] Name of the metric for which this load information
   * is provided.
   */
  name?: string;
  /**
   * @member {string} [nodeCapacity] Total capacity on the node for this
   * metric.
   */
  nodeCapacity?: string;
  /**
   * @member {string} [nodeLoad] Current load on the node for this metric.
   */
  nodeLoad?: string;
  /**
   * @member {string} [nodeRemainingCapacity] The remaining capacity on the
   * node for this metric.
   */
  nodeRemainingCapacity?: string;
  /**
   * @member {boolean} [isCapacityViolation] Indicates if there is a capacity
   * violation for this metric on the node.
   */
  isCapacityViolation?: boolean;
  /**
   * @member {string} [nodeBufferedCapacity] The value that indicates the
   * reserved capacity for this metric on the node.
   */
  nodeBufferedCapacity?: string;
  /**
   * @member {string} [nodeRemainingBufferedCapacity] The remaining reserved
   * capacity for this metric on the node.
   */
  nodeRemainingBufferedCapacity?: string;
}

/**
 * @interface
 * An interface representing NodeLoadInfo.
 * Information about load on a Service Fabric node. It holds a summary of all
 * metrics and their load on a node.
 *
 */
export interface NodeLoadInfo {
  /**
   * @member {string} [nodeName] Name of the node for which the load
   * information is provided by this object.
   */
  nodeName?: string;
  /**
   * @member {NodeLoadMetricInformation[]} [nodeLoadMetricInformation] List
   * that contains metrics and their load information on this node.
   */
  nodeLoadMetricInformation?: NodeLoadMetricInformation[];
}

/**
 * @interface
 * An interface representing NodesHealthEvaluation.
 * Represents health evaluation for nodes, containing health evaluations for
 * each unhealthy node that impacted current aggregated health state. Can be
 * returned when evaluating cluster health and the aggregated health state is
 * either Error or Warning.
 *
 */
export interface NodesHealthEvaluation {
  /**
   * @member {string} kind Polymorphic Discriminator
   */
  kind: "Nodes";
  /**
   * @member {HealthState} [aggregatedHealthState] The health state of a
   * Service Fabric entity such as Cluster, Node, Application, Service,
   * Partition, Replica etc. Possible values include: 'Invalid', 'Ok',
   * 'Warning', 'Error', 'Unknown'
   */
  aggregatedHealthState?: HealthState;
  /**
   * @member {string} [description] Description of the health evaluation, which
   * represents a summary of the evaluation process.
   */
  description?: string;
  /**
   * @member {number} [maxPercentUnhealthyNodes] Maximum allowed percentage of
   * unhealthy nodes from the ClusterHealthPolicy.
   */
  maxPercentUnhealthyNodes?: number;
  /**
   * @member {number} [totalCount] Total number of nodes found in the health
   * store.
   */
  totalCount?: number;
  /**
   * @member {HealthEvaluationWrapper[]} [unhealthyEvaluations] List of
   * unhealthy evaluations that led to the aggregated health state. Includes
   * all the unhealthy NodeHealthEvaluation that impacted the aggregated
   * health.
   */
  unhealthyEvaluations?: HealthEvaluationWrapper[];
}

/**
 * @interface
 * An interface representing PagedApplicationInfoList.
 * The list of applications in the cluster. The list is paged when all of the
 * results cannot fit in a single message. The next set of results can be
 * obtained by executing the same query with the continuation token provided in
 * this list.
 *
 */
export interface PagedApplicationInfoList {
  /**
   * @member {string} [continuationToken] The continuation token parameter is
   * used to obtain next set of results. The continuation token is included in
   * the response of the API when the results from the system do not fit in a
   * single response. When this value is passed to the next API call, the API
   * returns next set of results. If there are no further results, then the
   * continuation token is not included in the response.
   */
  continuationToken?: string;
  /**
   * @member {ApplicationInfo[]} [items] List of application information.
   */
  items?: ApplicationInfo[];
}

/**
 * @interface
 * An interface representing PagedDeployedApplicationInfoList.
 * The list of deployed applications in activating, downloading, or active
 * states on a node.
 * The list is paged when all of the results cannot fit in a single message.
 * The next set of results can be obtained by executing the same query with the
 * continuation token provided in this list.
 *
 */
export interface PagedDeployedApplicationInfoList {
  /**
   * @member {string} [continuationToken] The continuation token parameter is
   * used to obtain next set of results. The continuation token is included in
   * the response of the API when the results from the system do not fit in a
   * single response. When this value is passed to the next API call, the API
   * returns next set of results. If there are no further results, then the
   * continuation token is not included in the response.
   */
  continuationToken?: string;
  /**
   * @member {DeployedApplicationInfo[]} [items] List of deployed application
   * information.
   */
  items?: DeployedApplicationInfo[];
}

/**
 * @interface
 * An interface representing PagedNodeInfoList.
 * The list of nodes in the cluster. The list is paged when all of the results
 * cannot fit in a single message. The next set of results can be obtained by
 * executing the same query with the continuation token provided in this list.
 *
 */
export interface PagedNodeInfoList {
  /**
   * @member {string} [continuationToken] The continuation token parameter is
   * used to obtain next set of results. The continuation token is included in
   * the response of the API when the results from the system do not fit in a
   * single response. When this value is passed to the next API call, the API
   * returns next set of results. If there are no further results, then the
   * continuation token is not included in the response.
   */
  continuationToken?: string;
  /**
   * @member {NodeInfo[]} [items] List of node information.
   */
  items?: NodeInfo[];
}

/**
 * Contains the possible cases for ServicePartitionInfo.
 */
export type ServicePartitionInfoUnion = ServicePartitionInfo | StatefulServicePartitionInfo | StatelessServicePartitionInfo;

/**
 * @interface
 * An interface representing ServicePartitionInfo.
 * Information about a partition of a Service Fabric service.
 *
 */
export interface ServicePartitionInfo {
  /**
   * @member {string} serviceKind Polymorphic Discriminator
   */
  serviceKind: "ServicePartitionInfo";
  /**
   * @member {HealthState} [healthState] The health state of a Service Fabric
   * entity such as Cluster, Node, Application, Service, Partition, Replica
   * etc. Possible values include: 'Invalid', 'Ok', 'Warning', 'Error',
   * 'Unknown'
   */
  healthState?: HealthState;
  /**
   * @member {ServicePartitionStatus} [partitionStatus] The status of the
   * service fabric service partition. Possible values include: 'Invalid',
   * 'Ready', 'NotReady', 'InQuorumLoss', 'Reconfiguring', 'Deleting'
   */
  partitionStatus?: ServicePartitionStatus;
  /**
   * @member {PartitionInformationUnion} [partitionInformation] Information
   * about the partition identity, partitioning scheme and keys supported by
   * it.
   */
  partitionInformation?: PartitionInformationUnion;
}

/**
 * @interface
 * An interface representing PagedServicePartitionInfoList.
 * The list of partition in the cluster for a service. The list is paged when
 * all of the results cannot fit in a single message. The next set of results
 * can be obtained by executing the same query with the continuation token
 * provided in this list.
 *
 */
export interface PagedServicePartitionInfoList {
  /**
   * @member {string} [continuationToken] The continuation token parameter is
   * used to obtain next set of results. The continuation token is included in
   * the response of the API when the results from the system do not fit in a
   * single response. When this value is passed to the next API call, the API
   * returns next set of results. If there are no further results, then the
   * continuation token is not included in the response.
   */
  continuationToken?: string;
  /**
   * @member {ServicePartitionInfoUnion[]} [items] List of service partition
   * information.
   */
  items?: ServicePartitionInfoUnion[];
}

/**
 * Contains the possible cases for ReplicaInfo.
 */
export type ReplicaInfoUnion = ReplicaInfo | StatefulServiceReplicaInfo | StatelessServiceInstanceInfo;

/**
 * @interface
 * An interface representing ReplicaInfo.
 * Information about the identity, status, health, node name, uptime, and other
 * details about the replica.
 *
 */
export interface ReplicaInfo {
  /**
   * @member {string} serviceKind Polymorphic Discriminator
   */
  serviceKind: "ReplicaInfo";
  /**
   * @member {ReplicaStatus} [replicaStatus] The status of a replica of a
   * service. Possible values include: 'Invalid', 'InBuild', 'Standby',
   * 'Ready', 'Down', 'Dropped'
   */
  replicaStatus?: ReplicaStatus;
  /**
   * @member {HealthState} [healthState] The health state of a Service Fabric
   * entity such as Cluster, Node, Application, Service, Partition, Replica
   * etc. Possible values include: 'Invalid', 'Ok', 'Warning', 'Error',
   * 'Unknown'
   */
  healthState?: HealthState;
  /**
   * @member {string} [nodeName] The name of a Service Fabric node.
   */
  nodeName?: string;
  /**
   * @member {string} [address] The address the replica is listening on.
   */
  address?: string;
  /**
   * @member {string} [lastInBuildDurationInSeconds] The last in build duration
   * of the replica in seconds.
   */
  lastInBuildDurationInSeconds?: string;
}

/**
 * @interface
 * An interface representing PagedReplicaInfoList.
 * The list of replicas in the cluster for a given partition. The list is paged
 * when all of the results cannot fit in a single message. The next set of
 * results can be obtained by executing the same query with the continuation
 * token provided in this list.
 *
 */
export interface PagedReplicaInfoList {
  /**
   * @member {string} [continuationToken] The continuation token parameter is
   * used to obtain next set of results. The continuation token is included in
   * the response of the API when the results from the system do not fit in a
   * single response. When this value is passed to the next API call, the API
   * returns next set of results. If there are no further results, then the
   * continuation token is not included in the response.
   */
  continuationToken?: string;
  /**
   * @member {ReplicaInfoUnion[]} [items] List of replica information.
   */
  items?: ReplicaInfoUnion[];
}

/**
 * Contains the possible cases for ServiceInfo.
 */
export type ServiceInfoUnion = ServiceInfo | StatefulServiceInfo | StatelessServiceInfo;

/**
 * @interface
 * An interface representing ServiceInfo.
 * Information about a Service Fabric service.
 *
 */
export interface ServiceInfo {
  /**
   * @member {string} serviceKind Polymorphic Discriminator
   */
  serviceKind: "ServiceInfo";
  /**
   * @member {string} [id] The identity of the service. This ID is an encoded
   * representation of the service name. This is used in the REST APIs to
   * identify the service resource.
   * Starting in version 6.0, hierarchical names are delimited with the "\~"
   * character. For example, if the service name is "fabric:/myapp/app1/svc1",
   * the service identity would be "myapp~app1\~svc1" in 6.0+ and
   * "myapp/app1/svc1" in previous versions.
   */
  id?: string;
  /**
   * @member {string} [name] The full name of the service with 'fabric:' URI
   * scheme.
   */
  name?: string;
  /**
   * @member {string} [typeName] Name of the service type as specified in the
   * service manifest.
   */
  typeName?: string;
  /**
   * @member {string} [manifestVersion] The version of the service manifest.
   */
  manifestVersion?: string;
  /**
   * @member {HealthState} [healthState] The health state of a Service Fabric
   * entity such as Cluster, Node, Application, Service, Partition, Replica
   * etc. Possible values include: 'Invalid', 'Ok', 'Warning', 'Error',
   * 'Unknown'
   */
  healthState?: HealthState;
  /**
   * @member {ServiceStatus} [serviceStatus] The status of the application.
   * Possible values include: 'Unknown', 'Active', 'Upgrading', 'Deleting',
   * 'Creating', 'Failed'
   */
  serviceStatus?: ServiceStatus;
  /**
   * @member {boolean} [isServiceGroup] Whether the service is in a service
   * group.
   */
  isServiceGroup?: boolean;
}

/**
 * @interface
 * An interface representing PagedServiceInfoList.
 * The list of services in the cluster for an application. The list is paged
 * when all of the results cannot fit in a single message. The next set of
 * results can be obtained by executing the same query with the continuation
 * token provided in this list.
 *
 */
export interface PagedServiceInfoList {
  /**
   * @member {string} [continuationToken] The continuation token parameter is
   * used to obtain next set of results. The continuation token is included in
   * the response of the API when the results from the system do not fit in a
   * single response. When this value is passed to the next API call, the API
   * returns next set of results. If there are no further results, then the
   * continuation token is not included in the response.
   */
  continuationToken?: string;
  /**
   * @member {ServiceInfoUnion[]} [items] List of service information.
   */
  items?: ServiceInfoUnion[];
}

/**
 * Contains the possible cases for PartitionEvent.
 */
export type PartitionEventUnion = PartitionEvent | PartitionAnalysisEventUnion | PartitionHealthReportCreatedEvent | PartitionHealthReportExpiredEvent | PartitionReconfigurationCompletedEvent | ChaosMoveSecondaryFaultScheduledEvent | ChaosMovePrimaryFaultScheduledEvent;

/**
 * @interface
 * An interface representing PartitionEvent.
 * Represents the base for all Partition Events.
 *
 */
export interface PartitionEvent {
  /**
   * @member {string} kind Polymorphic Discriminator
   */
  kind: "PartitionEvent";
  /**
   * @member {string} eventInstanceId The identifier for the FabricEvent
   * instance.
   */
  eventInstanceId: string;
  /**
   * @member {Date} timeStamp The time event was logged.
   */
  timeStamp: Date;
  /**
   * @member {boolean} [hasCorrelatedEvents] Shows there is existing related
   * events available.
   */
  hasCorrelatedEvents?: boolean;
  /**
   * @member {string} partitionId An internal ID used by Service Fabric to
   * uniquely identify a partition. This is a randomly generated GUID when the
   * service was created. The partition ID is unique and does not change for
   * the lifetime of the service. If the same service was deleted and recreated
   * the IDs of its partitions would be different.
   */
  partitionId: string;
}

/**
 * Contains the possible cases for PartitionAnalysisEvent.
 */
export type PartitionAnalysisEventUnion = PartitionAnalysisEvent | PartitionPrimaryMoveAnalysisEvent;

/**
 * @interface
 * An interface representing PartitionAnalysisEvent.
 * Represents the base for all Partition Analysis Events.
 *
 */
export interface PartitionAnalysisEvent {
  /**
   * @member {string} kind Polymorphic Discriminator
   */
  kind: "PartitionAnalysisEvent";
  /**
   * @member {string} eventInstanceId The identifier for the FabricEvent
   * instance.
   */
  eventInstanceId: string;
  /**
   * @member {Date} timeStamp The time event was logged.
   */
  timeStamp: Date;
  /**
   * @member {boolean} [hasCorrelatedEvents] Shows there is existing related
   * events available.
   */
  hasCorrelatedEvents?: boolean;
  /**
   * @member {string} partitionId An internal ID used by Service Fabric to
   * uniquely identify a partition. This is a randomly generated GUID when the
   * service was created. The partition ID is unique and does not change for
   * the lifetime of the service. If the same service was deleted and recreated
   * the IDs of its partitions would be different.
   */
  partitionId: string;
  /**
   * @member {AnalysisEventMetadata} metadata Metadata about an Analysis Event.
   */
  metadata: AnalysisEventMetadata;
}

/**
 * Contains the possible cases for ReplicaHealthState.
 */
export type ReplicaHealthStateUnion = ReplicaHealthState | StatefulServiceReplicaHealthState | StatelessServiceInstanceHealthState;

/**
 * @interface
 * An interface representing ReplicaHealthState.
 * Represents a base class for stateful service replica or stateless service
 * instance health state.
 *
 */
export interface ReplicaHealthState {
  /**
   * @member {string} serviceKind Polymorphic Discriminator
   */
  serviceKind: "ReplicaHealthState";
  /**
   * @member {HealthState} [aggregatedHealthState] The health state of a
   * Service Fabric entity such as Cluster, Node, Application, Service,
   * Partition, Replica etc. Possible values include: 'Invalid', 'Ok',
   * 'Warning', 'Error', 'Unknown'
   */
  aggregatedHealthState?: HealthState;
  /**
   * @member {string} [partitionId] The ID of the partition to which this
   * replica belongs.
   */
  partitionId?: string;
}

/**
 * @interface
 * An interface representing PartitionHealth.
 * Information about the health of a Service Fabric partition.
 *
 * @extends EntityHealth
 */
export interface PartitionHealth extends EntityHealth {
  /**
   * @member {string} [partitionId] ID of the partition whose health
   * information is described by this object.
   */
  partitionId?: string;
  /**
   * @member {ReplicaHealthStateUnion[]} [replicaHealthStates] The list of
   * replica health states associated with the partition.
   */
  replicaHealthStates?: ReplicaHealthStateUnion[];
}

/**
 * @interface
 * An interface representing PartitionHealthEvaluation.
 * Represents health evaluation for a partition, containing information about
 * the data and the algorithm used by health store to evaluate health. The
 * evaluation is returned only when the aggregated health state is either Error
 * or Warning.
 *
 */
export interface PartitionHealthEvaluation {
  /**
   * @member {string} kind Polymorphic Discriminator
   */
  kind: "Partition";
  /**
   * @member {HealthState} [aggregatedHealthState] The health state of a
   * Service Fabric entity such as Cluster, Node, Application, Service,
   * Partition, Replica etc. Possible values include: 'Invalid', 'Ok',
   * 'Warning', 'Error', 'Unknown'
   */
  aggregatedHealthState?: HealthState;
  /**
   * @member {string} [description] Description of the health evaluation, which
   * represents a summary of the evaluation process.
   */
  description?: string;
  /**
   * @member {string} [partitionId] Id of the partition whose health evaluation
   * is described by this object.
   */
  partitionId?: string;
  /**
   * @member {HealthEvaluationWrapper[]} [unhealthyEvaluations] List of
   * unhealthy evaluations that led to the current aggregated health state of
   * the partition. The types of the unhealthy evaluations can be
   * ReplicasHealthEvaluation or EventHealthEvaluation.
   */
  unhealthyEvaluations?: HealthEvaluationWrapper[];
}

/**
 * @interface
 * An interface representing PartitionHealthState.
 * Represents the health state of a partition, which contains the partition
 * identifier and its aggregated health state.
 *
 * @extends EntityHealthState
 */
export interface PartitionHealthState extends EntityHealthState {
  /**
   * @member {string} [partitionId] Id of the partition whose health state is
   * described by this object.
   */
  partitionId?: string;
}

/**
 * @interface
 * An interface representing ProvisionFabricDescription.
 * Describes the parameters for provisioning a cluster.
 *
 */
export interface ProvisionFabricDescription {
  /**
   * @member {string} [codeFilePath] The cluster code package file path.
   */
  codeFilePath?: string;
  /**
   * @member {string} [clusterManifestFilePath] The cluster manifest file path.
   */
  clusterManifestFilePath?: string;
}

/**
 * Contains the possible cases for ProvisionApplicationTypeDescriptionBase.
 */
export type ProvisionApplicationTypeDescriptionBaseUnion = ProvisionApplicationTypeDescriptionBase | ProvisionApplicationTypeDescription | ExternalStoreProvisionApplicationTypeDescription;

/**
 * @interface
 * An interface representing ProvisionApplicationTypeDescriptionBase.
 * Represents the type of registration or provision requested, and if the
 * operation needs to be asynchronous or not. Supported types of provision
 * operations are from either image store or external store.
 *
 */
export interface ProvisionApplicationTypeDescriptionBase {
  /**
   * @member {string} kind Polymorphic Discriminator
   */
  kind: "ProvisionApplicationTypeDescriptionBase";
  /**
   * @member {boolean} async Indicates whether or not provisioning should occur
   * asynchronously. When set to true, the provision operation returns when the
   * request is accepted by the system, and the provision operation continues
   * without any timeout limit. The default value is false. For large
   * application packages, we recommend setting the value to true.
   */
  async: boolean;
}

/**
 * @interface
 * An interface representing ProvisionApplicationTypeDescription.
 * Describes the operation to register or provision an application type using
 * an application package uploaded to the Service Fabric image store.
 *
 */
export interface ProvisionApplicationTypeDescription {
  /**
   * @member {string} kind Polymorphic Discriminator
   */
  kind: "ImageStorePath";
  /**
   * @member {boolean} async Indicates whether or not provisioning should occur
   * asynchronously. When set to true, the provision operation returns when the
   * request is accepted by the system, and the provision operation continues
   * without any timeout limit. The default value is false. For large
   * application packages, we recommend setting the value to true.
   */
  async: boolean;
  /**
   * @member {string} applicationTypeBuildPath The relative path for the
   * application package in the image store specified during the prior upload
   * operation.
   */
  applicationTypeBuildPath: string;
  /**
   * @member {ApplicationPackageCleanupPolicy}
   * [applicationPackageCleanupPolicy] The kind of action that needs to be
   * taken for cleaning up the application package after successful provision.
   * Possible values include: 'Invalid', 'Default', 'Automatic', 'Manual'
   */
  applicationPackageCleanupPolicy?: ApplicationPackageCleanupPolicy;
}

/**
 * @interface
 * An interface representing ExternalStoreProvisionApplicationTypeDescription.
 * Describes the operation to register or provision an application type using
 * an application package from an external store instead of a package uploaded
 * to the Service Fabric image store.
 *
 */
export interface ExternalStoreProvisionApplicationTypeDescription {
  /**
   * @member {string} kind Polymorphic Discriminator
   */
  kind: "ExternalStore";
  /**
   * @member {boolean} async Indicates whether or not provisioning should occur
   * asynchronously. When set to true, the provision operation returns when the
   * request is accepted by the system, and the provision operation continues
   * without any timeout limit. The default value is false. For large
   * application packages, we recommend setting the value to true.
   */
  async: boolean;
  /**
   * @member {string} applicationPackageDownloadUri The path to the '.sfpkg'
   * application package from where the application package can be downloaded
   * using HTTP or HTTPS protocols. The application package can be stored in an
   * external store that provides GET operation to download the file. Supported
   * protocols are HTTP and HTTPS, and the path must allow READ access.
   */
  applicationPackageDownloadUri: string;
  /**
   * @member {string} applicationTypeName The application type name represents
   * the name of the application type found in the application manifest.
   */
  applicationTypeName: string;
  /**
   * @member {string} applicationTypeVersion The application type version
   * represents the version of the application type found in the application
   * manifest.
   */
  applicationTypeVersion: string;
}

/**
 * @interface
 * An interface representing UnprovisionFabricDescription.
 * Describes the parameters for unprovisioning a cluster.
 *
 */
export interface UnprovisionFabricDescription {
  /**
   * @member {string} [codeVersion] The cluster code package version.
   */
  codeVersion?: string;
  /**
   * @member {string} [configVersion] The cluster manifest version.
   */
  configVersion?: string;
}

/**
 * @interface
 * An interface representing ResumeClusterUpgradeDescription.
 * Describes the parameters for resuming a cluster upgrade.
 *
 */
export interface ResumeClusterUpgradeDescription {
  /**
   * @member {string} upgradeDomain The next upgrade domain for this cluster
   * upgrade.
   */
  upgradeDomain: string;
}

/**
 * @interface
 * An interface representing ClusterUpgradeHealthPolicyObject.
 * Defines a health policy used to evaluate the health of the cluster during a
 * cluster upgrade.
 *
 */
export interface ClusterUpgradeHealthPolicyObject {
  /**
   * @member {number} [maxPercentDeltaUnhealthyNodes] The maximum allowed
   * percentage of nodes health degradation allowed during cluster upgrades.
   * The delta is measured between the state of the nodes at the beginning of
   * upgrade and the state of the nodes at the time of the health evaluation.
   * The check is performed after every upgrade domain upgrade completion to
   * make sure the global state of the cluster is within tolerated limits. The
   * default value is 10%.
   */
  maxPercentDeltaUnhealthyNodes?: number;
  /**
   * @member {number} [maxPercentUpgradeDomainDeltaUnhealthyNodes] The maximum
   * allowed percentage of upgrade domain nodes health degradation allowed
   * during cluster upgrades. The delta is measured between the state of the
   * upgrade domain nodes at the beginning of upgrade and the state of the
   * upgrade domain nodes at the time of the health evaluation. The check is
   * performed after every upgrade domain upgrade completion for all completed
   * upgrade domains to make sure the state of the upgrade domains is within
   * tolerated limits. The default value is 15%.
   */
  maxPercentUpgradeDomainDeltaUnhealthyNodes?: number;
}

/**
 * @interface
 * An interface representing StartClusterUpgradeDescription.
 * Describes the parameters for starting a cluster upgrade.
 *
 */
export interface StartClusterUpgradeDescription {
  /**
   * @member {string} [codeVersion] The cluster code version.
   */
  codeVersion?: string;
  /**
   * @member {string} [configVersion] The cluster configuration version.
   */
  configVersion?: string;
  /**
   * @member {UpgradeKind} [upgradeKind] The kind of upgrade out of the
   * following possible values. Possible values include: 'Invalid', 'Rolling'.
   * Default value: 'Rolling' .
   */
  upgradeKind?: UpgradeKind;
  /**
   * @member {UpgradeMode} [rollingUpgradeMode] The mode used to monitor health
   * during a rolling upgrade. The values are UnmonitoredAuto,
   * UnmonitoredManual, and Monitored. Possible values include: 'Invalid',
   * 'UnmonitoredAuto', 'UnmonitoredManual', 'Monitored'. Default value:
   * 'UnmonitoredAuto' .
   */
  rollingUpgradeMode?: UpgradeMode;
  /**
   * @member {number} [upgradeReplicaSetCheckTimeoutInSeconds] The maximum
   * amount of time to block processing of an upgrade domain and prevent loss
   * of availability when there are unexpected issues. When this timeout
   * expires, processing of the upgrade domain will proceed regardless of
   * availability loss issues. The timeout is reset at the start of each
   * upgrade domain. Valid values are between 0 and 42949672925 inclusive.
   * (unsigned 32-bit integer).
   */
  upgradeReplicaSetCheckTimeoutInSeconds?: number;
  /**
   * @member {boolean} [forceRestart] If true, then processes are forcefully
   * restarted during upgrade even when the code version has not changed (the
   * upgrade only changes configuration or data).
   */
  forceRestart?: boolean;
  /**
   * @member {MonitoringPolicyDescription} [monitoringPolicy] Describes the
   * parameters for monitoring an upgrade in Monitored mode.
   */
  monitoringPolicy?: MonitoringPolicyDescription;
  /**
   * @member {ClusterHealthPolicy} [clusterHealthPolicy] Defines a health
   * policy used to evaluate the health of the cluster or of a cluster node.
   */
  clusterHealthPolicy?: ClusterHealthPolicy;
  /**
   * @member {boolean} [enableDeltaHealthEvaluation] When true, enables delta
   * health evaluation rather than absolute health evaluation after completion
   * of each upgrade domain.
   */
  enableDeltaHealthEvaluation?: boolean;
  /**
   * @member {ClusterUpgradeHealthPolicyObject} [clusterUpgradeHealthPolicy]
   * Defines a health policy used to evaluate the health of the cluster during
   * a cluster upgrade.
   */
  clusterUpgradeHealthPolicy?: ClusterUpgradeHealthPolicyObject;
  /**
   * @member {ApplicationHealthPolicies} [applicationHealthPolicyMap] Defines
   * the application health policy map used to evaluate the health of an
   * application or one of its children entities.
   */
  applicationHealthPolicyMap?: ApplicationHealthPolicies;
}

/**
 * @interface
 * An interface representing RollingUpgradeUpdateDescription.
 * Describes the parameters for updating a rolling upgrade of application or
 * cluster.
 *
 */
export interface RollingUpgradeUpdateDescription {
  /**
   * @member {UpgradeMode} rollingUpgradeMode The mode used to monitor health
   * during a rolling upgrade. The values are UnmonitoredAuto,
   * UnmonitoredManual, and Monitored. Possible values include: 'Invalid',
   * 'UnmonitoredAuto', 'UnmonitoredManual', 'Monitored'. Default value:
   * 'UnmonitoredAuto' .
   */
  rollingUpgradeMode: UpgradeMode;
  /**
   * @member {boolean} [forceRestart] If true, then processes are forcefully
   * restarted during upgrade even when the code version has not changed (the
   * upgrade only changes configuration or data).
   */
  forceRestart?: boolean;
  /**
   * @member {number} [replicaSetCheckTimeoutInMilliseconds] The maximum amount
   * of time to block processing of an upgrade domain and prevent loss of
   * availability when there are unexpected issues. When this timeout expires,
   * processing of the upgrade domain will proceed regardless of availability
   * loss issues. The timeout is reset at the start of each upgrade domain.
   * Valid values are between 0 and 42949672925 inclusive. (unsigned 32-bit
   * integer).
   */
  replicaSetCheckTimeoutInMilliseconds?: number;
  /**
   * @member {FailureAction} [failureAction] The compensating action to perform
   * when a Monitored upgrade encounters monitoring policy or health policy
   * violations.
   * Invalid indicates the failure action is invalid. Rollback specifies that
   * the upgrade will start rolling back automatically.
   * Manual indicates that the upgrade will switch to UnmonitoredManual upgrade
   * mode. Possible values include: 'Invalid', 'Rollback', 'Manual'
   */
  failureAction?: FailureAction;
  /**
   * @member {string} [healthCheckWaitDurationInMilliseconds] The amount of
   * time to wait after completing an upgrade domain before applying health
   * policies. It is first interpreted as a string representing an ISO 8601
   * duration. If that fails, then it is interpreted as a number representing
   * the total number of milliseconds.
   */
  healthCheckWaitDurationInMilliseconds?: string;
  /**
   * @member {string} [healthCheckStableDurationInMilliseconds] The amount of
   * time that the application or cluster must remain healthy before the
   * upgrade proceeds to the next upgrade domain. It is first interpreted as a
   * string representing an ISO 8601 duration. If that fails, then it is
   * interpreted as a number representing the total number of milliseconds.
   */
  healthCheckStableDurationInMilliseconds?: string;
  /**
   * @member {string} [healthCheckRetryTimeoutInMilliseconds] The amount of
   * time to retry health evaluation when the application or cluster is
   * unhealthy before FailureAction is executed. It is first interpreted as a
   * string representing an ISO 8601 duration. If that fails, then it is
   * interpreted as a number representing the total number of milliseconds.
   */
  healthCheckRetryTimeoutInMilliseconds?: string;
  /**
   * @member {string} [upgradeTimeoutInMilliseconds] The amount of time the
   * overall upgrade has to complete before FailureAction is executed. It is
   * first interpreted as a string representing an ISO 8601 duration. If that
   * fails, then it is interpreted as a number representing the total number of
   * milliseconds.
   */
  upgradeTimeoutInMilliseconds?: string;
  /**
   * @member {string} [upgradeDomainTimeoutInMilliseconds] The amount of time
   * each upgrade domain has to complete before FailureAction is executed. It
   * is first interpreted as a string representing an ISO 8601 duration. If
   * that fails, then it is interpreted as a number representing the total
   * number of milliseconds.
   */
  upgradeDomainTimeoutInMilliseconds?: string;
}

/**
 * @interface
 * An interface representing UpdateClusterUpgradeDescription.
 * Parameters for updating a cluster upgrade.
 *
 */
export interface UpdateClusterUpgradeDescription {
  /**
   * @member {UpgradeType} [upgradeKind] The type of upgrade out of the
   * following possible values. Possible values include: 'Invalid', 'Rolling',
   * 'Rolling_ForceRestart'. Default value: 'Rolling' .
   */
  upgradeKind?: UpgradeType;
  /**
   * @member {RollingUpgradeUpdateDescription} [updateDescription] Describes
   * the parameters for updating a rolling upgrade of application or cluster.
   */
  updateDescription?: RollingUpgradeUpdateDescription;
  /**
   * @member {ClusterHealthPolicy} [clusterHealthPolicy] Defines a health
   * policy used to evaluate the health of the cluster or of a cluster node.
   */
  clusterHealthPolicy?: ClusterHealthPolicy;
  /**
   * @member {boolean} [enableDeltaHealthEvaluation] When true, enables delta
   * health evaluation rather than absolute health evaluation after completion
   * of each upgrade domain.
   */
  enableDeltaHealthEvaluation?: boolean;
  /**
   * @member {ClusterUpgradeHealthPolicyObject} [clusterUpgradeHealthPolicy]
   * Defines a health policy used to evaluate the health of the cluster during
   * a cluster upgrade.
   */
  clusterUpgradeHealthPolicy?: ClusterUpgradeHealthPolicyObject;
  /**
   * @member {ApplicationHealthPolicies} [applicationHealthPolicyMap] Defines
   * the application health policy map used to evaluate the health of an
   * application or one of its children entities.
   */
  applicationHealthPolicyMap?: ApplicationHealthPolicies;
}

/**
 * Contains the possible cases for PartitionSafetyCheck.
 */
export type PartitionSafetyCheckUnion = PartitionSafetyCheck | EnsureAvailabilitySafetyCheck | EnsurePartitionQurumSafetyCheck | WaitForInbuildReplicaSafetyCheck | WaitForPrimaryPlacementSafetyCheck | WaitForPrimarySwapSafetyCheck | WaitForReconfigurationSafetyCheck;

/**
 * @interface
 * An interface representing PartitionSafetyCheck.
 * Represents a safety check for the service partition being performed by
 * service fabric before continuing with operations.
 *
 */
export interface PartitionSafetyCheck {
  /**
   * @member {string} kind Polymorphic Discriminator
   */
  kind: "PartitionSafetyCheck";
  /**
   * @member {string} [partitionId] Id of the partition which is undergoing the
   * safety check.
   */
  partitionId?: string;
}

/**
 * @interface
 * An interface representing EnsureAvailabilitySafetyCheck.
 * Safety check that waits to ensure the availability of the partition. It
 * waits until there are replicas available such that bringing down this
 * replica will not cause availability loss for the partition.
 *
 */
export interface EnsureAvailabilitySafetyCheck {
  /**
   * @member {string} kind Polymorphic Discriminator
   */
  kind: "EnsureAvailability";
  /**
   * @member {string} [partitionId] Id of the partition which is undergoing the
   * safety check.
   */
  partitionId?: string;
}

/**
 * @interface
 * An interface representing EnsurePartitionQurumSafetyCheck.
 * Safety check that ensures that a quorum of replicas are not lost for a
 * partition.
 *
 */
export interface EnsurePartitionQurumSafetyCheck {
  /**
   * @member {string} kind Polymorphic Discriminator
   */
  kind: "EnsurePartitionQuorum";
  /**
   * @member {string} [partitionId] Id of the partition which is undergoing the
   * safety check.
   */
  partitionId?: string;
}

/**
 * @interface
 * An interface representing SeedNodeSafetyCheck.
 * Represents a safety check for the seed nodes being performed by service
 * fabric before continuing with node level operations.
 *
 */
export interface SeedNodeSafetyCheck {
  /**
   * @member {string} kind Polymorphic Discriminator
   */
  kind: "EnsureSeedNodeQuorum";
}

/**
 * @interface
 * An interface representing PartitionsHealthEvaluation.
 * Represents health evaluation for the partitions of a service, containing
 * health evaluations for each unhealthy partition that impacts current
 * aggregated health state. Can be returned when evaluating service health and
 * the aggregated health state is either Error or Warning.
 *
 */
export interface PartitionsHealthEvaluation {
  /**
   * @member {string} kind Polymorphic Discriminator
   */
  kind: "Partitions";
  /**
   * @member {HealthState} [aggregatedHealthState] The health state of a
   * Service Fabric entity such as Cluster, Node, Application, Service,
   * Partition, Replica etc. Possible values include: 'Invalid', 'Ok',
   * 'Warning', 'Error', 'Unknown'
   */
  aggregatedHealthState?: HealthState;
  /**
   * @member {string} [description] Description of the health evaluation, which
   * represents a summary of the evaluation process.
   */
  description?: string;
  /**
   * @member {number} [maxPercentUnhealthyPartitionsPerService] Maximum allowed
   * percentage of unhealthy partitions per service from the
   * ServiceTypeHealthPolicy.
   */
  maxPercentUnhealthyPartitionsPerService?: number;
  /**
   * @member {number} [totalCount] Total number of partitions of the service
   * from the health store.
   */
  totalCount?: number;
  /**
   * @member {HealthEvaluationWrapper[]} [unhealthyEvaluations] List of
   * unhealthy evaluations that led to the aggregated health state. Includes
   * all the unhealthy PartitionHealthEvaluation that impacted the aggregated
   * health.
   */
  unhealthyEvaluations?: HealthEvaluationWrapper[];
}

/**
 * Contains the possible cases for ReplicaEvent.
 */
export type ReplicaEventUnion = ReplicaEvent | StatefulReplicaHealthReportCreatedEvent | StatefulReplicaHealthReportExpiredEvent | StatelessReplicaHealthReportCreatedEvent | StatelessReplicaHealthReportExpiredEvent | ChaosRemoveReplicaFaultScheduledEvent | ChaosRemoveReplicaFaultCompletedEvent | ChaosRestartReplicaFaultScheduledEvent;

/**
 * @interface
 * An interface representing ReplicaEvent.
 * Represents the base for all Replica Events.
 *
 */
export interface ReplicaEvent {
  /**
   * @member {string} kind Polymorphic Discriminator
   */
  kind: "ReplicaEvent";
  /**
   * @member {string} eventInstanceId The identifier for the FabricEvent
   * instance.
   */
  eventInstanceId: string;
  /**
   * @member {Date} timeStamp The time event was logged.
   */
  timeStamp: Date;
  /**
   * @member {boolean} [hasCorrelatedEvents] Shows there is existing related
   * events available.
   */
  hasCorrelatedEvents?: boolean;
  /**
   * @member {string} partitionId An internal ID used by Service Fabric to
   * uniquely identify a partition. This is a randomly generated GUID when the
   * service was created. The partition ID is unique and does not change for
   * the lifetime of the service. If the same service was deleted and recreated
   * the IDs of its partitions would be different.
   */
  partitionId: string;
  /**
   * @member {number} replicaId Id of a stateful service replica. ReplicaId is
   * used by Service Fabric to uniquely identify a replica of a partition. It
   * is unique within a partition and does not change for the lifetime of the
   * replica. If a replica gets dropped and another replica gets created on the
   * same node for the same partition, it will get a different value for the
   * id. Sometimes the id of a stateless service instance is also referred as a
   * replica id.
   */
  replicaId: number;
}

/**
 * Contains the possible cases for ReplicaHealth.
 */
export type ReplicaHealthUnion = ReplicaHealth | StatefulServiceReplicaHealth | StatelessServiceInstanceHealth;

/**
 * @interface
 * An interface representing ReplicaHealth.
 * Represents a base class for stateful service replica or stateless service
 * instance health.
 * Contains the replica aggregated health state, the health events and the
 * unhealthy evaluations.
 *
 */
export interface ReplicaHealth {
  /**
   * @member {string} serviceKind Polymorphic Discriminator
   */
  serviceKind: "ReplicaHealth";
  /**
   * @member {HealthState} [aggregatedHealthState] The HealthState representing
   * the aggregated health state of the entity computed by Health Manager.
   * The health evaluation of the entity reflects all events reported on the
   * entity and its children (if any).
   * The aggregation is done by applying the desired health policy. Possible
   * values include: 'Invalid', 'Ok', 'Warning', 'Error', 'Unknown'
   */
  aggregatedHealthState?: HealthState;
  /**
   * @member {HealthEvent[]} [healthEvents] The list of health events reported
   * on the entity.
   */
  healthEvents?: HealthEvent[];
  /**
   * @member {HealthEvaluationWrapper[]} [unhealthyEvaluations] The unhealthy
   * evaluations that show why the current aggregated health state was returned
   * by Health Manager.
   */
  unhealthyEvaluations?: HealthEvaluationWrapper[];
  /**
   * @member {HealthStatistics} [healthStatistics] Shows the health statistics
   * for all children types of the queried entity.
   */
  healthStatistics?: HealthStatistics;
  /**
   * @member {string} [partitionId] Id of the partition to which this replica
   * belongs.
   */
  partitionId?: string;
}

/**
 * @interface
 * An interface representing ReplicaHealthEvaluation.
 * Represents health evaluation for a replica, containing information about the
 * data and the algorithm used by health store to evaluate health. The
 * evaluation is returned only when the aggregated health state is either Error
 * or Warning.
 *
 */
export interface ReplicaHealthEvaluation {
  /**
   * @member {string} kind Polymorphic Discriminator
   */
  kind: "Replica";
  /**
   * @member {HealthState} [aggregatedHealthState] The health state of a
   * Service Fabric entity such as Cluster, Node, Application, Service,
   * Partition, Replica etc. Possible values include: 'Invalid', 'Ok',
   * 'Warning', 'Error', 'Unknown'
   */
  aggregatedHealthState?: HealthState;
  /**
   * @member {string} [description] Description of the health evaluation, which
   * represents a summary of the evaluation process.
   */
  description?: string;
  /**
   * @member {string} [partitionId] Id of the partition to which the replica
   * belongs.
   */
  partitionId?: string;
  /**
   * @member {string} [replicaOrInstanceId] Id of a stateful service replica or
   * a stateless service instance. This ID is used in the queries that apply to
   * both stateful and stateless services. It is used by Service Fabric to
   * uniquely identify a replica of a partition of a stateful service or an
   * instance of a stateless service partition. It is unique within a partition
   * and does not change for the lifetime of the replica or the instance. If a
   * stateful replica gets dropped and another replica gets created on the same
   * node for the same partition, it will get a different value for the ID. If
   * a stateless instance is failed over on the same or different node it will
   * get a different value for the ID.
   */
  replicaOrInstanceId?: string;
  /**
   * @member {HealthEvaluationWrapper[]} [unhealthyEvaluations] List of
   * unhealthy evaluations that led to the current aggregated health state of
   * the replica. The types of the unhealthy evaluations can be
   * EventHealthEvaluation.
   */
  unhealthyEvaluations?: HealthEvaluationWrapper[];
}

/**
 * @interface
 * An interface representing ReplicasHealthEvaluation.
 * Represents health evaluation for replicas, containing health evaluations for
 * each unhealthy replica that impacted current aggregated health state. Can be
 * returned when evaluating partition health and the aggregated health state is
 * either Error or Warning.
 *
 */
export interface ReplicasHealthEvaluation {
  /**
   * @member {string} kind Polymorphic Discriminator
   */
  kind: "Replicas";
  /**
   * @member {HealthState} [aggregatedHealthState] The health state of a
   * Service Fabric entity such as Cluster, Node, Application, Service,
   * Partition, Replica etc. Possible values include: 'Invalid', 'Ok',
   * 'Warning', 'Error', 'Unknown'
   */
  aggregatedHealthState?: HealthState;
  /**
   * @member {string} [description] Description of the health evaluation, which
   * represents a summary of the evaluation process.
   */
  description?: string;
  /**
   * @member {number} [maxPercentUnhealthyReplicasPerPartition] Maximum allowed
   * percentage of unhealthy replicas per partition from the
   * ApplicationHealthPolicy.
   */
  maxPercentUnhealthyReplicasPerPartition?: number;
  /**
   * @member {number} [totalCount] Total number of replicas in the partition
   * from the health store.
   */
  totalCount?: number;
  /**
   * @member {HealthEvaluationWrapper[]} [unhealthyEvaluations] List of
   * unhealthy evaluations that led to the aggregated health state. Includes
   * all the unhealthy ReplicaHealthEvaluation that impacted the aggregated
   * health.
   */
  unhealthyEvaluations?: HealthEvaluationWrapper[];
}

/**
 * @interface
 * An interface representing RestartNodeDescription.
 * Describes the parameters to restart a Service Fabric node.
 *
 */
export interface RestartNodeDescription {
  /**
   * @member {string} nodeInstanceId The instance ID of the target node. If
   * instance ID is specified the node is restarted only if it matches with the
   * current instance of the node. A default value of "0" would match any
   * instance ID. The instance ID can be obtained using get node query. Default
   * value: '0' .
   */
  nodeInstanceId: string;
  /**
   * @member {CreateFabricDump} [createFabricDump] Specify True to create a
   * dump of the fabric node process. This is case-sensitive. Possible values
   * include: 'False', 'True'. Default value: 'False' .
   */
  createFabricDump?: CreateFabricDump;
}

/**
 * Contains the possible cases for ServiceEvent.
 */
export type ServiceEventUnion = ServiceEvent | ServiceCreatedEvent | ServiceDeletedEvent | ServiceHealthReportCreatedEvent | ServiceHealthReportExpiredEvent;

/**
 * @interface
 * An interface representing ServiceEvent.
 * Represents the base for all Service Events.
 *
 */
export interface ServiceEvent {
  /**
   * @member {string} kind Polymorphic Discriminator
   */
  kind: "ServiceEvent";
  /**
   * @member {string} eventInstanceId The identifier for the FabricEvent
   * instance.
   */
  eventInstanceId: string;
  /**
   * @member {Date} timeStamp The time event was logged.
   */
  timeStamp: Date;
  /**
   * @member {boolean} [hasCorrelatedEvents] Shows there is existing related
   * events available.
   */
  hasCorrelatedEvents?: boolean;
  /**
   * @member {string} serviceId The identity of the service. This ID is an
   * encoded representation of the service name. This is used in the REST APIs
   * to identify the service resource.
   * Starting in version 6.0, hierarchical names are delimited with the "\~"
   * character. For example, if the service name is "fabric:/myapp/app1/svc1",
   * the service identity would be "myapp~app1\~svc1" in 6.0+ and
   * "myapp/app1/svc1" in previous versions.
   */
  serviceId: string;
}

/**
 * @interface
 * An interface representing ServiceFromTemplateDescription.
 * Defines description for creating a Service Fabric service from a template
 * defined in the application manifest.
 *
 */
export interface ServiceFromTemplateDescription {
  /**
   * @member {string} applicationName The name of the application, including
   * the 'fabric:' URI scheme.
   */
  applicationName: string;
  /**
   * @member {string} serviceName The full name of the service with 'fabric:'
   * URI scheme.
   */
  serviceName: string;
  /**
   * @member {string} serviceTypeName Name of the service type as specified in
   * the service manifest.
   */
  serviceTypeName: string;
  /**
   * @member {number[]} [initializationData] The initialization data for the
   * newly created service instance.
   */
  initializationData?: number[];
  /**
   * @member {ServicePackageActivationMode} [servicePackageActivationMode] The
   * activation mode of service package to be used for a service. Possible
   * values include: 'SharedProcess', 'ExclusiveProcess'
   */
  servicePackageActivationMode?: ServicePackageActivationMode;
  /**
   * @member {string} [serviceDnsName] The DNS name of the service. It requires
   * the DNS system service to be enabled in Service Fabric cluster.
   */
  serviceDnsName?: string;
}

/**
 * @interface
 * An interface representing ServiceHealthEvaluation.
 * Represents health evaluation for a service, containing information about the
 * data and the algorithm used by health store to evaluate health. The
 * evaluation is returned only when the aggregated health state is either Error
 * or Warning.
 *
 */
export interface ServiceHealthEvaluation {
  /**
   * @member {string} kind Polymorphic Discriminator
   */
  kind: "Service";
  /**
   * @member {HealthState} [aggregatedHealthState] The health state of a
   * Service Fabric entity such as Cluster, Node, Application, Service,
   * Partition, Replica etc. Possible values include: 'Invalid', 'Ok',
   * 'Warning', 'Error', 'Unknown'
   */
  aggregatedHealthState?: HealthState;
  /**
   * @member {string} [description] Description of the health evaluation, which
   * represents a summary of the evaluation process.
   */
  description?: string;
  /**
   * @member {string} [serviceName] Name of the service whose health evaluation
   * is described by this object.
   */
  serviceName?: string;
  /**
   * @member {HealthEvaluationWrapper[]} [unhealthyEvaluations] List of
   * unhealthy evaluations that led to the current aggregated health state of
   * the service. The types of the unhealthy evaluations can be
   * PartitionsHealthEvaluation or EventHealthEvaluation.
   */
  unhealthyEvaluations?: HealthEvaluationWrapper[];
}

/**
 * @interface
 * An interface representing ServiceHealth.
 * Information about the health of a Service Fabric service.
 *
 * @extends EntityHealth
 */
export interface ServiceHealth extends EntityHealth {
  /**
   * @member {string} [name] The name of the service whose health information
   * is described by this object.
   */
  name?: string;
  /**
   * @member {PartitionHealthState[]} [partitionHealthStates] The list of
   * partition health states associated with the service.
   */
  partitionHealthStates?: PartitionHealthState[];
}

/**
 * @interface
 * An interface representing ServiceNameInfo.
 * Information about the service name.
 *
 */
export interface ServiceNameInfo {
  /**
   * @member {string} [id] The identity of the service. This ID is an encoded
   * representation of the service name. This is used in the REST APIs to
   * identify the service resource.
   * Starting in version 6.0, hierarchical names are delimited with the "\~"
   * character. For example, if the service name is "fabric:/myapp/app1/svc1",
   * the service identity would be "myapp~app1\~svc1" in 6.0+ and
   * "myapp/app1/svc1" in previous versions.
   */
  id?: string;
  /**
   * @member {string} [name] The full name of the service with 'fabric:' URI
   * scheme.
   */
  name?: string;
}

/**
 * Contains the possible cases for ServicePlacementPolicyDescription.
 */
export type ServicePlacementPolicyDescriptionUnion = ServicePlacementPolicyDescription | ServicePlacementInvalidDomainPolicyDescription | ServicePlacementNonPartiallyPlaceServicePolicyDescription | ServicePlacementPreferPrimaryDomainPolicyDescription | ServicePlacementRequiredDomainPolicyDescription | ServicePlacementRequireDomainDistributionPolicyDescription;

/**
 * @interface
 * An interface representing ServicePlacementPolicyDescription.
 * Describes the policy to be used for placement of a Service Fabric service.
 *
 */
export interface ServicePlacementPolicyDescription {
  /**
   * @member {string} type Polymorphic Discriminator
   */
  type: "ServicePlacementPolicyDescription";
}

/**
 * @interface
 * An interface representing ServicePlacementInvalidDomainPolicyDescription.
 * Describes the policy to be used for placement of a Service Fabric service
 * where a particular fault or upgrade domain should not be used for placement
 * of the instances or replicas of that service.
 *
 */
export interface ServicePlacementInvalidDomainPolicyDescription {
  /**
   * @member {string} type Polymorphic Discriminator
   */
  type: "InvalidDomain";
  /**
   * @member {string} [domainName] The name of the domain that should not be
   * used for placement.
   */
  domainName?: string;
}

/**
 * @interface
 * An interface representing ServicePlacementNonPartiallyPlaceServicePolicyDescription.
 * Describes the policy to be used for placement of a Service Fabric service
 * where all replicas must be able to be placed in order for any replicas to be
 * created.
 *
 */
export interface ServicePlacementNonPartiallyPlaceServicePolicyDescription {
  /**
   * @member {string} type Polymorphic Discriminator
   */
  type: "NonPartiallyPlaceService";
}

/**
 * @interface
 * An interface representing ServicePlacementPreferPrimaryDomainPolicyDescription.
 * Describes the policy to be used for placement of a Service Fabric service
 * where the service's Primary replicas should optimally be placed in a
 * particular domain.
 *
 * This placement policy is usually used with fault domains in scenarios where
 * the Service Fabric cluster is geographically distributed in order to
 * indicate that a service's primary replica should be located in a particular
 * fault domain, which in geo-distributed scenarios usually aligns with
 * regional or datacenter boundaries. Note that since this is an optimization
 * it is possible that the Primary replica may not end up located in this
 * domain due to failures, capacity limits, or other constraints.
 *
 */
export interface ServicePlacementPreferPrimaryDomainPolicyDescription {
  /**
   * @member {string} type Polymorphic Discriminator
   */
  type: "PreferredPrimaryDomain";
  /**
   * @member {string} [domainName] The name of the domain that should used for
   * placement as per this policy.
   */
  domainName?: string;
}

/**
 * @interface
 * An interface representing ServicePlacementRequiredDomainPolicyDescription.
 * Describes the policy to be used for placement of a Service Fabric service
 * where the instances or replicas of that service must be placed in a
 * particular domain
 *
 */
export interface ServicePlacementRequiredDomainPolicyDescription {
  /**
   * @member {string} type Polymorphic Discriminator
   */
  type: "RequiredDomain";
  /**
   * @member {string} [domainName] The name of the domain that should used for
   * placement as per this policy.
   */
  domainName?: string;
}

/**
 * @interface
 * An interface representing ServicePlacementRequireDomainDistributionPolicyDescription.
 * Describes the policy to be used for placement of a Service Fabric service
 * where two replicas from the same partition should never be placed in the
 * same fault or upgrade domain.
 *
 * While this is not common it can expose the service to an increased risk of
 * concurrent failures due to unplanned outages or other cases of
 * subsequent/concurrent failures. As an example, consider a case where
 * replicas are deployed across different data center, with one replica per
 * location. In the event that one of the datacenters goes offline, normally
 * the replica that was placed in that datacenter will be packed into one of
 * the remaining datacenters. If this is not desirable then this policy should
 * be set.
 *
 */
export interface ServicePlacementRequireDomainDistributionPolicyDescription {
  /**
   * @member {string} type Polymorphic Discriminator
   */
  type: "RequiredDomainDistribution";
  /**
   * @member {string} [domainName] The name of the domain that should used for
   * placement as per this policy.
   */
  domainName?: string;
}

/**
 * @interface
 * An interface representing ServicesHealthEvaluation.
 * Represents health evaluation for services of a certain service type
 * belonging to an application, containing health evaluations for each
 * unhealthy service that impacted current aggregated health state. Can be
 * returned when evaluating application health and the aggregated health state
 * is either Error or Warning.
 *
 */
export interface ServicesHealthEvaluation {
  /**
   * @member {string} kind Polymorphic Discriminator
   */
  kind: "Services";
  /**
   * @member {HealthState} [aggregatedHealthState] The health state of a
   * Service Fabric entity such as Cluster, Node, Application, Service,
   * Partition, Replica etc. Possible values include: 'Invalid', 'Ok',
   * 'Warning', 'Error', 'Unknown'
   */
  aggregatedHealthState?: HealthState;
  /**
   * @member {string} [description] Description of the health evaluation, which
   * represents a summary of the evaluation process.
   */
  description?: string;
  /**
   * @member {string} [serviceTypeName] Name of the service type of the
   * services.
   */
  serviceTypeName?: string;
  /**
   * @member {number} [maxPercentUnhealthyServices] Maximum allowed percentage
   * of unhealthy services from the ServiceTypeHealthPolicy.
   */
  maxPercentUnhealthyServices?: number;
  /**
   * @member {number} [totalCount] Total number of services of the current
   * service type in the application from the health store.
   */
  totalCount?: number;
  /**
   * @member {HealthEvaluationWrapper[]} [unhealthyEvaluations] List of
   * unhealthy evaluations that led to the aggregated health state. Includes
   * all the unhealthy ServiceHealthEvaluation that impacted the aggregated
   * health.
   */
  unhealthyEvaluations?: HealthEvaluationWrapper[];
}

/**
 * @interface
 * An interface representing ServiceLoadMetricDescription.
 * Specifies a metric to load balance a service during runtime.
 *
 */
export interface ServiceLoadMetricDescription {
  /**
   * @member {string} name The name of the metric. If the service chooses to
   * report load during runtime, the load metric name should match the name
   * that is specified in Name exactly. Note that metric names are
   * case-sensitive.
   */
  name: string;
  /**
   * @member {ServiceLoadMetricWeight} [weight] The service load metric
   * relative weight, compared to other metrics configured for this service, as
   * a number. Possible values include: 'Zero', 'Low', 'Medium', 'High'
   */
  weight?: ServiceLoadMetricWeight;
  /**
   * @member {number} [primaryDefaultLoad] Used only for Stateful services. The
   * default amount of load, as a number, that this service creates for this
   * metric when it is a Primary replica.
   */
  primaryDefaultLoad?: number;
  /**
   * @member {number} [secondaryDefaultLoad] Used only for Stateful services.
   * The default amount of load, as a number, that this service creates for
   * this metric when it is a Secondary replica.
   */
  secondaryDefaultLoad?: number;
  /**
   * @member {number} [defaultLoad] Used only for Stateless services. The
   * default amount of load, as a number, that this service creates for this
   * metric.
   */
  defaultLoad?: number;
}

/**
 * @interface
 * An interface representing ServiceTypeExtensionDescription.
 * Describes extension of a service type defined in the service manifest.
 *
 */
export interface ServiceTypeExtensionDescription {
  /**
   * @member {string} [key] The name of the extension.
   */
  key?: string;
  /**
   * @member {string} [value] The extension value.
   */
  value?: string;
}

/**
 * Contains the possible cases for ServiceTypeDescription.
 */
export type ServiceTypeDescriptionUnion = ServiceTypeDescription | StatefulServiceTypeDescription | StatelessServiceTypeDescription;

/**
 * @interface
 * An interface representing ServiceTypeDescription.
 * Describes a service type defined in the service manifest of a provisioned
 * application type. The properties the ones defined in the service manifest.
 *
 */
export interface ServiceTypeDescription {
  /**
   * @member {string} kind Polymorphic Discriminator
   */
  kind: "ServiceTypeDescription";
  /**
   * @member {boolean} [isStateful] Indicates whether the service type is a
   * stateful service type or a stateless service type. This property is true
   * if the service type is a stateful service type, false otherwise.
   */
  isStateful?: boolean;
  /**
   * @member {string} [serviceTypeName] Name of the service type as specified
   * in the service manifest.
   */
  serviceTypeName?: string;
  /**
   * @member {string} [placementConstraints] The placement constraint to be
   * used when instantiating this service in a Service Fabric cluster.
   */
  placementConstraints?: string;
  /**
   * @member {ServiceLoadMetricDescription[]} [loadMetrics] The service load
   * metrics is given as an array of ServiceLoadMetricDescription objects.
   */
  loadMetrics?: ServiceLoadMetricDescription[];
  /**
   * @member {ServicePlacementPolicyDescriptionUnion[]}
   * [servicePlacementPolicies] List of service placement policy descriptions.
   */
  servicePlacementPolicies?: ServicePlacementPolicyDescriptionUnion[];
  /**
   * @member {ServiceTypeExtensionDescription[]} [extensions] List of service
   * type extensions.
   */
  extensions?: ServiceTypeExtensionDescription[];
}

/**
 * @interface
 * An interface representing ServiceTypeInfo.
 * Information about a service type that is defined in a service manifest of a
 * provisioned application type.
 *
 */
export interface ServiceTypeInfo {
  /**
   * @member {ServiceTypeDescriptionUnion} [serviceTypeDescription] Describes a
   * service type defined in the service manifest of a provisioned application
   * type. The properties the ones defined in the service manifest.
   */
  serviceTypeDescription?: ServiceTypeDescriptionUnion;
  /**
   * @member {string} [serviceManifestName] The name of the service manifest in
   * which this service type is defined.
   */
  serviceManifestName?: string;
  /**
   * @member {string} [serviceManifestVersion] The version of the service
   * manifest in which this service type is defined.
   */
  serviceManifestVersion?: string;
  /**
   * @member {boolean} [isServiceGroup] Indicates whether the service is a
   * service group. If it is, the property value is true otherwise false.
   */
  isServiceGroup?: boolean;
}

/**
 * @interface
 * An interface representing ServiceTypeManifest.
 * Contains the manifest describing a service type registered as part of an
 * application in a Service Fabric cluster.
 *
 */
export interface ServiceTypeManifest {
  /**
   * @member {string} [manifest] The XML manifest as a string.
   */
  manifest?: string;
}

/**
 * @interface
 * An interface representing SingletonPartitionInformation.
 * Information about a partition that is singleton. The services with singleton
 * partitioning scheme are effectively non-partitioned. They only have one
 * partition.
 *
 */
export interface SingletonPartitionInformation {
  /**
   * @member {string} servicePartitionKind Polymorphic Discriminator
   */
  servicePartitionKind: "Singleton";
  /**
   * @member {string} [id] An internal ID used by Service Fabric to uniquely
   * identify a partition. This is a randomly generated GUID when the service
   * was created. The partition ID is unique and does not change for the
   * lifetime of the service. If the same service was deleted and recreated the
   * IDs of its partitions would be different.
   */
  id?: string;
}

/**
 * @interface
 * An interface representing StatefulServiceInfo.
 * Information about a stateful Service Fabric service.
 *
 */
export interface StatefulServiceInfo {
  /**
   * @member {string} serviceKind Polymorphic Discriminator
   */
  serviceKind: "Stateful";
  /**
   * @member {string} [id] The identity of the service. This ID is an encoded
   * representation of the service name. This is used in the REST APIs to
   * identify the service resource.
   * Starting in version 6.0, hierarchical names are delimited with the "\~"
   * character. For example, if the service name is "fabric:/myapp/app1/svc1",
   * the service identity would be "myapp~app1\~svc1" in 6.0+ and
   * "myapp/app1/svc1" in previous versions.
   */
  id?: string;
  /**
   * @member {string} [name] The full name of the service with 'fabric:' URI
   * scheme.
   */
  name?: string;
  /**
   * @member {string} [typeName] Name of the service type as specified in the
   * service manifest.
   */
  typeName?: string;
  /**
   * @member {string} [manifestVersion] The version of the service manifest.
   */
  manifestVersion?: string;
  /**
   * @member {HealthState} [healthState] The health state of a Service Fabric
   * entity such as Cluster, Node, Application, Service, Partition, Replica
   * etc. Possible values include: 'Invalid', 'Ok', 'Warning', 'Error',
   * 'Unknown'
   */
  healthState?: HealthState;
  /**
   * @member {ServiceStatus} [serviceStatus] The status of the application.
   * Possible values include: 'Unknown', 'Active', 'Upgrading', 'Deleting',
   * 'Creating', 'Failed'
   */
  serviceStatus?: ServiceStatus;
  /**
   * @member {boolean} [isServiceGroup] Whether the service is in a service
   * group.
   */
  isServiceGroup?: boolean;
  /**
   * @member {boolean} [hasPersistedState] Whether the service has persisted
   * state.
   */
  hasPersistedState?: boolean;
}

/**
 * @interface
 * An interface representing StatefulServicePartitionInfo.
 * Information about a partition of a stateful Service Fabric service..
 *
 */
export interface StatefulServicePartitionInfo {
  /**
   * @member {string} serviceKind Polymorphic Discriminator
   */
  serviceKind: "Stateful";
  /**
   * @member {HealthState} [healthState] The health state of a Service Fabric
   * entity such as Cluster, Node, Application, Service, Partition, Replica
   * etc. Possible values include: 'Invalid', 'Ok', 'Warning', 'Error',
   * 'Unknown'
   */
  healthState?: HealthState;
  /**
   * @member {ServicePartitionStatus} [partitionStatus] The status of the
   * service fabric service partition. Possible values include: 'Invalid',
   * 'Ready', 'NotReady', 'InQuorumLoss', 'Reconfiguring', 'Deleting'
   */
  partitionStatus?: ServicePartitionStatus;
  /**
   * @member {PartitionInformationUnion} [partitionInformation] Information
   * about the partition identity, partitioning scheme and keys supported by
   * it.
   */
  partitionInformation?: PartitionInformationUnion;
  /**
   * @member {number} [targetReplicaSetSize] The target replica set size as a
   * number.
   */
  targetReplicaSetSize?: number;
  /**
   * @member {number} [minReplicaSetSize] The minimum replica set size as a
   * number.
   */
  minReplicaSetSize?: number;
  /**
   * @member {string} [lastQuorumLossDuration] The duration for which this
   * partition was in quorum loss. If the partition is currently in quorum
   * loss, it returns the duration since it has been in that state. This field
   * is using ISO8601 format for specifying the duration.
   */
  lastQuorumLossDuration?: string;
  /**
   * @member {Epoch} [currentConfigurationEpoch] An Epoch is a configuration
   * number for the partition as a whole. When the configuration of the replica
   * set changes, for example when the Primary replica changes, the operations
   * that are replicated from the new Primary replica are said to be a new
   * Epoch from the ones which were sent by the old Primary replica.
   */
  currentConfigurationEpoch?: Epoch;
}

/**
 * @interface
 * An interface representing StatefulServiceReplicaHealth.
 * Represents the health of the stateful service replica.
 * Contains the replica aggregated health state, the health events and the
 * unhealthy evaluations.
 *
 */
export interface StatefulServiceReplicaHealth {
  /**
   * @member {string} serviceKind Polymorphic Discriminator
   */
  serviceKind: "Stateful";
  /**
   * @member {HealthState} [aggregatedHealthState] The HealthState representing
   * the aggregated health state of the entity computed by Health Manager.
   * The health evaluation of the entity reflects all events reported on the
   * entity and its children (if any).
   * The aggregation is done by applying the desired health policy. Possible
   * values include: 'Invalid', 'Ok', 'Warning', 'Error', 'Unknown'
   */
  aggregatedHealthState?: HealthState;
  /**
   * @member {HealthEvent[]} [healthEvents] The list of health events reported
   * on the entity.
   */
  healthEvents?: HealthEvent[];
  /**
   * @member {HealthEvaluationWrapper[]} [unhealthyEvaluations] The unhealthy
   * evaluations that show why the current aggregated health state was returned
   * by Health Manager.
   */
  unhealthyEvaluations?: HealthEvaluationWrapper[];
  /**
   * @member {HealthStatistics} [healthStatistics] Shows the health statistics
   * for all children types of the queried entity.
   */
  healthStatistics?: HealthStatistics;
  /**
   * @member {string} [partitionId] Id of the partition to which this replica
   * belongs.
   */
  partitionId?: string;
  /**
   * @member {string} [replicaId] Id of a stateful service replica. ReplicaId
   * is used by Service Fabric to uniquely identify a replica of a partition.
   * It is unique within a partition and does not change for the lifetime of
   * the replica. If a replica gets dropped and another replica gets created on
   * the same node for the same partition, it will get a different value for
   * the id. Sometimes the id of a stateless service instance is also referred
   * as a replica id.
   */
  replicaId?: string;
}

/**
 * @interface
 * An interface representing StatefulServiceReplicaHealthState.
 * Represents the health state of the stateful service replica, which contains
 * the replica ID and the aggregated health state.
 *
 */
export interface StatefulServiceReplicaHealthState {
  /**
   * @member {string} serviceKind Polymorphic Discriminator
   */
  serviceKind: "Stateful";
  /**
   * @member {HealthState} [aggregatedHealthState] The health state of a
   * Service Fabric entity such as Cluster, Node, Application, Service,
   * Partition, Replica etc. Possible values include: 'Invalid', 'Ok',
   * 'Warning', 'Error', 'Unknown'
   */
  aggregatedHealthState?: HealthState;
  /**
   * @member {string} [partitionId] The ID of the partition to which this
   * replica belongs.
   */
  partitionId?: string;
  /**
   * @member {string} [replicaId] Id of a stateful service replica. ReplicaId
   * is used by Service Fabric to uniquely identify a replica of a partition.
   * It is unique within a partition and does not change for the lifetime of
   * the replica. If a replica gets dropped and another replica gets created on
   * the same node for the same partition, it will get a different value for
   * the id. Sometimes the id of a stateless service instance is also referred
   * as a replica id.
   */
  replicaId?: string;
}

/**
 * @interface
 * An interface representing StatefulServiceTypeDescription.
 * Describes a stateful service type defined in the service manifest of a
 * provisioned application type.
 *
 */
export interface StatefulServiceTypeDescription {
  /**
   * @member {string} kind Polymorphic Discriminator
   */
  kind: "Stateful";
  /**
   * @member {boolean} [isStateful] Indicates whether the service type is a
   * stateful service type or a stateless service type. This property is true
   * if the service type is a stateful service type, false otherwise.
   */
  isStateful?: boolean;
  /**
   * @member {string} [serviceTypeName] Name of the service type as specified
   * in the service manifest.
   */
  serviceTypeName?: string;
  /**
   * @member {string} [placementConstraints] The placement constraint to be
   * used when instantiating this service in a Service Fabric cluster.
   */
  placementConstraints?: string;
  /**
   * @member {ServiceLoadMetricDescription[]} [loadMetrics] The service load
   * metrics is given as an array of ServiceLoadMetricDescription objects.
   */
  loadMetrics?: ServiceLoadMetricDescription[];
  /**
   * @member {ServicePlacementPolicyDescriptionUnion[]}
   * [servicePlacementPolicies] List of service placement policy descriptions.
   */
  servicePlacementPolicies?: ServicePlacementPolicyDescriptionUnion[];
  /**
   * @member {ServiceTypeExtensionDescription[]} [extensions] List of service
   * type extensions.
   */
  extensions?: ServiceTypeExtensionDescription[];
  /**
   * @member {boolean} [hasPersistedState] A flag indicating whether this is a
   * persistent service which stores states on the local disk. If it is then
   * the value of this property is true, if not it is false.
   */
  hasPersistedState?: boolean;
}

/**
 * @interface
 * An interface representing StatelessServiceInfo.
 * Information about a stateless Service Fabric service.
 *
 */
export interface StatelessServiceInfo {
  /**
   * @member {string} serviceKind Polymorphic Discriminator
   */
  serviceKind: "Stateless";
  /**
   * @member {string} [id] The identity of the service. This ID is an encoded
   * representation of the service name. This is used in the REST APIs to
   * identify the service resource.
   * Starting in version 6.0, hierarchical names are delimited with the "\~"
   * character. For example, if the service name is "fabric:/myapp/app1/svc1",
   * the service identity would be "myapp~app1\~svc1" in 6.0+ and
   * "myapp/app1/svc1" in previous versions.
   */
  id?: string;
  /**
   * @member {string} [name] The full name of the service with 'fabric:' URI
   * scheme.
   */
  name?: string;
  /**
   * @member {string} [typeName] Name of the service type as specified in the
   * service manifest.
   */
  typeName?: string;
  /**
   * @member {string} [manifestVersion] The version of the service manifest.
   */
  manifestVersion?: string;
  /**
   * @member {HealthState} [healthState] The health state of a Service Fabric
   * entity such as Cluster, Node, Application, Service, Partition, Replica
   * etc. Possible values include: 'Invalid', 'Ok', 'Warning', 'Error',
   * 'Unknown'
   */
  healthState?: HealthState;
  /**
   * @member {ServiceStatus} [serviceStatus] The status of the application.
   * Possible values include: 'Unknown', 'Active', 'Upgrading', 'Deleting',
   * 'Creating', 'Failed'
   */
  serviceStatus?: ServiceStatus;
  /**
   * @member {boolean} [isServiceGroup] Whether the service is in a service
   * group.
   */
  isServiceGroup?: boolean;
}

/**
 * @interface
 * An interface representing StatelessServiceInstanceHealth.
 * Represents the health of the stateless service instance.
 * Contains the instance aggregated health state, the health events and the
 * unhealthy evaluations.
 *
 */
export interface StatelessServiceInstanceHealth {
  /**
   * @member {string} serviceKind Polymorphic Discriminator
   */
  serviceKind: "Stateless";
  /**
   * @member {HealthState} [aggregatedHealthState] The HealthState representing
   * the aggregated health state of the entity computed by Health Manager.
   * The health evaluation of the entity reflects all events reported on the
   * entity and its children (if any).
   * The aggregation is done by applying the desired health policy. Possible
   * values include: 'Invalid', 'Ok', 'Warning', 'Error', 'Unknown'
   */
  aggregatedHealthState?: HealthState;
  /**
   * @member {HealthEvent[]} [healthEvents] The list of health events reported
   * on the entity.
   */
  healthEvents?: HealthEvent[];
  /**
   * @member {HealthEvaluationWrapper[]} [unhealthyEvaluations] The unhealthy
   * evaluations that show why the current aggregated health state was returned
   * by Health Manager.
   */
  unhealthyEvaluations?: HealthEvaluationWrapper[];
  /**
   * @member {HealthStatistics} [healthStatistics] Shows the health statistics
   * for all children types of the queried entity.
   */
  healthStatistics?: HealthStatistics;
  /**
   * @member {string} [partitionId] Id of the partition to which this replica
   * belongs.
   */
  partitionId?: string;
  /**
   * @member {string} [instanceId] Id of a stateless service instance.
   * InstanceId is used by Service Fabric to uniquely identify an instance of a
   * partition of a stateless service. It is unique within a partition and does
   * not change for the lifetime of the instance. If the instance has failed
   * over on the same or different node, it will get a different value for the
   * InstanceId.
   */
  instanceId?: string;
}

/**
 * @interface
 * An interface representing StatelessServiceInstanceHealthState.
 * Represents the health state of the stateless service instance, which
 * contains the instance ID and the aggregated health state.
 *
 */
export interface StatelessServiceInstanceHealthState {
  /**
   * @member {string} serviceKind Polymorphic Discriminator
   */
  serviceKind: "Stateless";
  /**
   * @member {HealthState} [aggregatedHealthState] The health state of a
   * Service Fabric entity such as Cluster, Node, Application, Service,
   * Partition, Replica etc. Possible values include: 'Invalid', 'Ok',
   * 'Warning', 'Error', 'Unknown'
   */
  aggregatedHealthState?: HealthState;
  /**
   * @member {string} [partitionId] The ID of the partition to which this
   * replica belongs.
   */
  partitionId?: string;
  /**
   * @member {string} [replicaId] Id of the stateless service instance on the
   * wire this field is called ReplicaId.
   */
  replicaId?: string;
}

/**
 * @interface
 * An interface representing StatelessServicePartitionInfo.
 * Information about a partition of a stateless Service Fabric service.
 *
 */
export interface StatelessServicePartitionInfo {
  /**
   * @member {string} serviceKind Polymorphic Discriminator
   */
  serviceKind: "Stateless";
  /**
   * @member {HealthState} [healthState] The health state of a Service Fabric
   * entity such as Cluster, Node, Application, Service, Partition, Replica
   * etc. Possible values include: 'Invalid', 'Ok', 'Warning', 'Error',
   * 'Unknown'
   */
  healthState?: HealthState;
  /**
   * @member {ServicePartitionStatus} [partitionStatus] The status of the
   * service fabric service partition. Possible values include: 'Invalid',
   * 'Ready', 'NotReady', 'InQuorumLoss', 'Reconfiguring', 'Deleting'
   */
  partitionStatus?: ServicePartitionStatus;
  /**
   * @member {PartitionInformationUnion} [partitionInformation] Information
   * about the partition identity, partitioning scheme and keys supported by
   * it.
   */
  partitionInformation?: PartitionInformationUnion;
  /**
   * @member {number} [instanceCount] Number of instances of this partition.
   */
  instanceCount?: number;
}

/**
 * @interface
 * An interface representing StatelessServiceTypeDescription.
 * Describes a stateless service type defined in the service manifest of a
 * provisioned application type.
 *
 */
export interface StatelessServiceTypeDescription {
  /**
   * @member {string} kind Polymorphic Discriminator
   */
  kind: "Stateless";
  /**
   * @member {boolean} [isStateful] Indicates whether the service type is a
   * stateful service type or a stateless service type. This property is true
   * if the service type is a stateful service type, false otherwise.
   */
  isStateful?: boolean;
  /**
   * @member {string} [serviceTypeName] Name of the service type as specified
   * in the service manifest.
   */
  serviceTypeName?: string;
  /**
   * @member {string} [placementConstraints] The placement constraint to be
   * used when instantiating this service in a Service Fabric cluster.
   */
  placementConstraints?: string;
  /**
   * @member {ServiceLoadMetricDescription[]} [loadMetrics] The service load
   * metrics is given as an array of ServiceLoadMetricDescription objects.
   */
  loadMetrics?: ServiceLoadMetricDescription[];
  /**
   * @member {ServicePlacementPolicyDescriptionUnion[]}
   * [servicePlacementPolicies] List of service placement policy descriptions.
   */
  servicePlacementPolicies?: ServicePlacementPolicyDescriptionUnion[];
  /**
   * @member {ServiceTypeExtensionDescription[]} [extensions] List of service
   * type extensions.
   */
  extensions?: ServiceTypeExtensionDescription[];
  /**
   * @member {boolean} [useImplicitHost] A flag indicating if this type is not
   * implemented and hosted by a user service process, but is implicitly hosted
   * by a system created process. This value is true for services using the
   * guest executable services, false otherwise.
   */
  useImplicitHost?: boolean;
}

/**
 * @interface
 * An interface representing SystemApplicationHealthEvaluation.
 * Represents health evaluation for the fabric:/System application, containing
 * information about the data and the algorithm used by health store to
 * evaluate health. The evaluation is returned only when the aggregated health
 * state of the cluster is either Error or Warning.
 *
 */
export interface SystemApplicationHealthEvaluation {
  /**
   * @member {string} kind Polymorphic Discriminator
   */
  kind: "SystemApplication";
  /**
   * @member {HealthState} [aggregatedHealthState] The health state of a
   * Service Fabric entity such as Cluster, Node, Application, Service,
   * Partition, Replica etc. Possible values include: 'Invalid', 'Ok',
   * 'Warning', 'Error', 'Unknown'
   */
  aggregatedHealthState?: HealthState;
  /**
   * @member {string} [description] Description of the health evaluation, which
   * represents a summary of the evaluation process.
   */
  description?: string;
  /**
   * @member {HealthEvaluationWrapper[]} [unhealthyEvaluations] List of
   * unhealthy evaluations that led to the current aggregated health state of
   * the system application. The types of the unhealthy evaluations can be
   * DeployedApplicationsHealthEvaluation, ServicesHealthEvaluation or
   * EventHealthEvaluation.
   */
  unhealthyEvaluations?: HealthEvaluationWrapper[];
}

/**
 * @interface
 * An interface representing UpgradeDomainDeltaNodesCheckHealthEvaluation.
 * Represents health evaluation for delta unhealthy cluster nodes in an upgrade
 * domain, containing health evaluations for each unhealthy node that impacted
 * current aggregated health state.
 * Can be returned during cluster upgrade when cluster aggregated health state
 * is Warning or Error.
 *
 */
export interface UpgradeDomainDeltaNodesCheckHealthEvaluation {
  /**
   * @member {string} kind Polymorphic Discriminator
   */
  kind: "UpgradeDomainDeltaNodesCheck";
  /**
   * @member {HealthState} [aggregatedHealthState] The health state of a
   * Service Fabric entity such as Cluster, Node, Application, Service,
   * Partition, Replica etc. Possible values include: 'Invalid', 'Ok',
   * 'Warning', 'Error', 'Unknown'
   */
  aggregatedHealthState?: HealthState;
  /**
   * @member {string} [description] Description of the health evaluation, which
   * represents a summary of the evaluation process.
   */
  description?: string;
  /**
   * @member {string} [upgradeDomainName] Name of the upgrade domain where
   * nodes health is currently evaluated.
   */
  upgradeDomainName?: string;
  /**
   * @member {number} [baselineErrorCount] Number of upgrade domain nodes with
   * aggregated heath state Error in the health store at the beginning of the
   * cluster upgrade.
   */
  baselineErrorCount?: number;
  /**
   * @member {number} [baselineTotalCount] Total number of upgrade domain nodes
   * in the health store at the beginning of the cluster upgrade.
   */
  baselineTotalCount?: number;
  /**
   * @member {number} [maxPercentDeltaUnhealthyNodes] Maximum allowed
   * percentage of upgrade domain delta unhealthy nodes from the
   * ClusterUpgradeHealthPolicy.
   */
  maxPercentDeltaUnhealthyNodes?: number;
  /**
   * @member {number} [totalCount] Total number of upgrade domain nodes in the
   * health store.
   */
  totalCount?: number;
  /**
   * @member {HealthEvaluationWrapper[]} [unhealthyEvaluations] List of
   * unhealthy evaluations that led to the aggregated health state. Includes
   * all the unhealthy NodeHealthEvaluation that impacted the aggregated
   * health.
   */
  unhealthyEvaluations?: HealthEvaluationWrapper[];
}

/**
 * @interface
 * An interface representing UpgradeDomainNodesHealthEvaluation.
 * Represents health evaluation for cluster nodes in an upgrade domain,
 * containing health evaluations for each unhealthy node that impacted current
 * aggregated health state. Can be returned when evaluating cluster health
 * during cluster upgrade and the aggregated health state is either Error or
 * Warning.
 *
 */
export interface UpgradeDomainNodesHealthEvaluation {
  /**
   * @member {string} kind Polymorphic Discriminator
   */
  kind: "UpgradeDomainNodes";
  /**
   * @member {HealthState} [aggregatedHealthState] The health state of a
   * Service Fabric entity such as Cluster, Node, Application, Service,
   * Partition, Replica etc. Possible values include: 'Invalid', 'Ok',
   * 'Warning', 'Error', 'Unknown'
   */
  aggregatedHealthState?: HealthState;
  /**
   * @member {string} [description] Description of the health evaluation, which
   * represents a summary of the evaluation process.
   */
  description?: string;
  /**
   * @member {string} [upgradeDomainName] Name of the upgrade domain where
   * nodes health is currently evaluated.
   */
  upgradeDomainName?: string;
  /**
   * @member {number} [maxPercentUnhealthyNodes] Maximum allowed percentage of
   * unhealthy nodes from the ClusterHealthPolicy.
   */
  maxPercentUnhealthyNodes?: number;
  /**
   * @member {number} [totalCount] Total number of nodes in the current upgrade
   * domain.
   */
  totalCount?: number;
  /**
   * @member {HealthEvaluationWrapper[]} [unhealthyEvaluations] List of
   * unhealthy evaluations that led to the aggregated health state. Includes
   * all the unhealthy NodeHealthEvaluation that impacted the aggregated
   * health.
   */
  unhealthyEvaluations?: HealthEvaluationWrapper[];
}

/**
 * @interface
 * An interface representing WaitForInbuildReplicaSafetyCheck.
 * Safety check that waits for the replica build operation to finish. This
 * indicates that there is a replica that is going through the copy or is
 * providing data for building another replica. Bring the node down will abort
 * this copy operation which are typically expensive involving data movements.
 *
 */
export interface WaitForInbuildReplicaSafetyCheck {
  /**
   * @member {string} kind Polymorphic Discriminator
   */
  kind: "WaitForInbuildReplica";
  /**
   * @member {string} [partitionId] Id of the partition which is undergoing the
   * safety check.
   */
  partitionId?: string;
}

/**
 * @interface
 * An interface representing WaitForPrimaryPlacementSafetyCheck.
 * Safety check that waits for the primary replica that was moved out of the
 * node due to upgrade to be placed back again on that node.
 *
 */
export interface WaitForPrimaryPlacementSafetyCheck {
  /**
   * @member {string} kind Polymorphic Discriminator
   */
  kind: "WaitForPrimaryPlacement";
  /**
   * @member {string} [partitionId] Id of the partition which is undergoing the
   * safety check.
   */
  partitionId?: string;
}

/**
 * @interface
 * An interface representing WaitForPrimarySwapSafetyCheck.
 * Safety check that waits for the primary replica to be moved out of the node
 * before starting an upgrade to ensure the availability of the primary replica
 * for the partition.
 *
 */
export interface WaitForPrimarySwapSafetyCheck {
  /**
   * @member {string} kind Polymorphic Discriminator
   */
  kind: "WaitForPrimarySwap";
  /**
   * @member {string} [partitionId] Id of the partition which is undergoing the
   * safety check.
   */
  partitionId?: string;
}

/**
 * @interface
 * An interface representing WaitForReconfigurationSafetyCheck.
 * Safety check that waits for the current reconfiguration of the partition to
 * be completed before starting an upgrade.
 *
 */
export interface WaitForReconfigurationSafetyCheck {
  /**
   * @member {string} kind Polymorphic Discriminator
   */
  kind: "WaitForReconfiguration";
  /**
   * @member {string} [partitionId] Id of the partition which is undergoing the
   * safety check.
   */
  partitionId?: string;
}

/**
 * @interface
 * An interface representing LoadMetricReport.
 * Represents the load metric report which contains the time metric was
 * reported, its name and value.
 *
 */
export interface LoadMetricReport {
  /**
   * @member {Date} [lastReportedUtc] Gets the UTC time when the load was
   * reported.
   */
  lastReportedUtc?: Date;
  /**
   * @member {string} [name] The name of the load metric.
   */
  name?: string;
  /**
   * @member {string} [value] The value of the load metric.
   */
  value?: string;
}

/**
 * @interface
 * An interface representing PartitionLoadInformation.
 * Represents load information for a partition, which contains the primary and
 * secondary reported load metrics.
 * In case there is no load reported, PartitionLoadInformation will contain the
 * default load for the service of the partition.
 * For default loads, LoadMetricReport's LastReportedUtc is set to 0.
 *
 */
export interface PartitionLoadInformation {
  /**
   * @member {string} [partitionId] Id of the partition.
   */
  partitionId?: string;
  /**
   * @member {LoadMetricReport[]} [primaryLoadMetricReports] Array of load
   * reports from the primary replica for this partition.
   */
  primaryLoadMetricReports?: LoadMetricReport[];
  /**
   * @member {LoadMetricReport[]} [secondaryLoadMetricReports] Array of
   * aggregated load reports from all secondary replicas for this partition.
   * Array only contains the latest reported load for each metric.
   */
  secondaryLoadMetricReports?: LoadMetricReport[];
}

/**
 * @interface
 * An interface representing StatefulServiceReplicaInfo.
 * Represents a stateful service replica. This includes information about the
 * identity, role, status, health, node name, uptime, and other details about
 * the replica.
 *
 */
export interface StatefulServiceReplicaInfo {
  /**
   * @member {string} serviceKind Polymorphic Discriminator
   */
  serviceKind: "Stateful";
  /**
   * @member {ReplicaStatus} [replicaStatus] The status of a replica of a
   * service. Possible values include: 'Invalid', 'InBuild', 'Standby',
   * 'Ready', 'Down', 'Dropped'
   */
  replicaStatus?: ReplicaStatus;
  /**
   * @member {HealthState} [healthState] The health state of a Service Fabric
   * entity such as Cluster, Node, Application, Service, Partition, Replica
   * etc. Possible values include: 'Invalid', 'Ok', 'Warning', 'Error',
   * 'Unknown'
   */
  healthState?: HealthState;
  /**
   * @member {string} [nodeName] The name of a Service Fabric node.
   */
  nodeName?: string;
  /**
   * @member {string} [address] The address the replica is listening on.
   */
  address?: string;
  /**
   * @member {string} [lastInBuildDurationInSeconds] The last in build duration
   * of the replica in seconds.
   */
  lastInBuildDurationInSeconds?: string;
  /**
   * @member {ReplicaRole} [replicaRole] The role of a replica of a stateful
   * service. Possible values include: 'Unknown', 'None', 'Primary',
   * 'IdleSecondary', 'ActiveSecondary'
   */
  replicaRole?: ReplicaRole;
  /**
   * @member {string} [replicaId] Id of a stateful service replica. ReplicaId
   * is used by Service Fabric to uniquely identify a replica of a partition.
   * It is unique within a partition and does not change for the lifetime of
   * the replica. If a replica gets dropped and another replica gets created on
   * the same node for the same partition, it will get a different value for
   * the id. Sometimes the id of a stateless service instance is also referred
   * as a replica id.
   */
  replicaId?: string;
}

/**
 * @interface
 * An interface representing StatelessServiceInstanceInfo.
 * Represents a stateless service instance. This includes information about the
 * identity, status, health, node name, uptime, and other details about the
 * instance.
 *
 */
export interface StatelessServiceInstanceInfo {
  /**
   * @member {string} serviceKind Polymorphic Discriminator
   */
  serviceKind: "Stateless";
  /**
   * @member {ReplicaStatus} [replicaStatus] The status of a replica of a
   * service. Possible values include: 'Invalid', 'InBuild', 'Standby',
   * 'Ready', 'Down', 'Dropped'
   */
  replicaStatus?: ReplicaStatus;
  /**
   * @member {HealthState} [healthState] The health state of a Service Fabric
   * entity such as Cluster, Node, Application, Service, Partition, Replica
   * etc. Possible values include: 'Invalid', 'Ok', 'Warning', 'Error',
   * 'Unknown'
   */
  healthState?: HealthState;
  /**
   * @member {string} [nodeName] The name of a Service Fabric node.
   */
  nodeName?: string;
  /**
   * @member {string} [address] The address the replica is listening on.
   */
  address?: string;
  /**
   * @member {string} [lastInBuildDurationInSeconds] The last in build duration
   * of the replica in seconds.
   */
  lastInBuildDurationInSeconds?: string;
  /**
   * @member {string} [instanceId] Id of a stateless service instance.
   * InstanceId is used by Service Fabric to uniquely identify an instance of a
   * partition of a stateless service. It is unique within a partition and does
   * not change for the lifetime of the instance. If the instance has failed
   * over on the same or different node, it will get a different value for the
   * InstanceId.
   */
  instanceId?: string;
}

/**
 * @interface
 * An interface representing ClusterUpgradeDescriptionObject.
 * Represents a ServiceFabric cluster upgrade
 *
 */
export interface ClusterUpgradeDescriptionObject {
  /**
   * @member {string} [configVersion] The cluster configuration version
   * (specified in the cluster manifest).
   */
  configVersion?: string;
  /**
   * @member {string} [codeVersion] The ServiceFabric code version of the
   * cluster.
   */
  codeVersion?: string;
  /**
   * @member {UpgradeKind} [upgradeKind] The kind of upgrade out of the
   * following possible values. Possible values include: 'Invalid', 'Rolling'.
   * Default value: 'Rolling' .
   */
  upgradeKind?: UpgradeKind;
  /**
   * @member {UpgradeMode} [rollingUpgradeMode] The mode used to monitor health
   * during a rolling upgrade. The values are UnmonitoredAuto,
   * UnmonitoredManual, and Monitored. Possible values include: 'Invalid',
   * 'UnmonitoredAuto', 'UnmonitoredManual', 'Monitored'. Default value:
   * 'UnmonitoredAuto' .
   */
  rollingUpgradeMode?: UpgradeMode;
  /**
   * @member {number} [upgradeReplicaSetCheckTimeoutInSeconds] The maximum
   * amount of time to block processing of an upgrade domain and prevent loss
   * of availability when there are unexpected issues. When this timeout
   * expires, processing of the upgrade domain will proceed regardless of
   * availability loss issues. The timeout is reset at the start of each
   * upgrade domain. Valid values are between 0 and 42949672925 inclusive.
   * (unsigned 32-bit integer).
   */
  upgradeReplicaSetCheckTimeoutInSeconds?: number;
  /**
   * @member {boolean} [forceRestart] If true, then processes are forcefully
   * restarted during upgrade even when the code version has not changed (the
   * upgrade only changes configuration or data).
   */
  forceRestart?: boolean;
  /**
   * @member {boolean} [enableDeltaHealthEvaluation] When true, enables delta
   * health evaluation rather than absolute health evaluation after completion
   * of each upgrade domain.
   */
  enableDeltaHealthEvaluation?: boolean;
  /**
   * @member {MonitoringPolicyDescription} [monitoringPolicy] Describes the
   * parameters for monitoring an upgrade in Monitored mode.
   */
  monitoringPolicy?: MonitoringPolicyDescription;
  /**
   * @member {ClusterHealthPolicy} [clusterHealthPolicy] Defines a health
   * policy used to evaluate the health of the cluster or of a cluster node.
   */
  clusterHealthPolicy?: ClusterHealthPolicy;
  /**
   * @member {ClusterUpgradeHealthPolicyObject} [clusterUpgradeHealthPolicy]
   * Defines a health policy used to evaluate the health of the cluster during
   * a cluster upgrade.
   */
  clusterUpgradeHealthPolicy?: ClusterUpgradeHealthPolicyObject;
  /**
   * @member {ApplicationHealthPolicyMapItem[]} [applicationHealthPolicyMap]
   * Defines a map that contains specific application health policies for
   * different applications.
   * Each entry specifies as key the application name and as value an
   * ApplicationHealthPolicy used to evaluate the application health.
   * If an application is not specified in the map, the application health
   * evaluation uses the ApplicationHealthPolicy found in its application
   * manifest or the default application health policy (if no health policy is
   * defined in the manifest).
   * The map is empty by default.
   */
  applicationHealthPolicyMap?: ApplicationHealthPolicyMapItem[];
}

/**
 * @interface
 * An interface representing FailedUpgradeDomainProgressObject.
 * The detailed upgrade progress for nodes in the current upgrade domain at the
 * point of failure.
 *
 */
export interface FailedUpgradeDomainProgressObject {
  /**
   * @member {string} [domainName] The name of the upgrade domain
   */
  domainName?: string;
  /**
   * @member {NodeUpgradeProgressInfo[]} [nodeUpgradeProgressList] List of
   * upgrading nodes and their statuses
   */
  nodeUpgradeProgressList?: NodeUpgradeProgressInfo[];
}

/**
 * @interface
 * An interface representing ClusterUpgradeProgressObject.
 * Information about a cluster upgrade.
 *
 */
export interface ClusterUpgradeProgressObject {
  /**
   * @member {string} [codeVersion] The ServiceFabric code version of the
   * cluster.
   */
  codeVersion?: string;
  /**
   * @member {string} [configVersion] The cluster configuration version
   * (specified in the cluster manifest).
   */
  configVersion?: string;
  /**
   * @member {UpgradeDomainInfo[]} [upgradeDomains] List of upgrade domains and
   * their statuses.
   */
  upgradeDomains?: UpgradeDomainInfo[];
  /**
   * @member {UpgradeState} [upgradeState] The state of the upgrade domain.
   * Possible values include: 'Invalid', 'RollingBackInProgress',
   * 'RollingBackCompleted', 'RollingForwardPending',
   * 'RollingForwardInProgress', 'RollingForwardCompleted', 'Failed'
   */
  upgradeState?: UpgradeState;
  /**
   * @member {string} [nextUpgradeDomain] The name of the next upgrade domain
   * to be processed.
   */
  nextUpgradeDomain?: string;
  /**
   * @member {UpgradeMode} [rollingUpgradeMode] The mode used to monitor health
   * during a rolling upgrade. The values are UnmonitoredAuto,
   * UnmonitoredManual, and Monitored. Possible values include: 'Invalid',
   * 'UnmonitoredAuto', 'UnmonitoredManual', 'Monitored'. Default value:
   * 'UnmonitoredAuto' .
   */
  rollingUpgradeMode?: UpgradeMode;
  /**
   * @member {ClusterUpgradeDescriptionObject} [upgradeDescription] Represents
   * a ServiceFabric cluster upgrade
   */
  upgradeDescription?: ClusterUpgradeDescriptionObject;
  /**
   * @member {string} [upgradeDurationInMilliseconds] The estimated elapsed
   * time spent processing the current overall upgrade.
   */
  upgradeDurationInMilliseconds?: string;
  /**
   * @member {string} [upgradeDomainDurationInMilliseconds] The estimated
   * elapsed time spent processing the current upgrade domain.
   */
  upgradeDomainDurationInMilliseconds?: string;
  /**
   * @member {HealthEvaluationWrapper[]} [unhealthyEvaluations] List of health
   * evaluations that resulted in the current aggregated health state.
   */
  unhealthyEvaluations?: HealthEvaluationWrapper[];
  /**
   * @member {CurrentUpgradeDomainProgressInfo} [currentUpgradeDomainProgress]
   * Information about the current in-progress upgrade domain.
   */
  currentUpgradeDomainProgress?: CurrentUpgradeDomainProgressInfo;
  /**
   * @member {string} [startTimestampUtc] The start time of the upgrade in UTC.
   */
  startTimestampUtc?: string;
  /**
   * @member {string} [failureTimestampUtc] The failure time of the upgrade in
   * UTC.
   */
  failureTimestampUtc?: string;
  /**
   * @member {FailureReason} [failureReason] The cause of an upgrade failure
   * that resulted in FailureAction being executed. Possible values include:
   * 'None', 'Interrupted', 'HealthCheck', 'UpgradeDomainTimeout',
   * 'OverallUpgradeTimeout'
   */
  failureReason?: FailureReason;
  /**
   * @member {FailedUpgradeDomainProgressObject}
   * [upgradeDomainProgressAtFailure] The detailed upgrade progress for nodes
   * in the current upgrade domain at the point of failure.
   */
  upgradeDomainProgressAtFailure?: FailedUpgradeDomainProgressObject;
}

/**
 * @interface
 * An interface representing ClusterConfigurationUpgradeDescription.
 * Describes the parameters for a standalone cluster configuration upgrade.
 *
 */
export interface ClusterConfigurationUpgradeDescription {
  /**
   * @member {string} clusterConfig The cluster configuration.
   */
  clusterConfig: string;
  /**
   * @member {string} [healthCheckRetryTimeout] The length of time between
   * attempts to perform a health checks if the application or cluster is not
   * healthy. Default value: 'PT0H0M0S' .
   */
  healthCheckRetryTimeout?: string;
  /**
   * @member {string} [healthCheckWaitDurationInSeconds] The length of time to
   * wait after completing an upgrade domain before starting the health checks
   * process. Default value: 'PT0H0M0S' .
   */
  healthCheckWaitDurationInSeconds?: string;
  /**
   * @member {string} [healthCheckStableDurationInSeconds] The length of time
   * that the application or cluster must remain healthy. Default value:
   * 'PT0H0M0S' .
   */
  healthCheckStableDurationInSeconds?: string;
  /**
   * @member {string} [upgradeDomainTimeoutInSeconds] The timeout for the
   * upgrade domain. Default value: 'PT0H0M0S' .
   */
  upgradeDomainTimeoutInSeconds?: string;
  /**
   * @member {string} [upgradeTimeoutInSeconds] The upgrade timeout. Default
   * value: 'PT0H0M0S' .
   */
  upgradeTimeoutInSeconds?: string;
  /**
   * @member {number} [maxPercentUnhealthyApplications] The maximum allowed
   * percentage of unhealthy applications during the upgrade. Allowed values
   * are integer values from zero to 100. Default value: 0 .
   */
  maxPercentUnhealthyApplications?: number;
  /**
   * @member {number} [maxPercentUnhealthyNodes] The maximum allowed percentage
   * of unhealthy nodes during the upgrade. Allowed values are integer values
   * from zero to 100. Default value: 0 .
   */
  maxPercentUnhealthyNodes?: number;
  /**
   * @member {number} [maxPercentDeltaUnhealthyNodes] The maximum allowed
   * percentage of delta health degradation during the upgrade. Allowed values
   * are integer values from zero to 100. Default value: 0 .
   */
  maxPercentDeltaUnhealthyNodes?: number;
  /**
   * @member {number} [maxPercentUpgradeDomainDeltaUnhealthyNodes] The maximum
   * allowed percentage of upgrade domain delta health degradation during the
   * upgrade. Allowed values are integer values from zero to 100. Default
   * value: 0 .
   */
  maxPercentUpgradeDomainDeltaUnhealthyNodes?: number;
  /**
   * @member {ApplicationHealthPolicies} [applicationHealthPolicies] Defines
   * the application health policy map used to evaluate the health of an
   * application or one of its children entities.
   */
  applicationHealthPolicies?: ApplicationHealthPolicies;
}

/**
 * @interface
 * An interface representing UpgradeOrchestrationServiceState.
 * Service state of Service Fabric Upgrade Orchestration Service.
 *
 */
export interface UpgradeOrchestrationServiceState {
  /**
   * @member {string} [serviceState] The state of Service Fabric Upgrade
   * Orchestration Service.
   */
  serviceState?: string;
}

/**
 * @interface
 * An interface representing UpgradeOrchestrationServiceStateSummary.
 * Service state summary of Service Fabric Upgrade Orchestration Service.
 *
 */
export interface UpgradeOrchestrationServiceStateSummary {
  /**
   * @member {string} [currentCodeVersion] The current code version of the
   * cluster.
   */
  currentCodeVersion?: string;
  /**
   * @member {string} [currentManifestVersion] The current manifest version of
   * the cluster.
   */
  currentManifestVersion?: string;
  /**
   * @member {string} [targetCodeVersion] The target code version of  the
   * cluster.
   */
  targetCodeVersion?: string;
  /**
   * @member {string} [targetManifestVersion] The target manifest version of
   * the cluster.
   */
  targetManifestVersion?: string;
  /**
   * @member {string} [pendingUpgradeType] The type of the pending upgrade of
   * the cluster.
   */
  pendingUpgradeType?: string;
}

/**
 * @interface
 * An interface representing ApplicationTypeImageStorePath.
 * Path description for the application package in the image store specified
 * during the prior copy operation.
 *
 */
export interface ApplicationTypeImageStorePath {
  /**
   * @member {string} applicationTypeBuildPath The relative image store path to
   * the application package.
   */
  applicationTypeBuildPath: string;
}

/**
 * @interface
 * An interface representing UnprovisionApplicationTypeDescriptionInfo.
 * Describes the operation to unregister or unprovision an application type and
 * its version that was registered with the Service Fabric.
 *
 */
export interface UnprovisionApplicationTypeDescriptionInfo {
  /**
   * @member {string} applicationTypeVersion The version of the application
   * type as defined in the application manifest.
   */
  applicationTypeVersion: string;
  /**
   * @member {boolean} [async] The flag indicating whether or not unprovision
   * should occur asynchronously. When set to true, the unprovision operation
   * returns when the request is accepted by the system, and the unprovision
   * operation continues without any timeout limit. The default value is false.
   * However, we recommend setting it to true for large application packages
   * that were provisioned.
   */
  async?: boolean;
}

/**
 * @interface
 * An interface representing CodePackageEntryPointStatistics.
 * Statistics about setup or main entry point  of a code package deployed on a
 * Service Fabric node.
 *
 */
export interface CodePackageEntryPointStatistics {
  /**
   * @member {string} [lastExitCode] The last exit code of the entry point.
   */
  lastExitCode?: string;
  /**
   * @member {Date} [lastActivationTime] The last time (in UTC) when Service
   * Fabric attempted to run the entry point.
   */
  lastActivationTime?: Date;
  /**
   * @member {Date} [lastExitTime] The last time (in UTC) when the entry point
   * finished running.
   */
  lastExitTime?: Date;
  /**
   * @member {Date} [lastSuccessfulActivationTime] The last time (in UTC) when
   * the entry point ran successfully.
   */
  lastSuccessfulActivationTime?: Date;
  /**
   * @member {Date} [lastSuccessfulExitTime] The last time (in UTC) when the
   * entry point finished running gracefully.
   */
  lastSuccessfulExitTime?: Date;
  /**
   * @member {string} [activationCount] Number of times the entry point has
   * run.
   */
  activationCount?: string;
  /**
   * @member {string} [activationFailureCount] Number of times the entry point
   * failed to run.
   */
  activationFailureCount?: string;
  /**
   * @member {string} [continuousActivationFailureCount] Number of times the
   * entry point continuously failed to run.
   */
  continuousActivationFailureCount?: string;
  /**
   * @member {string} [exitCount] Number of times the entry point finished
   * running.
   */
  exitCount?: string;
  /**
   * @member {string} [exitFailureCount] Number of times the entry point failed
   * to exit gracefully.
   */
  exitFailureCount?: string;
  /**
   * @member {string} [continuousExitFailureCount] Number of times the entry
   * point continuously failed to exit gracefully.
   */
  continuousExitFailureCount?: string;
}

/**
 * @interface
 * An interface representing CodePackageEntryPoint.
 * Information about setup or main entry point of a code package deployed on a
 * Service Fabric node.
 *
 */
export interface CodePackageEntryPoint {
  /**
   * @member {string} [entryPointLocation] The location of entry point
   * executable on the node.
   */
  entryPointLocation?: string;
  /**
   * @member {string} [processId] The process ID of the entry point.
   */
  processId?: string;
  /**
   * @member {string} [runAsUserName] The user name under which entry point
   * executable is run on the node.
   */
  runAsUserName?: string;
  /**
   * @member {CodePackageEntryPointStatistics}
   * [codePackageEntryPointStatistics] Statistics about setup or main entry
   * point  of a code package deployed on a Service Fabric node.
   */
  codePackageEntryPointStatistics?: CodePackageEntryPointStatistics;
  /**
   * @member {EntryPointStatus} [status] Specifies the status of the code
   * package entry point deployed on a Service Fabric node. Possible values
   * include: 'Invalid', 'Pending', 'Starting', 'Started', 'Stopping',
   * 'Stopped'
   */
  status?: EntryPointStatus;
  /**
   * @member {Date} [nextActivationTime] The time (in UTC) when the entry point
   * executable will be run next.
   */
  nextActivationTime?: Date;
  /**
   * @member {string} [instanceId] The instance ID for current running entry
   * point. For a code package setup entry point (if specified) runs first and
   * after it finishes main entry point is started. Each time entry point
   * executable is run, its instance id will change.
   */
  instanceId?: string;
}

/**
 * @interface
 * An interface representing DeployedCodePackageInfo.
 * Information about code package deployed on a Service Fabric node.
 *
 */
export interface DeployedCodePackageInfo {
  /**
   * @member {string} [name] The name of the code package.
   */
  name?: string;
  /**
   * @member {string} [version] The version of the code package specified in
   * service manifest.
   */
  version?: string;
  /**
   * @member {string} [serviceManifestName] The name of service manifest that
   * specified this code package.
   */
  serviceManifestName?: string;
  /**
   * @member {string} [servicePackageActivationId] The ActivationId of a
   * deployed service package. If ServicePackageActivationMode specified at the
   * time of creating the service
   * is 'SharedProcess' (or if it is not specified, in which case it defaults
   * to 'SharedProcess'), then value of ServicePackageActivationId
   * is always an empty string.
   */
  servicePackageActivationId?: string;
  /**
   * @member {HostType} [hostType] Specifies the type of host for main entry
   * point of a code package as specified in service manifest. Possible values
   * include: 'Invalid', 'ExeHost', 'ContainerHost'
   */
  hostType?: HostType;
  /**
   * @member {HostIsolationMode} [hostIsolationMode] Specifies the isolation
   * mode of main entry point of a code package when it's host type is
   * ContainerHost. This is specified as part of container host policies in
   * application manifest while importing service manifest. Possible values
   * include: 'None', 'Process', 'HyperV'
   */
  hostIsolationMode?: HostIsolationMode;
  /**
   * @member {DeploymentStatus} [status] Specifies the status of a deployed
   * application or service package on a Service Fabric node. Possible values
   * include: 'Invalid', 'Downloading', 'Activating', 'Active', 'Upgrading',
   * 'Deactivating'
   */
  status?: DeploymentStatus;
  /**
   * @member {string} [runFrequencyInterval] The interval at which code package
   * is run. This is used for periodic code package.
   */
  runFrequencyInterval?: string;
  /**
   * @member {CodePackageEntryPoint} [setupEntryPoint] Information about setup
   * or main entry point of a code package deployed on a Service Fabric node.
   */
  setupEntryPoint?: CodePackageEntryPoint;
  /**
   * @member {CodePackageEntryPoint} [mainEntryPoint] Information about setup
   * or main entry point of a code package deployed on a Service Fabric node.
   */
  mainEntryPoint?: CodePackageEntryPoint;
}

/**
 * @interface
 * An interface representing ChaosContext.
 * Describes a map, which is a collection of (string, string) type key-value
 * pairs. The map can be used to record information about
 * the Chaos run. There cannot be more than 100 such pairs and each string (key
 * or value) can be at most 4095 characters long.
 * This map is set by the starter of the Chaos run to optionally store the
 * context about the specific run.
 *
 */
export interface ChaosContext {
  /**
   * @member {{ [propertyName: string]: string }} [map] Describes a map that
   * contains a collection of ChaosContextMapItem's.
   */
  map?: { [propertyName: string]: string };
}

/**
 * @interface
 * An interface representing ChaosTargetFilter.
 * Defines all filters for targeted Chaos faults, for example, faulting only
 * certain node types or faulting only certain applications.
 * If ChaosTargetFilter is not used, Chaos faults all cluster entities. If
 * ChaosTargetFilter is used, Chaos faults only the entities that meet the
 * ChaosTargetFilter
 * specification. NodeTypeInclusionList and ApplicationInclusionList allow a
 * union semantics only. It is not possible to specify an intersection
 * of NodeTypeInclusionList and ApplicationInclusionList. For example, it is
 * not possible to specify "fault this application only when it is on that node
 * type."
 * Once an entity is included in either NodeTypeInclusionList or
 * ApplicationInclusionList, that entity cannot be excluded using
 * ChaosTargetFilter. Even if
 * applicationX does not appear in ApplicationInclusionList, in some Chaos
 * iteration applicationX can be faulted because it happens to be on a node of
 * nodeTypeY that is included
 * in NodeTypeInclusionList. If both NodeTypeInclusionList and
 * ApplicationInclusionList are null or empty, an ArgumentException is thrown.
 *
 */
export interface ChaosTargetFilter {
  /**
   * @member {string[]} [nodeTypeInclusionList] A list of node types to include
   * in Chaos faults.
   * All types of faults (restart node, restart code package, remove replica,
   * restart replica, move primary, and move secondary) are enabled for the
   * nodes of these node types.
   * If a nodetype (say NodeTypeX) does not appear in the
   * NodeTypeInclusionList, then node level faults (like NodeRestart) will
   * never be enabled for the nodes of
   * NodeTypeX, but code package and replica faults can still be enabled for
   * NodeTypeX if an application in the ApplicationInclusionList.
   * happens to reside on a node of NodeTypeX.
   * At most 100 node type names can be included in this list, to increase this
   * number, a config upgrade is required for
   * MaxNumberOfNodeTypesInChaosEntityFilter configuration.
   */
  nodeTypeInclusionList?: string[];
  /**
   * @member {string[]} [applicationInclusionList] A list of application URI's
   * to include in Chaos faults.
   * All replicas belonging to services of these applications are amenable to
   * replica faults (restart replica, remove replica, move primary, and move
   * secondary) by Chaos.
   * Chaos may restart a code package only if the code package hosts replicas
   * of these applications only.
   * If an application does not appear in this list, it can still be faulted in
   * some Chaos iteration if the application ends up on a node of a node type
   * that is included in NodeTypeInclusionList.
   * However, if applicationX is tied to nodeTypeY through placement
   * constraints and applicationX is absent from ApplicationInclusionList and
   * nodeTypeY is absent from NodeTypeInclusionList, then applicationX will
   * never be faulted.
   * At most 1000 application names can be included in this list, to increase
   * this number, a config upgrade is required for
   * MaxNumberOfApplicationsInChaosEntityFilter configuration.
   */
  applicationInclusionList?: string[];
}

/**
 * @interface
 * An interface representing ChaosParameters.
 * Defines all the parameters to configure a Chaos run.
 *
 */
export interface ChaosParameters {
  /**
   * @member {string} [timeToRunInSeconds] Total time (in seconds) for which
   * Chaos will run before automatically stopping. The maximum allowed value is
   * 4,294,967,295 (System.UInt32.MaxValue). Default value: '4294967295' .
   */
  timeToRunInSeconds?: string;
  /**
   * @member {number} [maxClusterStabilizationTimeoutInSeconds] The maximum
   * amount of time to wait for all cluster entities to become stable and
   * healthy. Chaos executes in iterations and at the start of each iteration
   * it validates the health of cluster entities.
   * During validation if a cluster entity is not stable and healthy within
   * MaxClusterStabilizationTimeoutInSeconds, Chaos generates a validation
   * failed event. Default value: 60 .
   */
  maxClusterStabilizationTimeoutInSeconds?: number;
  /**
   * @member {number} [maxConcurrentFaults] MaxConcurrentFaults is the maximum
   * number of concurrent faults induced per iteration.
   * Chaos executes in iterations and two consecutive iterations are separated
   * by a validation phase.
   * The higher the concurrency, the more aggressive the injection of faults,
   * leading to inducing more complex series of states to uncover bugs.
   * The recommendation is to start with a value of 2 or 3 and to exercise
   * caution while moving up. Default value: 1 .
   */
  maxConcurrentFaults?: number;
  /**
   * @member {boolean} [enableMoveReplicaFaults] Enables or disables the move
   * primary and move secondary faults. Default value: true .
   */
  enableMoveReplicaFaults?: boolean;
  /**
   * @member {number} [waitTimeBetweenFaultsInSeconds] Wait time (in seconds)
   * between consecutive faults within a single iteration.
   * The larger the value, the lower the overlapping between faults and the
   * simpler the sequence of state transitions that the cluster goes through.
   * The recommendation is to start with a value between 1 and 5 and exercise
   * caution while moving up. Default value: 20 .
   */
  waitTimeBetweenFaultsInSeconds?: number;
  /**
   * @member {number} [waitTimeBetweenIterationsInSeconds] Time-separation (in
   * seconds) between two consecutive iterations of Chaos.
   * The larger the value, the lower the fault injection rate. Default value:
   * 30 .
   */
  waitTimeBetweenIterationsInSeconds?: number;
  /**
   * @member {ClusterHealthPolicy} [clusterHealthPolicy] Passed-in cluster
   * health policy is used to validate health of the cluster in between Chaos
   * iterations. If the cluster health is in error or if an unexpected
   * exception happens during fault execution--to provide the cluster with some
   * time to recuperate--Chaos will wait for 30 minutes before the next
   * health-check.
   */
  clusterHealthPolicy?: ClusterHealthPolicy;
  /**
   * @member {ChaosContext} [context] Describes a map, which is a collection of
   * (string, string) type key-value pairs. The map can be used to record
   * information about
   * the Chaos run. There cannot be more than 100 such pairs and each string
   * (key or value) can be at most 4095 characters long.
   * This map is set by the starter of the Chaos run to optionally store the
   * context about the specific run.
   */
  context?: ChaosContext;
  /**
   * @member {ChaosTargetFilter} [chaosTargetFilter] List of cluster entities
   * to target for Chaos faults.
   * This filter can be used to target Chaos faults only to certain node types
   * or only to certain application instances. If ChaosTargetFilter is not
   * used, Chaos faults all cluster entities.
   * If ChaosTargetFilter is used, Chaos faults only the entities that meet the
   * ChaosTargetFilter specification.
   */
  chaosTargetFilter?: ChaosTargetFilter;
}

/**
 * @interface
 * An interface representing Chaos.
 * Contains a description of Chaos.
 *
 */
export interface Chaos {
  /**
   * @member {ChaosParameters} [chaosParameters] If Chaos is running, these are
   * the parameters Chaos is running with.
   */
  chaosParameters?: ChaosParameters;
  /**
   * @member {ChaosStatus} [status] Current status of the Chaos run. Possible
   * values include: 'Invalid', 'Running', 'Stopped'
   */
  status?: ChaosStatus;
  /**
   * @member {ChaosScheduleStatus} [scheduleStatus] Current status of the
   * schedule. Possible values include: 'Invalid', 'Stopped', 'Active',
   * 'Expired', 'Pending'
   */
  scheduleStatus?: ChaosScheduleStatus;
}

/**
 * @interface
 * An interface representing ChaosParametersDictionaryItem.
 * Defines an item in ChaosParametersDictionary of the Chaos Schedule.
 *
 */
export interface ChaosParametersDictionaryItem {
  /**
   * @member {string} key The key identifying the Chaos Parameter in the
   * dictionary. This key is referenced by Chaos Schedule Jobs.
   */
  key: string;
  /**
   * @member {ChaosParameters} value Defines all the parameters to configure a
   * Chaos run.
   */
  value: ChaosParameters;
}

/**
 * Contains the possible cases for ChaosEvent.
 */
export type ChaosEventUnion = ChaosEvent | ExecutingFaultsChaosEvent | StartedChaosEvent | StoppedChaosEvent | TestErrorChaosEvent | ValidationFailedChaosEvent | WaitingChaosEvent;

/**
 * @interface
 * An interface representing ChaosEvent.
 * Represents an event generated during a Chaos run.
 *
 */
export interface ChaosEvent {
  /**
   * @member {string} kind Polymorphic Discriminator
   */
  kind: "ChaosEvent";
  /**
   * @member {Date} timeStampUtc The UTC timestamp when this Chaos event was
   * generated.
   */
  timeStampUtc: Date;
}

/**
 * @interface
 * An interface representing ChaosEventWrapper.
 * Wrapper object for Chaos event.
 *
 */
export interface ChaosEventWrapper {
  /**
   * @member {ChaosEventUnion} [chaosEvent] Represents an event generated
   * during a Chaos run.
   */
  chaosEvent?: ChaosEventUnion;
}

/**
 * @interface
 * An interface representing ChaosEventsSegment.
 * Contains the list of Chaos events and the continuation token to get the next
 * segment.
 *
 */
export interface ChaosEventsSegment {
  /**
   * @member {string} [continuationToken] The continuation token parameter is
   * used to obtain next set of results. The continuation token is included in
   * the response of the API when the results from the system do not fit in a
   * single response. When this value is passed to the next API call, the API
   * returns next set of results. If there are no further results, then the
   * continuation token is not included in the response.
   */
  continuationToken?: string;
  /**
   * @member {ChaosEventWrapper[]} [history] List of Chaos events that meet the
   * user-supplied criteria.
   */
  history?: ChaosEventWrapper[];
}

/**
 * @interface
 * An interface representing ChaosScheduleJobActiveDaysOfWeek.
 * Defines the days of the week that a Chaos Schedule Job will run for.
 *
 */
export interface ChaosScheduleJobActiveDaysOfWeek {
  /**
   * @member {boolean} [sunday] Indicates if the Chaos Schedule Job will run on
   * Sunday. Default value: false .
   */
  sunday?: boolean;
  /**
   * @member {boolean} [monday] Indicates if the Chaos Schedule Job will run on
   * Monday. Default value: false .
   */
  monday?: boolean;
  /**
   * @member {boolean} [tuesday] Indicates if the Chaos Schedule Job will run
   * on Tuesday. Default value: false .
   */
  tuesday?: boolean;
  /**
   * @member {boolean} [wednesday] Indicates if the Chaos Schedule Job will run
   * on Wednesday. Default value: false .
   */
  wednesday?: boolean;
  /**
   * @member {boolean} [thursday] Indicates if the Chaos Schedule Job will run
   * on Thursday. Default value: false .
   */
  thursday?: boolean;
  /**
   * @member {boolean} [friday] Indicates if the Chaos Schedule Job will run on
   * Friday. Default value: false .
   */
  friday?: boolean;
  /**
   * @member {boolean} [saturday] Indicates if the Chaos Schedule Job will run
   * on Saturday. Default value: false .
   */
  saturday?: boolean;
}

/**
 * @interface
 * An interface representing TimeOfDay.
 * Defines an hour and minute of the day specified in 24 hour time.
 *
 */
export interface TimeOfDay {
  /**
   * @member {number} [hour] Represents the hour of the day. Value must be
   * between 0 and 23 inclusive.
   */
  hour?: number;
  /**
   * @member {number} [minute] Represents the minute of the hour. Value must be
   * between 0 to 59 inclusive.
   */
  minute?: number;
}

/**
 * @interface
 * An interface representing TimeRange.
 * Defines a time range in a 24 hour day specified by a start and end time.
 *
 */
export interface TimeRange {
  /**
   * @member {TimeOfDay} [startTime] Defines an hour and minute of the day
   * specified in 24 hour time.
   */
  startTime?: TimeOfDay;
  /**
   * @member {TimeOfDay} [endTime] Defines an hour and minute of the day
   * specified in 24 hour time.
   */
  endTime?: TimeOfDay;
}

/**
 * @interface
 * An interface representing ChaosScheduleJob.
 * Defines a repetition rule and parameters of Chaos to be used with the Chaos
 * Schedule.
 *
 */
export interface ChaosScheduleJob {
  /**
   * @member {string} [chaosParameters] A reference to which Chaos Parameters
   * of the Chaos Schedule to use.
   */
  chaosParameters?: string;
  /**
   * @member {ChaosScheduleJobActiveDaysOfWeek} [days] Defines the days of the
   * week that a Chaos Schedule Job will run for.
   */
  days?: ChaosScheduleJobActiveDaysOfWeek;
  /**
   * @member {TimeRange[]} [times] A list of Time Ranges that specify when
   * during active days that this job will run. The times are interpreted as
   * UTC.
   */
  times?: TimeRange[];
}

/**
 * @interface
 * An interface representing ChaosSchedule.
 * Defines the schedule used by Chaos.
 *
 */
export interface ChaosSchedule {
  /**
   * @member {Date} [startDate] The date and time Chaos will start using this
   * schedule. Default value: new Date('1601-01-01T00:00:00Z') .
   */
  startDate?: Date;
  /**
   * @member {Date} [expiryDate] The date and time Chaos will continue to use
   * this schedule until. Default value: new Date('9999-12-31T23:59:59.999Z') .
   */
  expiryDate?: Date;
  /**
   * @member {ChaosParametersDictionaryItem[]} [chaosParametersDictionary] A
   * mapping of string names to Chaos Parameters to be referenced by Chaos
   * Schedule Jobs.
   */
  chaosParametersDictionary?: ChaosParametersDictionaryItem[];
  /**
   * @member {ChaosScheduleJob[]} [jobs] A list of all Chaos Schedule Jobs that
   * will be automated by the schedule.
   */
  jobs?: ChaosScheduleJob[];
}

/**
 * @interface
 * An interface representing ChaosScheduleDescription.
 * Defines the Chaos Schedule used by Chaos and the version of the Chaos
 * Schedule. The version value wraps back to 0 after surpassing 2,147,483,647.
 *
 */
export interface ChaosScheduleDescription {
  /**
   * @member {number} [version] The version number of the Schedule.
   */
  version?: number;
  /**
   * @member {ChaosSchedule} [schedule] Defines the schedule used by Chaos.
   */
  schedule?: ChaosSchedule;
}

/**
 * @interface
 * An interface representing ExecutingFaultsChaosEvent.
 * Describes a Chaos event that gets generated when Chaos has decided on the
 * faults for an iteration. This Chaos event contains the details of the faults
 * as a list of strings.
 *
 */
export interface ExecutingFaultsChaosEvent {
  /**
   * @member {string} kind Polymorphic Discriminator
   */
  kind: "ExecutingFaults";
  /**
   * @member {Date} timeStampUtc The UTC timestamp when this Chaos event was
   * generated.
   */
  timeStampUtc: Date;
  /**
   * @member {string[]} [faults] List of string description of the faults that
   * Chaos decided to execute in an iteration.
   */
  faults?: string[];
}

/**
 * @interface
 * An interface representing StartedChaosEvent.
 * Describes a Chaos event that gets generated when Chaos is started.
 *
 */
export interface StartedChaosEvent {
  /**
   * @member {string} kind Polymorphic Discriminator
   */
  kind: "Started";
  /**
   * @member {Date} timeStampUtc The UTC timestamp when this Chaos event was
   * generated.
   */
  timeStampUtc: Date;
  /**
   * @member {ChaosParameters} [chaosParameters] Defines all the parameters to
   * configure a Chaos run.
   */
  chaosParameters?: ChaosParameters;
}

/**
 * @interface
 * An interface representing StoppedChaosEvent.
 * Describes a Chaos event that gets generated when Chaos stops because either
 * the user issued a stop or the time to run was up.
 *
 */
export interface StoppedChaosEvent {
  /**
   * @member {string} kind Polymorphic Discriminator
   */
  kind: "Stopped";
  /**
   * @member {Date} timeStampUtc The UTC timestamp when this Chaos event was
   * generated.
   */
  timeStampUtc: Date;
  /**
   * @member {string} [reason] Describes why Chaos stopped. Chaos can stop
   * because of StopChaos API call or the timeToRun provided in ChaosParameters
   * is over.
   */
  reason?: string;
}

/**
 * @interface
 * An interface representing TestErrorChaosEvent.
 * Describes a Chaos event that gets generated when an unexpected event occurs
 * in the Chaos engine.
 * For example, due to the cluster snapshot being inconsistent, while faulting
 * an entity, Chaos found that the entity was already faulted -- which would be
 * an unexpected event.
 *
 */
export interface TestErrorChaosEvent {
  /**
   * @member {string} kind Polymorphic Discriminator
   */
  kind: "TestError";
  /**
   * @member {Date} timeStampUtc The UTC timestamp when this Chaos event was
   * generated.
   */
  timeStampUtc: Date;
  /**
   * @member {string} [reason] Describes why TestErrorChaosEvent was generated.
   * For example, Chaos tries to fault a partition but finds that the partition
   * is no longer fault tolerant, then a TestErrorEvent gets generated with the
   * reason stating that the partition is not fault tolerant.
   */
  reason?: string;
}

/**
 * @interface
 * An interface representing ValidationFailedChaosEvent.
 * Chaos event corresponding to a failure during validation.
 *
 */
export interface ValidationFailedChaosEvent {
  /**
   * @member {string} kind Polymorphic Discriminator
   */
  kind: "ValidationFailed";
  /**
   * @member {Date} timeStampUtc The UTC timestamp when this Chaos event was
   * generated.
   */
  timeStampUtc: Date;
  /**
   * @member {string} [reason] Describes why the ValidationFailedChaosEvent was
   * generated. This may happen because more than MaxPercentUnhealthyNodes are
   * unhealthy for more than MaxClusterStabilizationTimeout. This reason will
   * be in the Reason property of the ValidationFailedChaosEvent as a string.
   */
  reason?: string;
}

/**
 * @interface
 * An interface representing WaitingChaosEvent.
 * Describes a Chaos event that gets generated when Chaos is waiting for the
 * cluster to become ready for faulting, for example, Chaos may be waiting for
 * the on-going upgrade to finish.
 *
 */
export interface WaitingChaosEvent {
  /**
   * @member {string} kind Polymorphic Discriminator
   */
  kind: "Waiting";
  /**
   * @member {Date} timeStampUtc The UTC timestamp when this Chaos event was
   * generated.
   */
  timeStampUtc: Date;
  /**
   * @member {string} [reason] Describes why the WaitingChaosEvent was
   * generated, for example, due to a cluster upgrade.
   */
  reason?: string;
}

/**
 * @interface
 * An interface representing ApplicationCapacityDescription.
 * Describes capacity information for services of this application. This
 * description can be used for describing the following.
 * - Reserving the capacity for the services on the nodes
 * - Limiting the total number of nodes that services of this application can
 * run on
 * - Limiting the custom capacity metrics to limit the total consumption of
 * this metric by the services of this application
 *
 */
export interface ApplicationCapacityDescription {
  /**
   * @member {number} [minimumNodes] The minimum number of nodes where Service
   * Fabric will reserve capacity for this application. Note that this does not
   * mean that the services of this application will be placed on all of those
   * nodes. If this property is set to zero, no capacity will be reserved. The
   * value of this property cannot be more than the value of the MaximumNodes
   * property.
   */
  minimumNodes?: number;
  /**
   * @member {number} [maximumNodes] The maximum number of nodes where Service
   * Fabric will reserve capacity for this application. Note that this does not
   * mean that the services of this application will be placed on all of those
   * nodes. By default, the value of this property is zero and it means that
   * the services can be placed on any node. Default value: 0 .
   */
  maximumNodes?: number;
  /**
   * @member {ApplicationMetricDescription[]} [applicationMetrics] List of
   * application capacity metric description.
   */
  applicationMetrics?: ApplicationMetricDescription[];
}

/**
 * @interface
 * An interface representing ApplicationDescription.
 * Describes a Service Fabric application.
 *
 */
export interface ApplicationDescription {
  /**
   * @member {string} name The name of the application, including the 'fabric:'
   * URI scheme.
   */
  name: string;
  /**
   * @member {string} typeName The application type name as defined in the
   * application manifest.
   */
  typeName: string;
  /**
   * @member {string} typeVersion The version of the application type as
   * defined in the application manifest.
   */
  typeVersion: string;
  /**
   * @member {ApplicationParameter[]} [parameterList] List of application
   * parameters with overridden values from their default values specified in
   * the application manifest.
   */
  parameterList?: ApplicationParameter[];
  /**
   * @member {ApplicationCapacityDescription} [applicationCapacity] Describes
   * capacity information for services of this application. This description
   * can be used for describing the following.
   * - Reserving the capacity for the services on the nodes
   * - Limiting the total number of nodes that services of this application can
   * run on
   * - Limiting the custom capacity metrics to limit the total consumption of
   * this metric by the services of this application
   */
  applicationCapacity?: ApplicationCapacityDescription;
}

/**
 * @interface
 * An interface representing ComposeDeploymentStatusInfo.
 * Information about a Service Fabric compose deployment.
 *
 */
export interface ComposeDeploymentStatusInfo {
  /**
   * @member {string} [name] The name of the deployment.
   */
  name?: string;
  /**
   * @member {string} [applicationName] The name of the application, including
   * the 'fabric:' URI scheme.
   */
  applicationName?: string;
  /**
   * @member {ComposeDeploymentStatus} [status] The status of the compose
   * deployment. Possible values include: 'Invalid', 'Provisioning',
   * 'Creating', 'Ready', 'Unprovisioning', 'Deleting', 'Failed', 'Upgrading'
   */
  status?: ComposeDeploymentStatus;
  /**
   * @member {string} [statusDetails] The status details of compose deployment
   * including failure message.
   */
  statusDetails?: string;
}

/**
 * @interface
 * An interface representing RegistryCredential.
 * Credential information to connect to container registry.
 *
 */
export interface RegistryCredential {
  /**
   * @member {string} [registryUserName] The user name to connect to container
   * registry.
   */
  registryUserName?: string;
  /**
   * @member {string} [registryPassword] The password for supplied username to
   * connect to container registry.
   */
  registryPassword?: string;
  /**
   * @member {boolean} [passwordEncrypted] Indicates that supplied container
   * registry password is encrypted.
   */
  passwordEncrypted?: boolean;
}

/**
 * @interface
 * An interface representing ComposeDeploymentUpgradeDescription.
 * Describes the parameters for a compose deployment upgrade.
 *
 */
export interface ComposeDeploymentUpgradeDescription {
  /**
   * @member {string} deploymentName The name of the deployment.
   */
  deploymentName: string;
  /**
   * @member {string} composeFileContent The content of the compose file that
   * describes the deployment to create.
   */
  composeFileContent: string;
  /**
   * @member {RegistryCredential} [registryCredential] Credential information
   * to connect to container registry.
   */
  registryCredential?: RegistryCredential;
  /**
   * @member {UpgradeKind} upgradeKind The kind of upgrade out of the following
   * possible values. Possible values include: 'Invalid', 'Rolling'. Default
   * value: 'Rolling' .
   */
  upgradeKind: UpgradeKind;
  /**
   * @member {UpgradeMode} [rollingUpgradeMode] The mode used to monitor health
   * during a rolling upgrade. The values are UnmonitoredAuto,
   * UnmonitoredManual, and Monitored. Possible values include: 'Invalid',
   * 'UnmonitoredAuto', 'UnmonitoredManual', 'Monitored'. Default value:
   * 'UnmonitoredAuto' .
   */
  rollingUpgradeMode?: UpgradeMode;
  /**
   * @member {number} [upgradeReplicaSetCheckTimeoutInSeconds] The maximum
   * amount of time to block processing of an upgrade domain and prevent loss
   * of availability when there are unexpected issues. When this timeout
   * expires, processing of the upgrade domain will proceed regardless of
   * availability loss issues. The timeout is reset at the start of each
   * upgrade domain. Valid values are between 0 and 42949672925 inclusive.
   * (unsigned 32-bit integer).
   */
  upgradeReplicaSetCheckTimeoutInSeconds?: number;
  /**
   * @member {boolean} [forceRestart] If true, then processes are forcefully
   * restarted during upgrade even when the code version has not changed (the
   * upgrade only changes configuration or data).
   */
  forceRestart?: boolean;
  /**
   * @member {MonitoringPolicyDescription} [monitoringPolicy] Describes the
   * parameters for monitoring an upgrade in Monitored mode.
   */
  monitoringPolicy?: MonitoringPolicyDescription;
  /**
   * @member {ApplicationHealthPolicy} [applicationHealthPolicy] Defines a
   * health policy used to evaluate the health of an application or one of its
   * children entities.
   */
  applicationHealthPolicy?: ApplicationHealthPolicy;
}

/**
 * @interface
 * An interface representing ComposeDeploymentUpgradeProgressInfo.
 * Describes the parameters for a compose deployment upgrade.
 *
 */
export interface ComposeDeploymentUpgradeProgressInfo {
  /**
   * @member {string} [deploymentName] The name of the target deployment.
   */
  deploymentName?: string;
  /**
   * @member {string} [applicationName] The name of the target application,
   * including the 'fabric:' URI scheme.
   */
  applicationName?: string;
  /**
   * @member {ComposeDeploymentUpgradeState} [upgradeState] The state of the
   * compose deployment upgrade. Possible values include: 'Invalid',
   * 'ProvisioningTarget', 'RollingForwardInProgress', 'RollingForwardPending',
   * 'UnprovisioningCurrent', 'RollingForwardCompleted',
   * 'RollingBackInProgress', 'UnprovisioningTarget', 'RollingBackCompleted',
   * 'Failed'
   */
  upgradeState?: ComposeDeploymentUpgradeState;
  /**
   * @member {string} [upgradeStatusDetails] Additional detailed information
   * about the status of the pending upgrade.
   */
  upgradeStatusDetails?: string;
  /**
   * @member {UpgradeKind} [upgradeKind] The kind of upgrade out of the
   * following possible values. Possible values include: 'Invalid', 'Rolling'.
   * Default value: 'Rolling' .
   */
  upgradeKind?: UpgradeKind;
  /**
   * @member {UpgradeMode} [rollingUpgradeMode] The mode used to monitor health
   * during a rolling upgrade. The values are UnmonitoredAuto,
   * UnmonitoredManual, and Monitored. Possible values include: 'Invalid',
   * 'UnmonitoredAuto', 'UnmonitoredManual', 'Monitored'. Default value:
   * 'UnmonitoredAuto' .
   */
  rollingUpgradeMode?: UpgradeMode;
  /**
   * @member {boolean} [forceRestart] If true, then processes are forcefully
   * restarted during upgrade even when the code version has not changed (the
   * upgrade only changes configuration or data).
   */
  forceRestart?: boolean;
  /**
   * @member {number} [upgradeReplicaSetCheckTimeoutInSeconds] The maximum
   * amount of time to block processing of an upgrade domain and prevent loss
   * of availability when there are unexpected issues. When this timeout
   * expires, processing of the upgrade domain will proceed regardless of
   * availability loss issues. The timeout is reset at the start of each
   * upgrade domain. Valid values are between 0 and 42949672925 inclusive.
   * (unsigned 32-bit integer).
   */
  upgradeReplicaSetCheckTimeoutInSeconds?: number;
  /**
   * @member {MonitoringPolicyDescription} [monitoringPolicy] Describes the
   * parameters for monitoring an upgrade in Monitored mode.
   */
  monitoringPolicy?: MonitoringPolicyDescription;
  /**
   * @member {ApplicationHealthPolicy} [applicationHealthPolicy] Defines a
   * health policy used to evaluate the health of an application or one of its
   * children entities.
   */
  applicationHealthPolicy?: ApplicationHealthPolicy;
  /**
   * @member {string} [targetApplicationTypeVersion] The target application
   * type version (found in the application manifest) for the application
   * upgrade.
   */
  targetApplicationTypeVersion?: string;
  /**
   * @member {string} [upgradeDuration] The estimated amount of time that the
   * overall upgrade elapsed. It is first interpreted as a string representing
   * an ISO 8601 duration. If that fails, then it is interpreted as a number
   * representing the total number of milliseconds.
   */
  upgradeDuration?: string;
  /**
   * @member {string} [currentUpgradeDomainDuration] The estimated amount of
   * time spent processing current Upgrade Domain. It is first interpreted as a
   * string representing an ISO 8601 duration. If that fails, then it is
   * interpreted as a number representing the total number of milliseconds.
   */
  currentUpgradeDomainDuration?: string;
  /**
   * @member {HealthEvaluationWrapper[]} [applicationUnhealthyEvaluations] List
   * of health evaluations that resulted in the current aggregated health
   * state.
   */
  applicationUnhealthyEvaluations?: HealthEvaluationWrapper[];
  /**
   * @member {CurrentUpgradeDomainProgressInfo} [currentUpgradeDomainProgress]
   * Information about the current in-progress upgrade domain.
   */
  currentUpgradeDomainProgress?: CurrentUpgradeDomainProgressInfo;
  /**
   * @member {string} [startTimestampUtc] The estimated UTC datetime when the
   * upgrade started.
   */
  startTimestampUtc?: string;
  /**
   * @member {string} [failureTimestampUtc] The estimated UTC datetime when the
   * upgrade failed and FailureAction was executed.
   */
  failureTimestampUtc?: string;
  /**
   * @member {FailureReason} [failureReason] The cause of an upgrade failure
   * that resulted in FailureAction being executed. Possible values include:
   * 'None', 'Interrupted', 'HealthCheck', 'UpgradeDomainTimeout',
   * 'OverallUpgradeTimeout'
   */
  failureReason?: FailureReason;
  /**
   * @member {FailureUpgradeDomainProgressInfo}
   * [upgradeDomainProgressAtFailure] Information about the upgrade domain
   * progress at the time of upgrade failure.
   */
  upgradeDomainProgressAtFailure?: FailureUpgradeDomainProgressInfo;
  /**
   * @member {string} [applicationUpgradeStatusDetails] Additional details of
   * application upgrade including failure message.
   */
  applicationUpgradeStatusDetails?: string;
}

/**
 * @interface
 * An interface representing PagedComposeDeploymentStatusInfoList.
 * The list of compose deployments in the cluster. The list is paged when all
 * of the results cannot fit in a single message. The next set of results can
 * be obtained by executing the same query with the continuation token provided
 * in this list.
 *
 */
export interface PagedComposeDeploymentStatusInfoList {
  /**
   * @member {string} [continuationToken] The continuation token parameter is
   * used to obtain next set of results. The continuation token is included in
   * the response of the API when the results from the system do not fit in a
   * single response. When this value is passed to the next API call, the API
   * returns next set of results. If there are no further results, then the
   * continuation token is not included in the response.
   */
  continuationToken?: string;
  /**
   * @member {ComposeDeploymentStatusInfo[]} [items] List of compose deployment
   * status information.
   */
  items?: ComposeDeploymentStatusInfo[];
}

/**
 * @interface
 * An interface representing CreateComposeDeploymentDescription.
 * Defines description for creating a Service Fabric compose deployment.
 *
 */
export interface CreateComposeDeploymentDescription {
  /**
   * @member {string} deploymentName The name of the deployment.
   */
  deploymentName: string;
  /**
   * @member {string} composeFileContent The content of the compose file that
   * describes the deployment to create.
   */
  composeFileContent: string;
  /**
   * @member {RegistryCredential} [registryCredential] Credential information
   * to connect to container registry.
   */
  registryCredential?: RegistryCredential;
}

/**
 * @interface
 * An interface representing DeployedServicePackageInfo.
 * Information about service package deployed on a Service Fabric node.
 *
 */
export interface DeployedServicePackageInfo {
  /**
   * @member {string} [name] The name of the service package as specified in
   * the service manifest.
   */
  name?: string;
  /**
   * @member {string} [version] The version of the service package specified in
   * service manifest.
   */
  version?: string;
  /**
   * @member {DeploymentStatus} [status] Specifies the status of a deployed
   * application or service package on a Service Fabric node. Possible values
   * include: 'Invalid', 'Downloading', 'Activating', 'Active', 'Upgrading',
   * 'Deactivating'
   */
  status?: DeploymentStatus;
  /**
   * @member {string} [servicePackageActivationId] The ActivationId of a
   * deployed service package. If ServicePackageActivationMode specified at the
   * time of creating the service
   * is 'SharedProcess' (or if it is not specified, in which case it defaults
   * to 'SharedProcess'), then value of ServicePackageActivationId
   * is always an empty string.
   */
  servicePackageActivationId?: string;
}

/**
 * @interface
 * An interface representing ServiceCorrelationDescription.
 * Creates a particular correlation between services.
 *
 */
export interface ServiceCorrelationDescription {
  /**
   * @member {ServiceCorrelationScheme} scheme The ServiceCorrelationScheme
   * which describes the relationship between this service and the service
   * specified via ServiceName. Possible values include: 'Invalid', 'Affinity',
   * 'AlignedAffinity', 'NonAlignedAffinity'
   */
  scheme: ServiceCorrelationScheme;
  /**
   * @member {string} serviceName The name of the service that the correlation
   * relationship is established with.
   */
  serviceName: string;
}

/**
 * Contains the possible cases for PartitionSchemeDescription.
 */
export type PartitionSchemeDescriptionUnion = PartitionSchemeDescription | NamedPartitionSchemeDescription | SingletonPartitionSchemeDescription | UniformInt64RangePartitionSchemeDescription;

/**
 * @interface
 * An interface representing PartitionSchemeDescription.
 * Describes how the service is partitioned.
 *
 */
export interface PartitionSchemeDescription {
  /**
   * @member {string} partitionScheme Polymorphic Discriminator
   */
  partitionScheme: "PartitionSchemeDescription";
}

/**
 * @interface
 * An interface representing NamedPartitionSchemeDescription.
 * Describes the named partition scheme of the service.
 *
 */
export interface NamedPartitionSchemeDescription {
  /**
   * @member {string} partitionScheme Polymorphic Discriminator
   */
  partitionScheme: "Named";
  /**
   * @member {number} count The number of partitions.
   */
  count: number;
  /**
   * @member {string[]} names Array of size specified by the ‘Count’ parameter,
   * for the names of the partitions.
   */
  names: string[];
}

/**
 * @interface
 * An interface representing SingletonPartitionSchemeDescription.
 * Describes the partition scheme of a singleton-partitioned, or
 * non-partitioned service.
 *
 */
export interface SingletonPartitionSchemeDescription {
  /**
   * @member {string} partitionScheme Polymorphic Discriminator
   */
  partitionScheme: "Singleton";
}

/**
 * @interface
 * An interface representing UniformInt64RangePartitionSchemeDescription.
 * Describes a partitioning scheme where an integer range is allocated evenly
 * across a number of partitions.
 *
 */
export interface UniformInt64RangePartitionSchemeDescription {
  /**
   * @member {string} partitionScheme Polymorphic Discriminator
   */
  partitionScheme: "UniformInt64Range";
  /**
   * @member {number} count The number of partitions.
   */
  count: number;
  /**
   * @member {string} lowKey String indicating the lower bound of the partition
   * key range that
   * should be split between the partitions.
   */
  lowKey: string;
  /**
   * @member {string} highKey String indicating the upper bound of the
   * partition key range that
   * should be split between the partitions.
   */
  highKey: string;
}

/**
 * Contains the possible cases for ScalingTriggerDescription.
 */
export type ScalingTriggerDescriptionUnion = ScalingTriggerDescription | AveragePartitionLoadScalingTrigger | AverageServiceLoadScalingTrigger;

/**
 * @interface
 * An interface representing ScalingTriggerDescription.
 * Describes the trigger for performing a scaling operation.
 *
 */
export interface ScalingTriggerDescription {
  /**
   * @member {string} kind Polymorphic Discriminator
   */
  kind: "ScalingTriggerDescription";
}

/**
 * Contains the possible cases for ScalingMechanismDescription.
 */
export type ScalingMechanismDescriptionUnion = ScalingMechanismDescription | PartitionInstanceCountScaleMechanism | AddRemoveIncrementalNamedPartitionScalingMechanism;

/**
 * @interface
 * An interface representing ScalingMechanismDescription.
 * Describes the mechanism for performing a scaling operation.
 *
 */
export interface ScalingMechanismDescription {
  /**
   * @member {string} kind Polymorphic Discriminator
   */
  kind: "ScalingMechanismDescription";
}

/**
 * @interface
 * An interface representing ScalingPolicyDescription.
 * Describes how the scaling should be performed
 *
 */
export interface ScalingPolicyDescription {
  /**
   * @member {ScalingTriggerDescriptionUnion} scalingTrigger Specifies the
   * trigger associated with this scaling policy
   */
  scalingTrigger: ScalingTriggerDescriptionUnion;
  /**
   * @member {ScalingMechanismDescriptionUnion} scalingMechanism Specifies the
   * mechanism associated with this scaling policy
   */
  scalingMechanism: ScalingMechanismDescriptionUnion;
}

/**
 * Contains the possible cases for ServiceDescription.
 */
export type ServiceDescriptionUnion = ServiceDescription | StatefulServiceDescription | StatelessServiceDescription;

/**
 * @interface
 * An interface representing ServiceDescription.
 * A ServiceDescription contains all of the information necessary to create a
 * service.
 *
 */
export interface ServiceDescription {
  /**
   * @member {string} serviceKind Polymorphic Discriminator
   */
  serviceKind: "ServiceDescription";
  /**
   * @member {string} [applicationName] The name of the application, including
   * the 'fabric:' URI scheme.
   */
  applicationName?: string;
  /**
   * @member {string} serviceName The full name of the service with 'fabric:'
   * URI scheme.
   */
  serviceName: string;
  /**
   * @member {string} serviceTypeName Name of the service type as specified in
   * the service manifest.
   */
  serviceTypeName: string;
  /**
   * @member {number[]} [initializationData] The initialization data as an
   * array of bytes. Initialization data is passed to service instances or
   * replicas when they are created.
   */
  initializationData?: number[];
  /**
   * @member {PartitionSchemeDescriptionUnion} partitionDescription The
   * partition description as an object.
   */
  partitionDescription: PartitionSchemeDescriptionUnion;
  /**
   * @member {string} [placementConstraints] The placement constraints as a
   * string. Placement constraints are boolean expressions on node properties
   * and allow for restricting a service to particular nodes based on the
   * service requirements. For example, to place a service on nodes where
   * NodeType is blue specify the following: "NodeColor == blue)".
   */
  placementConstraints?: string;
  /**
   * @member {ServiceCorrelationDescription[]} [correlationScheme] The
   * correlation scheme.
   */
  correlationScheme?: ServiceCorrelationDescription[];
  /**
   * @member {ServiceLoadMetricDescription[]} [serviceLoadMetrics] The service
   * load metrics.
   */
  serviceLoadMetrics?: ServiceLoadMetricDescription[];
  /**
   * @member {ServicePlacementPolicyDescriptionUnion[]}
   * [servicePlacementPolicies] The service placement policies.
   */
  servicePlacementPolicies?: ServicePlacementPolicyDescriptionUnion[];
  /**
   * @member {MoveCost} [defaultMoveCost] The move cost for the service.
   * Possible values include: 'Zero', 'Low', 'Medium', 'High'
   */
  defaultMoveCost?: MoveCost;
  /**
   * @member {boolean} [isDefaultMoveCostSpecified] Indicates if the
   * DefaultMoveCost property is specified.
   */
  isDefaultMoveCostSpecified?: boolean;
  /**
   * @member {ServicePackageActivationMode} [servicePackageActivationMode] The
   * activation mode of service package to be used for a service. Possible
   * values include: 'SharedProcess', 'ExclusiveProcess'
   */
  servicePackageActivationMode?: ServicePackageActivationMode;
  /**
   * @member {string} [serviceDnsName] The DNS name of the service. It requires
   * the DNS system service to be enabled in Service Fabric cluster.
   */
  serviceDnsName?: string;
  /**
   * @member {ScalingPolicyDescription[]} [scalingPolicies] Scaling policies
   * for this service.
   */
  scalingPolicies?: ScalingPolicyDescription[];
}

/**
 * @interface
 * An interface representing StatefulServiceDescription.
 * Describes a stateful service.
 *
 */
export interface StatefulServiceDescription {
  /**
   * @member {string} serviceKind Polymorphic Discriminator
   */
  serviceKind: "Stateful";
  /**
   * @member {string} [applicationName] The name of the application, including
   * the 'fabric:' URI scheme.
   */
  applicationName?: string;
  /**
   * @member {string} serviceName The full name of the service with 'fabric:'
   * URI scheme.
   */
  serviceName: string;
  /**
   * @member {string} serviceTypeName Name of the service type as specified in
   * the service manifest.
   */
  serviceTypeName: string;
  /**
   * @member {number[]} [initializationData] The initialization data as an
   * array of bytes. Initialization data is passed to service instances or
   * replicas when they are created.
   */
  initializationData?: number[];
  /**
   * @member {PartitionSchemeDescriptionUnion} partitionDescription The
   * partition description as an object.
   */
  partitionDescription: PartitionSchemeDescriptionUnion;
  /**
   * @member {string} [placementConstraints] The placement constraints as a
   * string. Placement constraints are boolean expressions on node properties
   * and allow for restricting a service to particular nodes based on the
   * service requirements. For example, to place a service on nodes where
   * NodeType is blue specify the following: "NodeColor == blue)".
   */
  placementConstraints?: string;
  /**
   * @member {ServiceCorrelationDescription[]} [correlationScheme] The
   * correlation scheme.
   */
  correlationScheme?: ServiceCorrelationDescription[];
  /**
   * @member {ServiceLoadMetricDescription[]} [serviceLoadMetrics] The service
   * load metrics.
   */
  serviceLoadMetrics?: ServiceLoadMetricDescription[];
  /**
   * @member {ServicePlacementPolicyDescriptionUnion[]}
   * [servicePlacementPolicies] The service placement policies.
   */
  servicePlacementPolicies?: ServicePlacementPolicyDescriptionUnion[];
  /**
   * @member {MoveCost} [defaultMoveCost] The move cost for the service.
   * Possible values include: 'Zero', 'Low', 'Medium', 'High'
   */
  defaultMoveCost?: MoveCost;
  /**
   * @member {boolean} [isDefaultMoveCostSpecified] Indicates if the
   * DefaultMoveCost property is specified.
   */
  isDefaultMoveCostSpecified?: boolean;
  /**
   * @member {ServicePackageActivationMode} [servicePackageActivationMode] The
   * activation mode of service package to be used for a service. Possible
   * values include: 'SharedProcess', 'ExclusiveProcess'
   */
  servicePackageActivationMode?: ServicePackageActivationMode;
  /**
   * @member {string} [serviceDnsName] The DNS name of the service. It requires
   * the DNS system service to be enabled in Service Fabric cluster.
   */
  serviceDnsName?: string;
  /**
   * @member {ScalingPolicyDescription[]} [scalingPolicies] Scaling policies
   * for this service.
   */
  scalingPolicies?: ScalingPolicyDescription[];
  /**
   * @member {number} targetReplicaSetSize The target replica set size as a
   * number.
   */
  targetReplicaSetSize: number;
  /**
   * @member {number} minReplicaSetSize The minimum replica set size as a
   * number.
   */
  minReplicaSetSize: number;
  /**
   * @member {boolean} hasPersistedState A flag indicating whether this is a
   * persistent service which stores states on the local disk. If it is then
   * the value of this property is true, if not it is false.
   */
  hasPersistedState: boolean;
  /**
   * @member {number} [flags] Flags indicating whether other properties are
   * set. Each of the associated properties corresponds to a flag, specified
   * below, which, if set, indicate that the property is specified.
   * This property can be a combination of those flags obtained using bitwise
   * 'OR' operator.
   * For example, if the provided value is 6 then the flags for
   * QuorumLossWaitDuration (2) and StandByReplicaKeepDuration(4) are set.
   *
   * - None - Does not indicate any other properties are set. The value is
   * zero.
   * - ReplicaRestartWaitDuration - Indicates the ReplicaRestartWaitDuration
   * property is set. The value is 1.
   * - QuorumLossWaitDuration - Indicates the QuorumLossWaitDuration property
   * is set. The value is 2.
   * - StandByReplicaKeepDuration - Indicates the StandByReplicaKeepDuration
   * property is set. The value is 4.
   */
  flags?: number;
  /**
   * @member {number} [replicaRestartWaitDurationSeconds] The duration, in
   * seconds, between when a replica goes down and when a new replica is
   * created.
   */
  replicaRestartWaitDurationSeconds?: number;
  /**
   * @member {number} [quorumLossWaitDurationSeconds] The maximum duration, in
   * seconds, for which a partition is allowed to be in a state of quorum loss.
   */
  quorumLossWaitDurationSeconds?: number;
  /**
   * @member {number} [standByReplicaKeepDurationSeconds] The definition on how
   * long StandBy replicas should be maintained before being removed.
   */
  standByReplicaKeepDurationSeconds?: number;
}

/**
 * @interface
 * An interface representing StatelessServiceDescription.
 * Describes a stateless service.
 *
 */
export interface StatelessServiceDescription {
  /**
   * @member {string} serviceKind Polymorphic Discriminator
   */
  serviceKind: "Stateless";
  /**
   * @member {string} [applicationName] The name of the application, including
   * the 'fabric:' URI scheme.
   */
  applicationName?: string;
  /**
   * @member {string} serviceName The full name of the service with 'fabric:'
   * URI scheme.
   */
  serviceName: string;
  /**
   * @member {string} serviceTypeName Name of the service type as specified in
   * the service manifest.
   */
  serviceTypeName: string;
  /**
   * @member {number[]} [initializationData] The initialization data as an
   * array of bytes. Initialization data is passed to service instances or
   * replicas when they are created.
   */
  initializationData?: number[];
  /**
   * @member {PartitionSchemeDescriptionUnion} partitionDescription The
   * partition description as an object.
   */
  partitionDescription: PartitionSchemeDescriptionUnion;
  /**
   * @member {string} [placementConstraints] The placement constraints as a
   * string. Placement constraints are boolean expressions on node properties
   * and allow for restricting a service to particular nodes based on the
   * service requirements. For example, to place a service on nodes where
   * NodeType is blue specify the following: "NodeColor == blue)".
   */
  placementConstraints?: string;
  /**
   * @member {ServiceCorrelationDescription[]} [correlationScheme] The
   * correlation scheme.
   */
  correlationScheme?: ServiceCorrelationDescription[];
  /**
   * @member {ServiceLoadMetricDescription[]} [serviceLoadMetrics] The service
   * load metrics.
   */
  serviceLoadMetrics?: ServiceLoadMetricDescription[];
  /**
   * @member {ServicePlacementPolicyDescriptionUnion[]}
   * [servicePlacementPolicies] The service placement policies.
   */
  servicePlacementPolicies?: ServicePlacementPolicyDescriptionUnion[];
  /**
   * @member {MoveCost} [defaultMoveCost] The move cost for the service.
   * Possible values include: 'Zero', 'Low', 'Medium', 'High'
   */
  defaultMoveCost?: MoveCost;
  /**
   * @member {boolean} [isDefaultMoveCostSpecified] Indicates if the
   * DefaultMoveCost property is specified.
   */
  isDefaultMoveCostSpecified?: boolean;
  /**
   * @member {ServicePackageActivationMode} [servicePackageActivationMode] The
   * activation mode of service package to be used for a service. Possible
   * values include: 'SharedProcess', 'ExclusiveProcess'
   */
  servicePackageActivationMode?: ServicePackageActivationMode;
  /**
   * @member {string} [serviceDnsName] The DNS name of the service. It requires
   * the DNS system service to be enabled in Service Fabric cluster.
   */
  serviceDnsName?: string;
  /**
   * @member {ScalingPolicyDescription[]} [scalingPolicies] Scaling policies
   * for this service.
   */
  scalingPolicies?: ScalingPolicyDescription[];
  /**
   * @member {number} instanceCount The instance count.
   */
  instanceCount: number;
}

/**
 * @interface
 * An interface representing ReplicatorQueueStatus.
 * Provides various statistics of the queue used in the service fabric
 * replicator.
 * Contains information about the service fabric replicator like the
 * replication/copy queue utilization, last acknowledgement received timestamp,
 * etc.
 * Depending on the role of the replicator, the properties in this type imply
 * different meanings.
 *
 */
export interface ReplicatorQueueStatus {
  /**
   * @member {number} [queueUtilizationPercentage] Represents the utilization
   * of the queue. A value of 0 indicates that the queue is empty and a value
   * of 100 indicates the queue is full.
   */
  queueUtilizationPercentage?: number;
  /**
   * @member {string} [queueMemorySize] Represents the virtual memory consumed
   * by the queue in bytes.
   */
  queueMemorySize?: string;
  /**
   * @member {string} [firstSequenceNumber] On a primary replicator, this is
   * semantically the sequence number of the operation for which all the
   * secondary replicas have sent an acknowledgement.
   * On a secondary replicator, this is the smallest sequence number of the
   * operation that is present in the queue.
   */
  firstSequenceNumber?: string;
  /**
   * @member {string} [completedSequenceNumber] On a primary replicator, this
   * is semantically the highest sequence number of the operation for which all
   * the secondary replicas have sent an acknowledgement.
   * On a secondary replicator, this is semantically the highest sequence
   * number that has been applied to the persistent state.
   */
  completedSequenceNumber?: string;
  /**
   * @member {string} [committedSequenceNumber] On a primary replicator, this
   * is semantically the highest sequence number of the operation for which a
   * write quorum of the secondary replicas have sent an acknowledgement.
   * On a secondary replicator, this is semantically the highest sequence
   * number of the in-order operation received from the primary.
   */
  committedSequenceNumber?: string;
  /**
   * @member {string} [lastSequenceNumber] Represents the latest sequence
   * number of the operation that is available in the queue.
   */
  lastSequenceNumber?: string;
}

/**
 * Contains the possible cases for ReplicatorStatus.
 */
export type ReplicatorStatusUnion = ReplicatorStatus | PrimaryReplicatorStatus | SecondaryReplicatorStatusUnion;

/**
 * @interface
 * An interface representing ReplicatorStatus.
 * Represents a base class for primary or secondary replicator status.
 * Contains information about the service fabric replicator like the
 * replication/copy queue utilization, last acknowledgement received timestamp,
 * etc.
 *
 */
export interface ReplicatorStatus {
  /**
   * @member {string} kind Polymorphic Discriminator
   */
  kind: "ReplicatorStatus";
}

/**
 * @interface
 * An interface representing RemoteReplicatorAcknowledgementDetail.
 * Provides various statistics of the acknowledgements that are being received
 * from the remote replicator.
 *
 */
export interface RemoteReplicatorAcknowledgementDetail {
  /**
   * @member {string} [averageReceiveDuration] Represents the average duration
   * it takes for the remote replicator to receive an operation.
   */
  averageReceiveDuration?: string;
  /**
   * @member {string} [averageApplyDuration] Represents the average duration it
   * takes for the remote replicator to apply an operation. This usually
   * entails writing the operation to disk.
   */
  averageApplyDuration?: string;
  /**
   * @member {string} [notReceivedCount] Represents the number of operations
   * not yet received by a remote replicator.
   */
  notReceivedCount?: string;
  /**
   * @member {string} [receivedAndNotAppliedCount] Represents the number of
   * operations received and not yet applied by a remote replicator.
   */
  receivedAndNotAppliedCount?: string;
}

/**
 * @interface
 * An interface representing RemoteReplicatorAcknowledgementStatus.
 * Provides details about the remote replicators from the primary replicator's
 * point of view.
 *
 */
export interface RemoteReplicatorAcknowledgementStatus {
  /**
   * @member {RemoteReplicatorAcknowledgementDetail}
   * [replicationStreamAcknowledgementDetail] Details about the
   * acknowledgements for operations that are part of the replication stream
   * data.
   */
  replicationStreamAcknowledgementDetail?: RemoteReplicatorAcknowledgementDetail;
  /**
   * @member {RemoteReplicatorAcknowledgementDetail}
   * [copyStreamAcknowledgementDetail] Details about the acknowledgements for
   * operations that are part of the copy stream data.
   */
  copyStreamAcknowledgementDetail?: RemoteReplicatorAcknowledgementDetail;
}

/**
 * @interface
 * An interface representing RemoteReplicatorStatus.
 * Represents the state of the secondary replicator from the primary
 * replicator’s point of view.
 *
 */
export interface RemoteReplicatorStatus {
  /**
   * @member {string} [replicaId] Represents the replica ID of the remote
   * secondary replicator.
   */
  replicaId?: string;
  /**
   * @member {Date} [lastAcknowledgementProcessedTimeUtc] The last timestamp
   * (in UTC) when an acknowledgement from the secondary replicator was
   * processed on the primary.
   * UTC 0 represents an invalid value, indicating that no acknowledgement
   * messages were ever processed.
   */
  lastAcknowledgementProcessedTimeUtc?: Date;
  /**
   * @member {string} [lastReceivedReplicationSequenceNumber] The highest
   * replication operation sequence number that the secondary has received from
   * the primary.
   */
  lastReceivedReplicationSequenceNumber?: string;
  /**
   * @member {string} [lastAppliedReplicationSequenceNumber] The highest
   * replication operation sequence number that the secondary has applied to
   * its state.
   */
  lastAppliedReplicationSequenceNumber?: string;
  /**
   * @member {boolean} [isInBuild] A value that indicates whether the secondary
   * replica is in the process of being built.
   */
  isInBuild?: boolean;
  /**
   * @member {string} [lastReceivedCopySequenceNumber] The highest copy
   * operation sequence number that the secondary has received from the
   * primary.
   * A value of -1 implies that the secondary has received all copy operations.
   */
  lastReceivedCopySequenceNumber?: string;
  /**
   * @member {string} [lastAppliedCopySequenceNumber] The highest copy
   * operation sequence number that the secondary has applied to its state.
   * A value of -1 implies that the secondary has applied all copy operations
   * and the copy process is complete.
   */
  lastAppliedCopySequenceNumber?: string;
  /**
   * @member {RemoteReplicatorAcknowledgementStatus}
   * [remoteReplicatorAcknowledgementStatus] Represents the acknowledgment
   * status for the remote secondary replicator.
   */
  remoteReplicatorAcknowledgementStatus?: RemoteReplicatorAcknowledgementStatus;
}

/**
 * @interface
 * An interface representing PrimaryReplicatorStatus.
 * Provides statistics about the Service Fabric Replicator, when it is
 * functioning in a Primary role.
 *
 */
export interface PrimaryReplicatorStatus {
  /**
   * @member {string} kind Polymorphic Discriminator
   */
  kind: "Primary";
  /**
   * @member {ReplicatorQueueStatus} [replicationQueueStatus] Details about the
   * replication queue on the primary replicator.
   */
  replicationQueueStatus?: ReplicatorQueueStatus;
  /**
   * @member {RemoteReplicatorStatus[]} [remoteReplicators] The status of all
   * the active and idle secondary replicators that the primary is aware of.
   */
  remoteReplicators?: RemoteReplicatorStatus[];
}

/**
 * Contains the possible cases for SecondaryReplicatorStatus.
 */
export type SecondaryReplicatorStatusUnion = SecondaryReplicatorStatus | SecondaryActiveReplicatorStatus | SecondaryIdleReplicatorStatus;

/**
 * @interface
 * An interface representing SecondaryReplicatorStatus.
 * Provides statistics about the Service Fabric Replicator, when it is
 * functioning in a ActiveSecondary role.
 *
 */
export interface SecondaryReplicatorStatus {
  /**
   * @member {string} kind Polymorphic Discriminator
   */
  kind: "SecondaryReplicatorStatus";
  /**
   * @member {ReplicatorQueueStatus} [replicationQueueStatus] Details about the
   * replication queue on the secondary replicator.
   */
  replicationQueueStatus?: ReplicatorQueueStatus;
  /**
   * @member {Date} [lastReplicationOperationReceivedTimeUtc] The last
   * time-stamp (UTC) at which a replication operation was received from the
   * primary.
   * UTC 0 represents an invalid value, indicating that a replication operation
   * message was never received.
   */
  lastReplicationOperationReceivedTimeUtc?: Date;
  /**
   * @member {boolean} [isInBuild] Value that indicates whether the replica is
   * currently being built.
   */
  isInBuild?: boolean;
  /**
   * @member {ReplicatorQueueStatus} [copyQueueStatus] Details about the copy
   * queue on the secondary replicator.
   */
  copyQueueStatus?: ReplicatorQueueStatus;
  /**
   * @member {Date} [lastCopyOperationReceivedTimeUtc] The last time-stamp
   * (UTC) at which a copy operation was received from the primary.
   * UTC 0 represents an invalid value, indicating that a copy operation
   * message was never received.
   */
  lastCopyOperationReceivedTimeUtc?: Date;
  /**
   * @member {Date} [lastAcknowledgementSentTimeUtc] The last time-stamp (UTC)
   * at which an acknowledgment was sent to the primary replicator.
   * UTC 0 represents an invalid value, indicating that an acknowledgment
   * message was never sent.
   */
  lastAcknowledgementSentTimeUtc?: Date;
}

/**
 * @interface
 * An interface representing SecondaryActiveReplicatorStatus.
 * Status of the secondary replicator when it is in active mode and is part of
 * the replica set.
 *
 */
export interface SecondaryActiveReplicatorStatus {
  /**
   * @member {string} kind Polymorphic Discriminator
   */
  kind: "ActiveSecondary";
  /**
   * @member {ReplicatorQueueStatus} [replicationQueueStatus] Details about the
   * replication queue on the secondary replicator.
   */
  replicationQueueStatus?: ReplicatorQueueStatus;
  /**
   * @member {Date} [lastReplicationOperationReceivedTimeUtc] The last
   * time-stamp (UTC) at which a replication operation was received from the
   * primary.
   * UTC 0 represents an invalid value, indicating that a replication operation
   * message was never received.
   */
  lastReplicationOperationReceivedTimeUtc?: Date;
  /**
   * @member {boolean} [isInBuild] Value that indicates whether the replica is
   * currently being built.
   */
  isInBuild?: boolean;
  /**
   * @member {ReplicatorQueueStatus} [copyQueueStatus] Details about the copy
   * queue on the secondary replicator.
   */
  copyQueueStatus?: ReplicatorQueueStatus;
  /**
   * @member {Date} [lastCopyOperationReceivedTimeUtc] The last time-stamp
   * (UTC) at which a copy operation was received from the primary.
   * UTC 0 represents an invalid value, indicating that a copy operation
   * message was never received.
   */
  lastCopyOperationReceivedTimeUtc?: Date;
  /**
   * @member {Date} [lastAcknowledgementSentTimeUtc] The last time-stamp (UTC)
   * at which an acknowledgment was sent to the primary replicator.
   * UTC 0 represents an invalid value, indicating that an acknowledgment
   * message was never sent.
   */
  lastAcknowledgementSentTimeUtc?: Date;
}

/**
 * @interface
 * An interface representing SecondaryIdleReplicatorStatus.
 * Status of the secondary replicator when it is in idle mode and is being
 * built by the primary.
 *
 */
export interface SecondaryIdleReplicatorStatus {
  /**
   * @member {string} kind Polymorphic Discriminator
   */
  kind: "IdleSecondary";
  /**
   * @member {ReplicatorQueueStatus} [replicationQueueStatus] Details about the
   * replication queue on the secondary replicator.
   */
  replicationQueueStatus?: ReplicatorQueueStatus;
  /**
   * @member {Date} [lastReplicationOperationReceivedTimeUtc] The last
   * time-stamp (UTC) at which a replication operation was received from the
   * primary.
   * UTC 0 represents an invalid value, indicating that a replication operation
   * message was never received.
   */
  lastReplicationOperationReceivedTimeUtc?: Date;
  /**
   * @member {boolean} [isInBuild] Value that indicates whether the replica is
   * currently being built.
   */
  isInBuild?: boolean;
  /**
   * @member {ReplicatorQueueStatus} [copyQueueStatus] Details about the copy
   * queue on the secondary replicator.
   */
  copyQueueStatus?: ReplicatorQueueStatus;
  /**
   * @member {Date} [lastCopyOperationReceivedTimeUtc] The last time-stamp
   * (UTC) at which a copy operation was received from the primary.
   * UTC 0 represents an invalid value, indicating that a copy operation
   * message was never received.
   */
  lastCopyOperationReceivedTimeUtc?: Date;
  /**
   * @member {Date} [lastAcknowledgementSentTimeUtc] The last time-stamp (UTC)
   * at which an acknowledgment was sent to the primary replicator.
   * UTC 0 represents an invalid value, indicating that an acknowledgment
   * message was never sent.
   */
  lastAcknowledgementSentTimeUtc?: Date;
}

/**
 * @interface
 * An interface representing LoadMetricReportInfo.
 * Information about load reported by replica.
 *
 */
export interface LoadMetricReportInfo {
  /**
   * @member {string} [name] The name of the metric.
   */
  name?: string;
  /**
   * @member {number} [value] The value of the load for the metric..
   */
  value?: number;
  /**
   * @member {Date} [lastReportedUtc] The UTC time when the load is reported.
   */
  lastReportedUtc?: Date;
}

/**
 * Contains the possible cases for DeployedServiceReplicaDetailInfo.
 */
export type DeployedServiceReplicaDetailInfoUnion = DeployedServiceReplicaDetailInfo | DeployedStatefulServiceReplicaDetailInfo | DeployedStatelessServiceInstanceDetailInfo;

/**
 * @interface
 * An interface representing DeployedServiceReplicaDetailInfo.
 * Information about a Service Fabric service replica deployed on a node.
 *
 */
export interface DeployedServiceReplicaDetailInfo {
  /**
   * @member {string} serviceKind Polymorphic Discriminator
   */
  serviceKind: "DeployedServiceReplicaDetailInfo";
  /**
   * @member {string} [serviceName] Full hierarchical name of the service in
   * URI format starting with `fabric:`.
   */
  serviceName?: string;
  /**
   * @member {string} [partitionId] An internal ID used by Service Fabric to
   * uniquely identify a partition. This is a randomly generated GUID when the
   * service was created. The partition ID is unique and does not change for
   * the lifetime of the service. If the same service was deleted and recreated
   * the IDs of its partitions would be different.
   */
  partitionId?: string;
  /**
   * @member {ServiceOperationName} [currentServiceOperation] Specifies the
   * current active life-cycle operation on a stateful service replica or
   * stateless service instance. Possible values include: 'Unknown', 'None',
   * 'Open', 'ChangeRole', 'Close', 'Abort'
   */
  currentServiceOperation?: ServiceOperationName;
  /**
   * @member {Date} [currentServiceOperationStartTimeUtc] The start time of the
   * current service operation in UTC format.
   */
  currentServiceOperationStartTimeUtc?: Date;
  /**
   * @member {LoadMetricReportInfo[]} [reportedLoad] List of load reported by
   * replica.
   */
  reportedLoad?: LoadMetricReportInfo[];
}

/**
 * Contains the possible cases for ReplicaStatusBase.
 */
export type ReplicaStatusBaseUnion = ReplicaStatusBase | KeyValueStoreReplicaStatus;

/**
 * @interface
 * An interface representing ReplicaStatusBase.
 * Information about the replica.
 *
 */
export interface ReplicaStatusBase {
  /**
   * @member {string} kind Polymorphic Discriminator
   */
  kind: "ReplicaStatusBase";
}

/**
 * @interface
 * An interface representing KeyValueStoreReplicaStatus.
 * Key value store related information for the replica.
 *
 */
export interface KeyValueStoreReplicaStatus {
  /**
   * @member {string} kind Polymorphic Discriminator
   */
  kind: "KeyValueStore";
  /**
   * @member {string} [databaseRowCountEstimate] Value indicating the estimated
   * number of rows in the underlying database.
   */
  databaseRowCountEstimate?: string;
  /**
   * @member {string} [databaseLogicalSizeEstimate] Value indicating the
   * estimated size of the underlying database.
   */
  databaseLogicalSizeEstimate?: string;
  /**
   * @member {string} [copyNotificationCurrentKeyFilter] Value indicating the
   * latest key-prefix filter applied to enumeration during the callback. Null
   * if there is no pending callback.
   */
  copyNotificationCurrentKeyFilter?: string;
  /**
   * @member {string} [copyNotificationCurrentProgress] Value indicating the
   * latest number of keys enumerated during the callback. 0 if there is no
   * pending callback.
   */
  copyNotificationCurrentProgress?: string;
  /**
   * @member {string} [statusDetails] Value indicating the current status
   * details of the replica.
   */
  statusDetails?: string;
}

/**
 * @interface
 * An interface representing DeployedStatefulServiceReplicaDetailInfo.
 * Information about a stateful replica running in a code package. Note
 * DeployedServiceReplicaQueryResult will contain duplicate data like
 * ServiceKind, ServiceName, PartitionId and replicaId.
 *
 */
export interface DeployedStatefulServiceReplicaDetailInfo {
  /**
   * @member {string} serviceKind Polymorphic Discriminator
   */
  serviceKind: "Stateful";
  /**
   * @member {string} [serviceName] Full hierarchical name of the service in
   * URI format starting with `fabric:`.
   */
  serviceName?: string;
  /**
   * @member {string} [partitionId] An internal ID used by Service Fabric to
   * uniquely identify a partition. This is a randomly generated GUID when the
   * service was created. The partition ID is unique and does not change for
   * the lifetime of the service. If the same service was deleted and recreated
   * the IDs of its partitions would be different.
   */
  partitionId?: string;
  /**
   * @member {ServiceOperationName} [currentServiceOperation] Specifies the
   * current active life-cycle operation on a stateful service replica or
   * stateless service instance. Possible values include: 'Unknown', 'None',
   * 'Open', 'ChangeRole', 'Close', 'Abort'
   */
  currentServiceOperation?: ServiceOperationName;
  /**
   * @member {Date} [currentServiceOperationStartTimeUtc] The start time of the
   * current service operation in UTC format.
   */
  currentServiceOperationStartTimeUtc?: Date;
  /**
   * @member {LoadMetricReportInfo[]} [reportedLoad] List of load reported by
   * replica.
   */
  reportedLoad?: LoadMetricReportInfo[];
  /**
   * @member {string} [replicaId] Id of a stateful service replica. ReplicaId
   * is used by Service Fabric to uniquely identify a replica of a partition.
   * It is unique within a partition and does not change for the lifetime of
   * the replica. If a replica gets dropped and another replica gets created on
   * the same node for the same partition, it will get a different value for
   * the id. Sometimes the id of a stateless service instance is also referred
   * as a replica id.
   */
  replicaId?: string;
  /**
   * @member {ReplicatorOperationName} [currentReplicatorOperation] Specifies
   * the operation currently being executed by the Replicator. Possible values
   * include: 'Invalid', 'None', 'Open', 'ChangeRole', 'UpdateEpoch', 'Close',
   * 'Abort', 'OnDataLoss', 'WaitForCatchup', 'Build'
   */
  currentReplicatorOperation?: ReplicatorOperationName;
  /**
   * @member {PartitionAccessStatus} [readStatus] Specifies the access status
   * of the partition. Possible values include: 'Invalid', 'Granted',
   * 'ReconfigurationPending', 'NotPrimary', 'NoWriteQuorum'
   */
  readStatus?: PartitionAccessStatus;
  /**
   * @member {PartitionAccessStatus} [writeStatus] Specifies the access status
   * of the partition. Possible values include: 'Invalid', 'Granted',
   * 'ReconfigurationPending', 'NotPrimary', 'NoWriteQuorum'
   */
  writeStatus?: PartitionAccessStatus;
  /**
   * @member {ReplicatorStatusUnion} [replicatorStatus] Represents a base class
   * for primary or secondary replicator status.
   * Contains information about the service fabric replicator like the
   * replication/copy queue utilization, last acknowledgement received
   * timestamp, etc.
   */
  replicatorStatus?: ReplicatorStatusUnion;
  /**
   * @member {KeyValueStoreReplicaStatus} [replicaStatus] Key value store
   * related information for the replica.
   */
  replicaStatus?: KeyValueStoreReplicaStatus;
  /**
   * @member {DeployedStatefulServiceReplicaInfo}
   * [deployedServiceReplicaQueryResult] Information about a stateful service
   * replica deployed on a node.
   */
  deployedServiceReplicaQueryResult?: DeployedStatefulServiceReplicaInfo;
}

/**
 * @interface
 * An interface representing DeployedStatelessServiceInstanceDetailInfo.
 * Information about a stateless instance running in a code package. Note that
 * DeployedServiceReplicaQueryResult will contain duplicate data like
 * ServiceKind, ServiceName, PartitionId and InstanceId.
 *
 */
export interface DeployedStatelessServiceInstanceDetailInfo {
  /**
   * @member {string} serviceKind Polymorphic Discriminator
   */
  serviceKind: "Stateless";
  /**
   * @member {string} [serviceName] Full hierarchical name of the service in
   * URI format starting with `fabric:`.
   */
  serviceName?: string;
  /**
   * @member {string} [partitionId] An internal ID used by Service Fabric to
   * uniquely identify a partition. This is a randomly generated GUID when the
   * service was created. The partition ID is unique and does not change for
   * the lifetime of the service. If the same service was deleted and recreated
   * the IDs of its partitions would be different.
   */
  partitionId?: string;
  /**
   * @member {ServiceOperationName} [currentServiceOperation] Specifies the
   * current active life-cycle operation on a stateful service replica or
   * stateless service instance. Possible values include: 'Unknown', 'None',
   * 'Open', 'ChangeRole', 'Close', 'Abort'
   */
  currentServiceOperation?: ServiceOperationName;
  /**
   * @member {Date} [currentServiceOperationStartTimeUtc] The start time of the
   * current service operation in UTC format.
   */
  currentServiceOperationStartTimeUtc?: Date;
  /**
   * @member {LoadMetricReportInfo[]} [reportedLoad] List of load reported by
   * replica.
   */
  reportedLoad?: LoadMetricReportInfo[];
  /**
   * @member {string} [instanceId] Id of a stateless service instance.
   * InstanceId is used by Service Fabric to uniquely identify an instance of a
   * partition of a stateless service. It is unique within a partition and does
   * not change for the lifetime of the instance. If the instance has failed
   * over on the same or different node, it will get a different value for the
   * InstanceId.
   */
  instanceId?: string;
  /**
   * @member {DeployedStatelessServiceInstanceInfo}
   * [deployedServiceReplicaQueryResult] Information about a stateless service
   * instance deployed on a node.
   */
  deployedServiceReplicaQueryResult?: DeployedStatelessServiceInstanceInfo;
}

/**
 * Contains the possible cases for ServiceUpdateDescription.
 */
export type ServiceUpdateDescriptionUnion = ServiceUpdateDescription | StatefulServiceUpdateDescription | StatelessServiceUpdateDescription;

/**
 * @interface
 * An interface representing ServiceUpdateDescription.
 * A ServiceUpdateDescription contains all of the information necessary to
 * update a service.
 *
 */
export interface ServiceUpdateDescription {
  /**
   * @member {string} serviceKind Polymorphic Discriminator
   */
  serviceKind: "ServiceUpdateDescription";
  /**
   * @member {string} [flags] Flags indicating whether other properties are
   * set. Each of the associated properties corresponds to a flag, specified
   * below, which, if set, indicate that the property is specified.
   * This property can be a combination of those flags obtained using bitwise
   * 'OR' operator.
   * For example, if the provided value is 6 then the flags for
   * ReplicaRestartWaitDuration (2) and QuorumLossWaitDuration (4) are set.
   *
   * - None - Does not indicate any other properties are set. The value is
   * zero.
   * - TargetReplicaSetSize/InstanceCount - Indicates whether the
   * TargetReplicaSetSize property (for Stateful services) or the InstanceCount
   * property (for Stateless services) is set. The value is 1.
   * - ReplicaRestartWaitDuration - Indicates the ReplicaRestartWaitDuration
   * property is set. The value is  2.
   * - QuorumLossWaitDuration - Indicates the QuorumLossWaitDuration property
   * is set. The value is 4.
   * - StandByReplicaKeepDuration - Indicates the StandByReplicaKeepDuration
   * property is set. The value is 8.
   * - MinReplicaSetSize - Indicates the MinReplicaSetSize property is set. The
   * value is 16.
   * - PlacementConstraints - Indicates the PlacementConstraints property is
   * set. The value is 32.
   * - PlacementPolicyList - Indicates the ServicePlacementPolicies property is
   * set. The value is 64.
   * - Correlation - Indicates the CorrelationScheme property is set. The value
   * is 128.
   * - Metrics - Indicates the ServiceLoadMetrics property is set. The value is
   * 256.
   * - DefaultMoveCost - Indicates the DefaultMoveCost property is set. The
   * value is 512.
   * - ScalingPolicy - Indicates the ScalingPolicies property is set. The value
   * is 1024.
   */
  flags?: string;
  /**
   * @member {string} [placementConstraints] The placement constraints as a
   * string. Placement constraints are boolean expressions on node properties
   * and allow for restricting a service to particular nodes based on the
   * service requirements. For example, to place a service on nodes where
   * NodeType is blue specify the following: "NodeColor == blue)".
   */
  placementConstraints?: string;
  /**
   * @member {ServiceCorrelationDescription[]} [correlationScheme] The
   * correlation scheme.
   */
  correlationScheme?: ServiceCorrelationDescription[];
  /**
   * @member {ServiceLoadMetricDescription[]} [loadMetrics] The service load
   * metrics.
   */
  loadMetrics?: ServiceLoadMetricDescription[];
  /**
   * @member {ServicePlacementPolicyDescriptionUnion[]}
   * [servicePlacementPolicies] The service placement policies.
   */
  servicePlacementPolicies?: ServicePlacementPolicyDescriptionUnion[];
  /**
   * @member {MoveCost} [defaultMoveCost] The move cost for the service.
   * Possible values include: 'Zero', 'Low', 'Medium', 'High'
   */
  defaultMoveCost?: MoveCost;
  /**
   * @member {ScalingPolicyDescription[]} [scalingPolicies] Scaling policies
   * for this service.
   */
  scalingPolicies?: ScalingPolicyDescription[];
}

/**
 * @interface
 * An interface representing StatefulServiceUpdateDescription.
 * Describes an update for a stateful service.
 *
 */
export interface StatefulServiceUpdateDescription {
  /**
   * @member {string} serviceKind Polymorphic Discriminator
   */
  serviceKind: "Stateful";
  /**
   * @member {string} [flags] Flags indicating whether other properties are
   * set. Each of the associated properties corresponds to a flag, specified
   * below, which, if set, indicate that the property is specified.
   * This property can be a combination of those flags obtained using bitwise
   * 'OR' operator.
   * For example, if the provided value is 6 then the flags for
   * ReplicaRestartWaitDuration (2) and QuorumLossWaitDuration (4) are set.
   *
   * - None - Does not indicate any other properties are set. The value is
   * zero.
   * - TargetReplicaSetSize/InstanceCount - Indicates whether the
   * TargetReplicaSetSize property (for Stateful services) or the InstanceCount
   * property (for Stateless services) is set. The value is 1.
   * - ReplicaRestartWaitDuration - Indicates the ReplicaRestartWaitDuration
   * property is set. The value is  2.
   * - QuorumLossWaitDuration - Indicates the QuorumLossWaitDuration property
   * is set. The value is 4.
   * - StandByReplicaKeepDuration - Indicates the StandByReplicaKeepDuration
   * property is set. The value is 8.
   * - MinReplicaSetSize - Indicates the MinReplicaSetSize property is set. The
   * value is 16.
   * - PlacementConstraints - Indicates the PlacementConstraints property is
   * set. The value is 32.
   * - PlacementPolicyList - Indicates the ServicePlacementPolicies property is
   * set. The value is 64.
   * - Correlation - Indicates the CorrelationScheme property is set. The value
   * is 128.
   * - Metrics - Indicates the ServiceLoadMetrics property is set. The value is
   * 256.
   * - DefaultMoveCost - Indicates the DefaultMoveCost property is set. The
   * value is 512.
   * - ScalingPolicy - Indicates the ScalingPolicies property is set. The value
   * is 1024.
   */
  flags?: string;
  /**
   * @member {string} [placementConstraints] The placement constraints as a
   * string. Placement constraints are boolean expressions on node properties
   * and allow for restricting a service to particular nodes based on the
   * service requirements. For example, to place a service on nodes where
   * NodeType is blue specify the following: "NodeColor == blue)".
   */
  placementConstraints?: string;
  /**
   * @member {ServiceCorrelationDescription[]} [correlationScheme] The
   * correlation scheme.
   */
  correlationScheme?: ServiceCorrelationDescription[];
  /**
   * @member {ServiceLoadMetricDescription[]} [loadMetrics] The service load
   * metrics.
   */
  loadMetrics?: ServiceLoadMetricDescription[];
  /**
   * @member {ServicePlacementPolicyDescriptionUnion[]}
   * [servicePlacementPolicies] The service placement policies.
   */
  servicePlacementPolicies?: ServicePlacementPolicyDescriptionUnion[];
  /**
   * @member {MoveCost} [defaultMoveCost] The move cost for the service.
   * Possible values include: 'Zero', 'Low', 'Medium', 'High'
   */
  defaultMoveCost?: MoveCost;
  /**
   * @member {ScalingPolicyDescription[]} [scalingPolicies] Scaling policies
   * for this service.
   */
  scalingPolicies?: ScalingPolicyDescription[];
  /**
   * @member {number} [targetReplicaSetSize] The target replica set size as a
   * number.
   */
  targetReplicaSetSize?: number;
  /**
   * @member {number} [minReplicaSetSize] The minimum replica set size as a
   * number.
   */
  minReplicaSetSize?: number;
  /**
   * @member {string} [replicaRestartWaitDurationSeconds] The duration, in
   * seconds, between when a replica goes down and when a new replica is
   * created.
   */
  replicaRestartWaitDurationSeconds?: string;
  /**
   * @member {string} [quorumLossWaitDurationSeconds] The maximum duration, in
   * seconds, for which a partition is allowed to be in a state of quorum loss.
   */
  quorumLossWaitDurationSeconds?: string;
  /**
   * @member {string} [standByReplicaKeepDurationSeconds] The definition on how
   * long StandBy replicas should be maintained before being removed.
   */
  standByReplicaKeepDurationSeconds?: string;
}

/**
 * @interface
 * An interface representing StatelessServiceUpdateDescription.
 * Describes an update for a stateless service.
 *
 */
export interface StatelessServiceUpdateDescription {
  /**
   * @member {string} serviceKind Polymorphic Discriminator
   */
  serviceKind: "Stateless";
  /**
   * @member {string} [flags] Flags indicating whether other properties are
   * set. Each of the associated properties corresponds to a flag, specified
   * below, which, if set, indicate that the property is specified.
   * This property can be a combination of those flags obtained using bitwise
   * 'OR' operator.
   * For example, if the provided value is 6 then the flags for
   * ReplicaRestartWaitDuration (2) and QuorumLossWaitDuration (4) are set.
   *
   * - None - Does not indicate any other properties are set. The value is
   * zero.
   * - TargetReplicaSetSize/InstanceCount - Indicates whether the
   * TargetReplicaSetSize property (for Stateful services) or the InstanceCount
   * property (for Stateless services) is set. The value is 1.
   * - ReplicaRestartWaitDuration - Indicates the ReplicaRestartWaitDuration
   * property is set. The value is  2.
   * - QuorumLossWaitDuration - Indicates the QuorumLossWaitDuration property
   * is set. The value is 4.
   * - StandByReplicaKeepDuration - Indicates the StandByReplicaKeepDuration
   * property is set. The value is 8.
   * - MinReplicaSetSize - Indicates the MinReplicaSetSize property is set. The
   * value is 16.
   * - PlacementConstraints - Indicates the PlacementConstraints property is
   * set. The value is 32.
   * - PlacementPolicyList - Indicates the ServicePlacementPolicies property is
   * set. The value is 64.
   * - Correlation - Indicates the CorrelationScheme property is set. The value
   * is 128.
   * - Metrics - Indicates the ServiceLoadMetrics property is set. The value is
   * 256.
   * - DefaultMoveCost - Indicates the DefaultMoveCost property is set. The
   * value is 512.
   * - ScalingPolicy - Indicates the ScalingPolicies property is set. The value
   * is 1024.
   */
  flags?: string;
  /**
   * @member {string} [placementConstraints] The placement constraints as a
   * string. Placement constraints are boolean expressions on node properties
   * and allow for restricting a service to particular nodes based on the
   * service requirements. For example, to place a service on nodes where
   * NodeType is blue specify the following: "NodeColor == blue)".
   */
  placementConstraints?: string;
  /**
   * @member {ServiceCorrelationDescription[]} [correlationScheme] The
   * correlation scheme.
   */
  correlationScheme?: ServiceCorrelationDescription[];
  /**
   * @member {ServiceLoadMetricDescription[]} [loadMetrics] The service load
   * metrics.
   */
  loadMetrics?: ServiceLoadMetricDescription[];
  /**
   * @member {ServicePlacementPolicyDescriptionUnion[]}
   * [servicePlacementPolicies] The service placement policies.
   */
  servicePlacementPolicies?: ServicePlacementPolicyDescriptionUnion[];
  /**
   * @member {MoveCost} [defaultMoveCost] The move cost for the service.
   * Possible values include: 'Zero', 'Low', 'Medium', 'High'
   */
  defaultMoveCost?: MoveCost;
  /**
   * @member {ScalingPolicyDescription[]} [scalingPolicies] Scaling policies
   * for this service.
   */
  scalingPolicies?: ScalingPolicyDescription[];
  /**
   * @member {number} [instanceCount] The instance count.
   */
  instanceCount?: number;
}

/**
 * @interface
 * An interface representing FileVersion.
 * Information about the version of image store file.
 *
 */
export interface FileVersion {
  /**
   * @member {string} [versionNumber] The current image store version number
   * for the file is used in image store for checking whether it need to be
   * updated.
   */
  versionNumber?: string;
  /**
   * @member {string} [epochDataLossNumber] The epoch data loss number of image
   * store replica when this file entry was updated or created.
   */
  epochDataLossNumber?: string;
  /**
   * @member {string} [epochConfigurationNumber] The epoch configuration
   * version number of the image store replica when this file entry was created
   * or updated.
   */
  epochConfigurationNumber?: string;
}

/**
 * @interface
 * An interface representing FileInfo.
 * Information about a image store file.
 *
 */
export interface FileInfo {
  /**
   * @member {string} [fileSize] The size of file in bytes.
   */
  fileSize?: string;
  /**
   * @member {FileVersion} [fileVersion] Information about the version of image
   * store file.
   */
  fileVersion?: FileVersion;
  /**
   * @member {Date} [modifiedDate] The date and time when the image store file
   * was last modified.
   */
  modifiedDate?: Date;
  /**
   * @member {string} [storeRelativePath] The file path relative to the image
   * store root path.
   */
  storeRelativePath?: string;
}

/**
 * @interface
 * An interface representing FolderInfo.
 * Information about a image store folder. It includes how many files this
 * folder contains and its image store relative path.
 *
 */
export interface FolderInfo {
  /**
   * @member {string} [storeRelativePath] The remote location within image
   * store. This path is relative to the image store root.
   */
  storeRelativePath?: string;
  /**
   * @member {string} [fileCount] The number of files from within the image
   * store folder.
   */
  fileCount?: string;
}

/**
 * @interface
 * An interface representing ImageStoreContent.
 * Information about the image store content.
 *
 */
export interface ImageStoreContent {
  /**
   * @member {FileInfo[]} [storeFiles] The list of image store file info
   * objects represents files found under the given image store relative path.
   */
  storeFiles?: FileInfo[];
  /**
   * @member {FolderInfo[]} [storeFolders] The list of image store folder info
   * objects represents subfolders found under the given image store relative
   * path.
   */
  storeFolders?: FolderInfo[];
}

/**
 * @interface
 * An interface representing ImageStoreCopyDescription.
 * Information about how to copy image store content from one image store
 * relative path to another image store relative path.
 *
 */
export interface ImageStoreCopyDescription {
  /**
   * @member {string} remoteSource The relative path of source image store
   * content to be copied from.
   */
  remoteSource: string;
  /**
   * @member {string} remoteDestination The relative path of destination image
   * store content to be copied to.
   */
  remoteDestination: string;
  /**
   * @member {string[]} [skipFiles] The list of the file names to be skipped
   * for copying.
   */
  skipFiles?: string[];
  /**
   * @member {boolean} [checkMarkFile] Indicates whether to check mark file
   * during copying. The property is true if checking mark file is required,
   * false otherwise. The mark file is used to check whether the folder is well
   * constructed. If the property is true and mark file does not exist, the
   * copy is skipped.
   */
  checkMarkFile?: boolean;
}

/**
 * @interface
 * An interface representing RestartDeployedCodePackageDescription.
 * Defines description for restarting a deployed code package on Service Fabric
 * node.
 *
 */
export interface RestartDeployedCodePackageDescription {
  /**
   * @member {string} serviceManifestName The name of service manifest that
   * specified this code package.
   */
  serviceManifestName: string;
  /**
   * @member {string} [servicePackageActivationId] The ActivationId of a
   * deployed service package. If ServicePackageActivationMode specified at the
   * time of creating the service
   * is 'SharedProcess' (or if it is not specified, in which case it defaults
   * to 'SharedProcess'), then value of ServicePackageActivationId
   * is always an empty string.
   */
  servicePackageActivationId?: string;
  /**
   * @member {string} codePackageName The name of the code package defined in
   * the service manifest.
   */
  codePackageName: string;
  /**
   * @member {string} codePackageInstanceId The instance ID for currently
   * running entry point. For a code package setup entry point (if specified)
   * runs first and after it finishes main entry point is started.
   * Each time entry point executable is run, its instance ID will change. If 0
   * is passed in as the code package instance ID, the API will restart the
   * code package with whatever instance ID it is currently running.
   * If an instance ID other than 0 is passed in, the API will restart the code
   * package only if the current Instance ID matches the passed in instance ID.
   * Note, passing in the exact instance ID (not 0) in the API is safer,
   * because if ensures at most one restart of the code package.
   */
  codePackageInstanceId: string;
}

/**
 * @interface
 * An interface representing DeployedServiceTypeInfo.
 * Information about service type deployed on a node, information such as the
 * status of the service type registration on a node.
 *
 */
export interface DeployedServiceTypeInfo {
  /**
   * @member {string} [serviceTypeName] Name of the service type as specified
   * in the service manifest.
   */
  serviceTypeName?: string;
  /**
   * @member {string} [serviceManifestName] The name of the service manifest in
   * which this service type is defined.
   */
  serviceManifestName?: string;
  /**
   * @member {string} [codePackageName] The name of the code package that
   * registered the service type.
   */
  codePackageName?: string;
  /**
   * @member {ServiceTypeRegistrationStatus} [status] The status of the service
   * type registration on the node. Possible values include: 'Invalid',
   * 'Disabled', 'Enabled', 'Registered'
   */
  status?: ServiceTypeRegistrationStatus;
  /**
   * @member {string} [servicePackageActivationId] The ActivationId of a
   * deployed service package. If ServicePackageActivationMode specified at the
   * time of creating the service
   * is 'SharedProcess' (or if it is not specified, in which case it defaults
   * to 'SharedProcess'), then value of ServicePackageActivationId
   * is always an empty string.
   */
  servicePackageActivationId?: string;
}

/**
 * @interface
 * An interface representing ResolvedServiceEndpoint.
 * Endpoint of a resolved service partition.
 *
 */
export interface ResolvedServiceEndpoint {
  /**
   * @member {ServiceEndpointRole} [kind] The role of the replica where the
   * endpoint is reported. Possible values include: 'Invalid', 'Stateless',
   * 'StatefulPrimary', 'StatefulSecondary'
   */
  kind?: ServiceEndpointRole;
  /**
   * @member {string} [address] The address of the endpoint. If the endpoint
   * has multiple listeners the address is a JSON object with one property per
   * listener with the value as the address of that listener.
   */
  address?: string;
}

/**
 * @interface
 * An interface representing ResolvedServicePartition.
 * Information about a service partition and its associated endpoints.
 *
 */
export interface ResolvedServicePartition {
  /**
   * @member {string} name The full name of the service with 'fabric:' URI
   * scheme.
   */
  name: string;
  /**
   * @member {PartitionInformationUnion} partitionInformation A representation
   * of the resolved partition.
   */
  partitionInformation: PartitionInformationUnion;
  /**
   * @member {ResolvedServiceEndpoint[]} endpoints List of resolved service
   * endpoints of a service partition.
   */
  endpoints: ResolvedServiceEndpoint[];
  /**
   * @member {string} version The version of this resolved service partition
   * result. This version should be passed in the next time the ResolveService
   * call is made via the PreviousRspVersion query parameter.
   */
  version: string;
}

/**
 * @interface
 * An interface representing SelectedPartition.
 * This class returns information about the partition that the user-induced
 * operation acted upon.
 *
 */
export interface SelectedPartition {
  /**
   * @member {string} [serviceName] The name of the service the partition
   * belongs to.
   */
  serviceName?: string;
  /**
   * @member {string} [partitionId] An internal ID used by Service Fabric to
   * uniquely identify a partition. This is a randomly generated GUID when the
   * service was created. The partition ID is unique and does not change for
   * the lifetime of the service. If the same service was deleted and recreated
   * the IDs of its partitions would be different.
   */
  partitionId?: string;
}

/**
 * @interface
 * An interface representing InvokeDataLossResult.
 * Represents information about an operation in a terminal state (Completed or
 * Faulted).
 *
 */
export interface InvokeDataLossResult {
  /**
   * @member {number} [errorCode] If OperationState is Completed, this is 0.
   * If OperationState is Faulted, this is an error code indicating the reason.
   */
  errorCode?: number;
  /**
   * @member {SelectedPartition} [selectedPartition] This class returns
   * information about the partition that the user-induced operation acted
   * upon.
   */
  selectedPartition?: SelectedPartition;
}

/**
 * @interface
 * An interface representing InvokeQuorumLossResult.
 * Represents information about an operation in a terminal state (Completed or
 * Faulted).
 *
 */
export interface InvokeQuorumLossResult {
  /**
   * @member {number} [errorCode] If OperationState is Completed, this is 0.
   * If OperationState is Faulted, this is an error code indicating the reason.
   */
  errorCode?: number;
  /**
   * @member {SelectedPartition} [selectedPartition] This class returns
   * information about the partition that the user-induced operation acted
   * upon.
   */
  selectedPartition?: SelectedPartition;
}

/**
 * @interface
 * An interface representing NodeResult.
 * Contains information about a node that was targeted by a user-induced
 * operation.
 *
 */
export interface NodeResult {
  /**
   * @member {string} [nodeName] The name of a Service Fabric node.
   */
  nodeName?: string;
  /**
   * @member {string} [nodeInstanceId] The node instance id.
   */
  nodeInstanceId?: string;
}

/**
 * @interface
 * An interface representing NodeTransitionResult.
 * Represents information about an operation in a terminal state (Completed or
 * Faulted).
 *
 */
export interface NodeTransitionResult {
  /**
   * @member {number} [errorCode] If OperationState is Completed, this is 0.
   * If OperationState is Faulted, this is an error code indicating the reason.
   */
  errorCode?: number;
  /**
   * @member {NodeResult} [nodeResult] Contains information about a node that
   * was targeted by a user-induced operation.
   */
  nodeResult?: NodeResult;
}

/**
 * @interface
 * An interface representing NodeTransitionProgress.
 * Information about an NodeTransition operation.  This class contains an
 * OperationState and a NodeTransitionResult.  The NodeTransitionResult is not
 * valid until OperationState
 * is Completed or Faulted.
 *
 */
export interface NodeTransitionProgress {
  /**
   * @member {OperationState} [state] The state of the operation. Possible
   * values include: 'Invalid', 'Running', 'RollingBack', 'Completed',
   * 'Faulted', 'Cancelled', 'ForceCancelled'
   */
  state?: OperationState;
  /**
   * @member {NodeTransitionResult} [nodeTransitionResult] Represents
   * information about an operation in a terminal state (Completed or Faulted).
   */
  nodeTransitionResult?: NodeTransitionResult;
}

/**
 * @interface
 * An interface representing OperationStatus.
 * Contains the OperationId, OperationState, and OperationType for user-induced
 * operations.
 *
 */
export interface OperationStatus {
  /**
   * @member {string} [operationId] A GUID that identifies a call to this API.
   * This is also passed into the corresponding GetProgress API.
   */
  operationId?: string;
  /**
   * @member {OperationState} [state] The state of the operation. Possible
   * values include: 'Invalid', 'Running', 'RollingBack', 'Completed',
   * 'Faulted', 'Cancelled', 'ForceCancelled'
   */
  state?: OperationState;
  /**
   * @member {OperationType} [type] The type of the operation. Possible values
   * include: 'Invalid', 'PartitionDataLoss', 'PartitionQuorumLoss',
   * 'PartitionRestart', 'NodeTransition'
   */
  type?: OperationType;
}

/**
 * @interface
 * An interface representing PartitionDataLossProgress.
 * Information about a partition data loss user-induced operation.
 *
 */
export interface PartitionDataLossProgress {
  /**
   * @member {OperationState} [state] The state of the operation. Possible
   * values include: 'Invalid', 'Running', 'RollingBack', 'Completed',
   * 'Faulted', 'Cancelled', 'ForceCancelled'
   */
  state?: OperationState;
  /**
   * @member {InvokeDataLossResult} [invokeDataLossResult] Represents
   * information about an operation in a terminal state (Completed or Faulted).
   */
  invokeDataLossResult?: InvokeDataLossResult;
}

/**
 * @interface
 * An interface representing PartitionQuorumLossProgress.
 * Information about a partition quorum loss user-induced operation.
 *
 */
export interface PartitionQuorumLossProgress {
  /**
   * @member {OperationState} [state] The state of the operation. Possible
   * values include: 'Invalid', 'Running', 'RollingBack', 'Completed',
   * 'Faulted', 'Cancelled', 'ForceCancelled'
   */
  state?: OperationState;
  /**
   * @member {InvokeQuorumLossResult} [invokeQuorumLossResult] Represents
   * information about an operation in a terminal state (Completed or Faulted).
   */
  invokeQuorumLossResult?: InvokeQuorumLossResult;
}

/**
 * @interface
 * An interface representing RestartPartitionResult.
 * Represents information about an operation in a terminal state (Completed or
 * Faulted).
 *
 */
export interface RestartPartitionResult {
  /**
   * @member {number} [errorCode] If OperationState is Completed, this is 0.
   * If OperationState is Faulted, this is an error code indicating the reason.
   */
  errorCode?: number;
  /**
   * @member {SelectedPartition} [selectedPartition] This class returns
   * information about the partition that the user-induced operation acted
   * upon.
   */
  selectedPartition?: SelectedPartition;
}

/**
 * @interface
 * An interface representing PartitionRestartProgress.
 * Information about a partition restart user-induced operation.
 *
 */
export interface PartitionRestartProgress {
  /**
   * @member {OperationState} [state] The state of the operation. Possible
   * values include: 'Invalid', 'Running', 'RollingBack', 'Completed',
   * 'Faulted', 'Cancelled', 'ForceCancelled'
   */
  state?: OperationState;
  /**
   * @member {RestartPartitionResult} [restartPartitionResult] Represents
   * information about an operation in a terminal state (Completed or Faulted).
   */
  restartPartitionResult?: RestartPartitionResult;
}

/**
 * @interface
 * An interface representing PackageSharingPolicyInfo.
 * Represents a policy for the package sharing.
 *
 */
export interface PackageSharingPolicyInfo {
  /**
   * @member {string} [sharedPackageName] The name of code, configuration or
   * data package that should be shared.
   */
  sharedPackageName?: string;
  /**
   * @member {PackageSharingPolicyScope} [packageSharingScope] Represents the
   * scope for PackageSharingPolicy. This is specified during
   * DeployServicePackageToNode operation. Possible values include: 'None',
   * 'All', 'Code', 'Config', 'Data'
   */
  packageSharingScope?: PackageSharingPolicyScope;
}

/**
 * @interface
 * An interface representing DeployServicePackageToNodeDescription.
 * Defines description for downloading packages associated with a service
 * manifest to image cache on a Service Fabric node.
 *
 */
export interface DeployServicePackageToNodeDescription {
  /**
   * @member {string} serviceManifestName The name of service manifest whose
   * packages need to be downloaded.
   */
  serviceManifestName: string;
  /**
   * @member {string} applicationTypeName The application type name as defined
   * in the application manifest.
   */
  applicationTypeName: string;
  /**
   * @member {string} applicationTypeVersion The version of the application
   * type as defined in the application manifest.
   */
  applicationTypeVersion: string;
  /**
   * @member {string} nodeName The name of a Service Fabric node.
   */
  nodeName: string;
  /**
   * @member {PackageSharingPolicyInfo[]} [packageSharingPolicy] List of
   * package sharing policy information.
   */
  packageSharingPolicy?: PackageSharingPolicyInfo[];
}

/**
 * @interface
 * An interface representing ResumeApplicationUpgradeDescription.
 * Describes the parameters for resuming an unmonitored manual Service Fabric
 * application upgrade
 *
 */
export interface ResumeApplicationUpgradeDescription {
  /**
   * @member {string} upgradeDomainName The name of the upgrade domain in which
   * to resume the upgrade.
   */
  upgradeDomainName: string;
}

/**
 * @interface
 * An interface representing ApplicationUpgradeUpdateDescription.
 * Describes the parameters for updating an ongoing application upgrade.
 *
 */
export interface ApplicationUpgradeUpdateDescription {
  /**
   * @member {string} name The name of the application, including the 'fabric:'
   * URI scheme.
   */
  name: string;
  /**
   * @member {UpgradeKind} upgradeKind The kind of upgrade out of the following
   * possible values. Possible values include: 'Invalid', 'Rolling'. Default
   * value: 'Rolling' .
   */
  upgradeKind: UpgradeKind;
  /**
   * @member {ApplicationHealthPolicy} [applicationHealthPolicy] Defines a
   * health policy used to evaluate the health of an application or one of its
   * children entities.
   */
  applicationHealthPolicy?: ApplicationHealthPolicy;
  /**
   * @member {RollingUpgradeUpdateDescription} [updateDescription] Describes
   * the parameters for updating a rolling upgrade of application or cluster.
   */
  updateDescription?: RollingUpgradeUpdateDescription;
}

/**
 * @interface
 * An interface representing NameDescription.
 * Describes a Service Fabric name.
 *
 */
export interface NameDescription {
  /**
   * @member {string} name The Service Fabric name, including the 'fabric:' URI
   * scheme.
   */
  name: string;
}

/**
 * @interface
 * An interface representing PagedSubNameInfoList.
 * A paged list of Service Fabric names. The list is paged when all of the
 * results cannot fit in a single message. The next set of results can be
 * obtained by executing the same query with the continuation token provided in
 * this list.
 *
 */
export interface PagedSubNameInfoList {
  /**
   * @member {string} [continuationToken] The continuation token parameter is
   * used to obtain next set of results. The continuation token is included in
   * the response of the API when the results from the system do not fit in a
   * single response. When this value is passed to the next API call, the API
   * returns next set of results. If there are no further results, then the
   * continuation token is not included in the response.
   */
  continuationToken?: string;
  /**
   * @member {boolean} [isConsistent] Indicates whether any name under the
   * given name has been modified during the enumeration. If there was a
   * modification, this property value is false.
   */
  isConsistent?: boolean;
  /**
   * @member {string[]} [subNames] List of the child names.
   */
  subNames?: string[];
}

/**
 * Contains the possible cases for PropertyValue.
 */
export type PropertyValueUnion = PropertyValue | BinaryPropertyValue | Int64PropertyValue | DoublePropertyValue | StringPropertyValue | GuidPropertyValue;

/**
 * @interface
 * An interface representing PropertyValue.
 * Describes a Service Fabric property value.
 *
 */
export interface PropertyValue {
  /**
   * @member {string} kind Polymorphic Discriminator
   */
  kind: "PropertyValue";
}

/**
 * @interface
 * An interface representing BinaryPropertyValue.
 * Describes a Service Fabric property value of type Binary.
 *
 */
export interface BinaryPropertyValue {
  /**
   * @member {string} kind Polymorphic Discriminator
   */
  kind: "Binary";
  /**
   * @member {number[]} data Array of bytes to be sent as an integer array.
   * Each element of array is a number between 0 and 255.
   */
  data: number[];
}

/**
 * @interface
 * An interface representing Int64PropertyValue.
 * Describes a Service Fabric property value of type Int64.
 *
 */
export interface Int64PropertyValue {
  /**
   * @member {string} kind Polymorphic Discriminator
   */
  kind: "Int64";
  /**
   * @member {string} data The data of the property value.
   */
  data: string;
}

/**
 * @interface
 * An interface representing DoublePropertyValue.
 * Describes a Service Fabric property value of type Double.
 *
 */
export interface DoublePropertyValue {
  /**
   * @member {string} kind Polymorphic Discriminator
   */
  kind: "Double";
  /**
   * @member {number} data The data of the property value.
   */
  data: number;
}

/**
 * @interface
 * An interface representing StringPropertyValue.
 * Describes a Service Fabric property value of type String.
 *
 */
export interface StringPropertyValue {
  /**
   * @member {string} kind Polymorphic Discriminator
   */
  kind: "String";
  /**
   * @member {string} data The data of the property value.
   */
  data: string;
}

/**
 * @interface
 * An interface representing GuidPropertyValue.
 * Describes a Service Fabric property value of type Guid.
 *
 */
export interface GuidPropertyValue {
  /**
   * @member {string} kind Polymorphic Discriminator
   */
  kind: "Guid";
  /**
   * @member {string} data The data of the property value.
   */
  data: string;
}

/**
 * @interface
 * An interface representing PropertyMetadata.
 * The metadata associated with a property, including the property's name.
 *
 */
export interface PropertyMetadata {
  /**
   * @member {PropertyValueKind} [typeId] The kind of property, determined by
   * the type of data. Following are the possible values. Possible values
   * include: 'Invalid', 'Binary', 'Int64', 'Double', 'String', 'Guid'
   */
  typeId?: PropertyValueKind;
  /**
   * @member {string} [customTypeId] The property's custom type ID.
   */
  customTypeId?: string;
  /**
   * @member {string} [parent] The name of the parent Service Fabric Name for
   * the property. It could be thought of as the name-space/table under which
   * the property exists.
   */
  parent?: string;
  /**
   * @member {number} [sizeInBytes] The length of the serialized property
   * value.
   */
  sizeInBytes?: number;
  /**
   * @member {Date} [lastModifiedUtcTimestamp] Represents when the Property was
   * last modified. Only write operations will cause this field to be updated.
   */
  lastModifiedUtcTimestamp?: Date;
  /**
   * @member {string} [sequenceNumber] The version of the property. Every time
   * a property is modified, its sequence number is increased.
   */
  sequenceNumber?: string;
}

/**
 * @interface
 * An interface representing PropertyInfo.
 * Information about a Service Fabric property.
 *
 */
export interface PropertyInfo {
  /**
   * @member {string} name The name of the Service Fabric property.
   */
  name: string;
  /**
   * @member {PropertyValueUnion} [value] Describes a Service Fabric property
   * value.
   */
  value?: PropertyValueUnion;
  /**
   * @member {PropertyMetadata} metadata The metadata associated with a
   * property, including the property's name.
   */
  metadata: PropertyMetadata;
}

/**
 * @interface
 * An interface representing PagedPropertyInfoList.
 * The paged list of Service Fabric properties under a given name. The list is
 * paged when all of the results cannot fit in a single message. The next set
 * of results can be obtained by executing the same query with the continuation
 * token provided in this list.
 *
 */
export interface PagedPropertyInfoList {
  /**
   * @member {string} [continuationToken] The continuation token parameter is
   * used to obtain next set of results. The continuation token is included in
   * the response of the API when the results from the system do not fit in a
   * single response. When this value is passed to the next API call, the API
   * returns next set of results. If there are no further results, then the
   * continuation token is not included in the response.
   */
  continuationToken?: string;
  /**
   * @member {boolean} [isConsistent] Indicates whether any property under the
   * given name has been modified during the enumeration. If there was a
   * modification, this property value is false.
   */
  isConsistent?: boolean;
  /**
   * @member {PropertyInfo[]} [properties] List of property information.
   */
  properties?: PropertyInfo[];
}

/**
 * @interface
 * An interface representing PropertyDescription.
 * Description of a Service Fabric property.
 *
 */
export interface PropertyDescription {
  /**
   * @member {string} propertyName The name of the Service Fabric property.
   */
  propertyName: string;
  /**
   * @member {string} [customTypeId] The property's custom type ID. Using this
   * property, the user is able to tag the type of the value of the property.
   */
  customTypeId?: string;
  /**
   * @member {PropertyValueUnion} value Describes a Service Fabric property
   * value.
   */
  value: PropertyValueUnion;
}

/**
 * Contains the possible cases for PropertyBatchOperation.
 */
export type PropertyBatchOperationUnion = PropertyBatchOperation | CheckExistsPropertyBatchOperation | CheckSequencePropertyBatchOperation | CheckValuePropertyBatchOperation | DeletePropertyBatchOperation | GetPropertyBatchOperation | PutPropertyBatchOperation;

/**
 * @interface
 * An interface representing PropertyBatchOperation.
 * Represents the base type for property operations that can be put into a
 * batch and submitted.
 *
 */
export interface PropertyBatchOperation {
  /**
   * @member {string} kind Polymorphic Discriminator
   */
  kind: "PropertyBatchOperation";
  /**
   * @member {string} propertyName The name of the Service Fabric property.
   */
  propertyName: string;
}

/**
 * @interface
 * An interface representing PropertyBatchDescriptionList.
 * Describes a list of property batch operations to be executed. Either all or
 * none of the operations will be committed.
 *
 */
export interface PropertyBatchDescriptionList {
  /**
   * @member {PropertyBatchOperationUnion[]} [operations] A list of the
   * property batch operations to be executed.
   */
  operations?: PropertyBatchOperationUnion[];
}

/**
 * @interface
 * An interface representing CheckExistsPropertyBatchOperation.
 * Represents a PropertyBatchOperation that compares the Boolean existence of a
 * property with the Exists argument.
 * The PropertyBatchOperation operation fails if the property's existence is
 * not equal to the Exists argument.
 * The CheckExistsPropertyBatchOperation is generally used as a precondition
 * for the write operations in the batch.
 * Note that if one PropertyBatchOperation in a PropertyBatch fails,
 * the entire batch fails and cannot be committed in a transactional manner.
 *
 */
export interface CheckExistsPropertyBatchOperation {
  /**
   * @member {string} kind Polymorphic Discriminator
   */
  kind: "CheckExists";
  /**
   * @member {string} propertyName The name of the Service Fabric property.
   */
  propertyName: string;
  /**
   * @member {boolean} exists Whether or not the property should exist for the
   * operation to pass.
   */
  exists: boolean;
}

/**
 * @interface
 * An interface representing CheckSequencePropertyBatchOperation.
 * Compares the Sequence Number of a property with the SequenceNumber argument.
 * A property's sequence number can be thought of as that property's version.
 * Every time the property is modified, its sequence number is increased.
 * The sequence number can be found in a property's metadata.
 * The comparison fails if the sequence numbers are not equal.
 * CheckSequencePropertyBatchOperation is generally used as a precondition for
 * the write operations in the batch.
 * Note that if one PropertyBatchOperation in a PropertyBatch fails,
 * the entire batch fails and cannot be committed in a transactional manner.
 *
 */
export interface CheckSequencePropertyBatchOperation {
  /**
   * @member {string} kind Polymorphic Discriminator
   */
  kind: "CheckSequence";
  /**
   * @member {string} propertyName The name of the Service Fabric property.
   */
  propertyName: string;
  /**
   * @member {string} sequenceNumber The expected sequence number.
   */
  sequenceNumber: string;
}

/**
 * @interface
 * An interface representing CheckValuePropertyBatchOperation.
 * Represents a PropertyBatchOperation that compares the value of the property
 * with the expected value.
 * The CheckValuePropertyBatchOperation is generally used as a precondition for
 * the write operations in the batch.
 * Note that if one PropertyBatchOperation in a PropertyBatch fails,
 * the entire batch fails and cannot be committed in a transactional manner.
 *
 */
export interface CheckValuePropertyBatchOperation {
  /**
   * @member {string} kind Polymorphic Discriminator
   */
  kind: "CheckValue";
  /**
   * @member {string} propertyName The name of the Service Fabric property.
   */
  propertyName: string;
  /**
   * @member {PropertyValueUnion} value The expected property value.
   */
  value: PropertyValueUnion;
}

/**
 * @interface
 * An interface representing DeletePropertyBatchOperation.
 * Represents a PropertyBatchOperation that deletes a specified property if it
 * exists.
 * Note that if one PropertyBatchOperation in a PropertyBatch fails,
 * the entire batch fails and cannot be committed in a transactional manner.
 *
 */
export interface DeletePropertyBatchOperation {
  /**
   * @member {string} kind Polymorphic Discriminator
   */
  kind: "Delete";
  /**
   * @member {string} propertyName The name of the Service Fabric property.
   */
  propertyName: string;
}

/**
 * @interface
 * An interface representing GetPropertyBatchOperation.
 * Represents a PropertyBatchOperation that gets the specified property if it
 * exists.
 * Note that if one PropertyBatchOperation in a PropertyBatch fails,
 * the entire batch fails and cannot be committed in a transactional manner.
 *
 */
export interface GetPropertyBatchOperation {
  /**
   * @member {string} kind Polymorphic Discriminator
   */
  kind: "Get";
  /**
   * @member {string} propertyName The name of the Service Fabric property.
   */
  propertyName: string;
  /**
   * @member {boolean} [includeValue] Whether or not to return the property
   * value with the metadata.
   * True if values should be returned with the metadata; False to return only
   * property metadata. Default value: false .
   */
  includeValue?: boolean;
}

/**
 * @interface
 * An interface representing PutPropertyBatchOperation.
 * Puts the specified property under the specified name.
 * Note that if one PropertyBatchOperation in a PropertyBatch fails,
 * the entire batch fails and cannot be committed in a transactional manner.
 *
 */
export interface PutPropertyBatchOperation {
  /**
   * @member {string} kind Polymorphic Discriminator
   */
  kind: "Put";
  /**
   * @member {string} propertyName The name of the Service Fabric property.
   */
  propertyName: string;
  /**
   * @member {PropertyValueUnion} value Describes a Service Fabric property
   * value.
   */
  value: PropertyValueUnion;
  /**
   * @member {string} [customTypeId] The property's custom type ID. Using this
   * property, the user is able to tag the type of the value of the property.
   */
  customTypeId?: string;
}

/**
 * Contains the possible cases for PropertyBatchInfo.
 */
export type PropertyBatchInfoUnion = PropertyBatchInfo | SuccessfulPropertyBatchInfo | FailedPropertyBatchInfo;

/**
 * @interface
 * An interface representing PropertyBatchInfo.
 * Information about the results of a property batch.
 *
 */
export interface PropertyBatchInfo {
  /**
   * @member {string} kind Polymorphic Discriminator
   */
  kind: "PropertyBatchInfo";
}

/**
 * @interface
 * An interface representing SuccessfulPropertyBatchInfo.
 * Derived from PropertyBatchInfo. Represents the property batch succeeding.
 * Contains the results of any "Get" operations in the batch.
 *
 */
export interface SuccessfulPropertyBatchInfo {
  /**
   * @member {string} kind Polymorphic Discriminator
   */
  kind: "Successful";
  /**
   * @member {{ [propertyName: string]: PropertyInfo }} [properties] A map
   * containing the properties that were requested through any "Get" property
   * batch operations. The key represents the index of the "Get" operation in
   * the original request, in string form. The value is the property. If a
   * property is not found, it will not be in the map.
   */
  properties?: { [propertyName: string]: PropertyInfo };
}

/**
 * @interface
 * An interface representing FailedPropertyBatchInfo.
 * Derived from PropertyBatchInfo. Represents the property batch failing.
 * Contains information about the specific batch failure.
 *
 */
export interface FailedPropertyBatchInfo {
  /**
   * @member {string} kind Polymorphic Discriminator
   */
  kind: "Failed";
  /**
   * @member {string} [errorMessage] The error message of the failed operation.
   * Describes the exception thrown due to the first unsuccessful operation in
   * the property batch.
   */
  errorMessage?: string;
  /**
   * @member {number} [operationIndex] The index of the unsuccessful operation
   * in the property batch.
   */
  operationIndex?: number;
}

/**
 * Contains the possible cases for BackupScheduleDescription.
 */
export type BackupScheduleDescriptionUnion = BackupScheduleDescription | FrequencyBasedBackupScheduleDescription | TimeBasedBackupScheduleDescription;

/**
 * @interface
 * An interface representing BackupScheduleDescription.
 * Describes the backup schedule parameters.
 *
 */
export interface BackupScheduleDescription {
  /**
   * @member {string} scheduleKind Polymorphic Discriminator
   */
  scheduleKind: "BackupScheduleDescription";
}

/**
 * Contains the possible cases for BackupStorageDescription.
 */
export type BackupStorageDescriptionUnion = BackupStorageDescription | AzureBlobBackupStorageDescription | FileShareBackupStorageDescription;

/**
 * @interface
 * An interface representing BackupStorageDescription.
 * Describes the parameters for the backup storage.
 *
 */
export interface BackupStorageDescription {
  /**
   * @member {string} storageKind Polymorphic Discriminator
   */
  storageKind: "BackupStorageDescription";
  /**
   * @member {string} [friendlyName] Friendly name for this backup storage.
   */
  friendlyName?: string;
}

/**
 * @interface
 * An interface representing BackupPolicyDescription.
 * Describes a backup policy for configuring periodic backup.
 *
 */
export interface BackupPolicyDescription {
  /**
   * @member {string} name The unique name identifying this backup policy.
   */
  name: string;
  /**
   * @member {boolean} autoRestoreOnDataLoss Specifies whether to trigger
   * restore automatically using the latest available backup in case the
   * partition experiences a data loss event.
   */
  autoRestoreOnDataLoss: boolean;
  /**
   * @member {number} maxIncrementalBackups Defines the maximum number of
   * incremental backups to be taken between two full backups. This is just the
   * upper limit. A full backup may be taken before specified number of
   * incremental backups are completed in one of the following conditions
   * - The replica has never taken a full backup since it has become primary,
   * - Some of the log records since the last backup has been truncated, or
   * - Replica passed the MaxAccumulatedBackupLogSizeInMB limit.
   */
  maxIncrementalBackups: number;
  /**
   * @member {BackupScheduleDescriptionUnion} schedule Describes the backup
   * schedule parameters.
   */
  schedule: BackupScheduleDescriptionUnion;
  /**
   * @member {BackupStorageDescriptionUnion} storage Describes the details of
   * backup storage where to store the periodic backups.
   */
  storage: BackupStorageDescriptionUnion;
}

/**
 * @interface
 * An interface representing PagedBackupPolicyDescriptionList.
 * The list of backup policies configured in the cluster. The list is paged
 * when all of the results cannot fit in a single message. The next set of
 * results can be obtained by executing the same query with the continuation
 * token provided in this list.
 *
 */
export interface PagedBackupPolicyDescriptionList {
  /**
   * @member {string} [continuationToken] The continuation token parameter is
   * used to obtain next set of results. The continuation token is included in
   * the response of the API when the results from the system do not fit in a
   * single response. When this value is passed to the next API call, the API
   * returns next set of results. If there are no further results, then the
   * continuation token is not included in the response.
   */
  continuationToken?: string;
  /**
   * @member {BackupPolicyDescription[]} [items] The list of backup policies
   * information.
   */
  items?: BackupPolicyDescription[];
}

/**
 * Contains the possible cases for BackupConfigurationInfo.
 */
export type BackupConfigurationInfoUnion = BackupConfigurationInfo | ApplicationBackupConfigurationInfo | ServiceBackupConfigurationInfo | PartitionBackupConfigurationInfo;

/**
 * @interface
 * An interface representing BackupConfigurationInfo.
 * Describes the backup configuration information.
 *
 */
export interface BackupConfigurationInfo {
  /**
   * @member {string} kind Polymorphic Discriminator
   */
  kind: "BackupConfigurationInfo";
  /**
   * @member {string} [policyName] The name of the backup policy which is
   * applicable to this Service Fabric application or service or partition.
   */
  policyName?: string;
  /**
   * @member {BackupPolicyScope} [policyInheritedFrom] Specifies the scope at
   * which the backup policy is applied. Possible values include: 'Invalid',
   * 'Partition', 'Service', 'Application'
   */
  policyInheritedFrom?: BackupPolicyScope;
  /**
   * @member {BackupSuspensionInfo} [suspensionInfo] Describes the backup
   * suspension details.
   */
  suspensionInfo?: BackupSuspensionInfo;
}

/**
 * @interface
 * An interface representing ApplicationBackupConfigurationInfo.
 * Backup configuration information for a specific Service Fabric application
 * specifying what backup policy is being applied and suspend description, if
 * any.
 *
 */
export interface ApplicationBackupConfigurationInfo {
  /**
   * @member {string} kind Polymorphic Discriminator
   */
  kind: "Application";
  /**
   * @member {string} [policyName] The name of the backup policy which is
   * applicable to this Service Fabric application or service or partition.
   */
  policyName?: string;
  /**
   * @member {BackupPolicyScope} [policyInheritedFrom] Specifies the scope at
   * which the backup policy is applied. Possible values include: 'Invalid',
   * 'Partition', 'Service', 'Application'
   */
  policyInheritedFrom?: BackupPolicyScope;
  /**
   * @member {BackupSuspensionInfo} [suspensionInfo] Describes the backup
   * suspension details.
   */
  suspensionInfo?: BackupSuspensionInfo;
  /**
   * @member {string} [applicationName] The name of the application, including
   * the 'fabric:' URI scheme.
   */
  applicationName?: string;
}

/**
 * @interface
 * An interface representing ServiceBackupConfigurationInfo.
 * Backup configuration information for a specific Service Fabric service
 * specifying what backup policy is being applied and suspend description, if
 * any.
 *
 */
export interface ServiceBackupConfigurationInfo {
  /**
   * @member {string} kind Polymorphic Discriminator
   */
  kind: "Service";
  /**
   * @member {string} [policyName] The name of the backup policy which is
   * applicable to this Service Fabric application or service or partition.
   */
  policyName?: string;
  /**
   * @member {BackupPolicyScope} [policyInheritedFrom] Specifies the scope at
   * which the backup policy is applied. Possible values include: 'Invalid',
   * 'Partition', 'Service', 'Application'
   */
  policyInheritedFrom?: BackupPolicyScope;
  /**
   * @member {BackupSuspensionInfo} [suspensionInfo] Describes the backup
   * suspension details.
   */
  suspensionInfo?: BackupSuspensionInfo;
  /**
   * @member {string} [serviceName] The full name of the service with 'fabric:'
   * URI scheme.
   */
  serviceName?: string;
}

/**
 * @interface
 * An interface representing BackupSuspensionInfo.
 * Describes the backup suspension details.
 *
 */
export interface BackupSuspensionInfo {
  /**
   * @member {boolean} [isSuspended] Indicates whether periodic backup is
   * suspended at this level or not.
   */
  isSuspended?: boolean;
  /**
   * @member {BackupSuspensionScope} [suspensionInheritedFrom] Specifies the
   * scope at which the backup suspension was applied. Possible values include:
   * 'Invalid', 'Partition', 'Service', 'Application'
   */
  suspensionInheritedFrom?: BackupSuspensionScope;
}

/**
 * @interface
 * An interface representing PagedBackupConfigurationInfoList.
 * The list of backup configuration information. The list is paged when all of
 * the results cannot fit in a single message. The next set of results can be
 * obtained by executing the same query with the continuation token provided in
 * this list.
 *
 */
export interface PagedBackupConfigurationInfoList {
  /**
   * @member {string} [continuationToken] The continuation token parameter is
   * used to obtain next set of results. The continuation token is included in
   * the response of the API when the results from the system do not fit in a
   * single response. When this value is passed to the next API call, the API
   * returns next set of results. If there are no further results, then the
   * continuation token is not included in the response.
   */
  continuationToken?: string;
  /**
   * @member {BackupConfigurationInfoUnion[]} [items] List of backup
   * configuration information.
   */
  items?: BackupConfigurationInfoUnion[];
}

/**
 * @interface
 * An interface representing RestorePartitionDescription.
 * Specifies the parameters needed to trigger a restore of a specific
 * partition.
 *
 */
export interface RestorePartitionDescription {
  /**
   * @member {string} backupId Unique backup ID.
   */
  backupId: string;
  /**
   * @member {string} backupLocation Location of the backup relative to the
   * backup storage specified/ configured.
   */
  backupLocation: string;
  /**
   * @member {BackupStorageDescriptionUnion} [backupStorage] Location of the
   * backup from where the partition will be restored.
   */
  backupStorage?: BackupStorageDescriptionUnion;
}

/**
 * @interface
 * An interface representing RestoreProgressInfo.
 * Describes the progress of a restore operation on a partition.
 *
 */
export interface RestoreProgressInfo {
  /**
   * @member {RestoreState} [restoreState] Represents the current state of the
   * partition restore operation. Possible values include: 'Invalid',
   * 'Accepted', 'RestoreInProgress', 'Success', 'Failure', 'Timeout'
   */
  restoreState?: RestoreState;
  /**
   * @member {Date} [timeStampUtc] Timestamp when operation succeeded or
   * failed.
   */
  timeStampUtc?: Date;
  /**
   * @member {BackupEpoch} [restoredEpoch] Describes the epoch at which the
   * partition is restored.
   */
  restoredEpoch?: BackupEpoch;
  /**
   * @member {string} [restoredLsn] Restored LSN.
   */
  restoredLsn?: string;
  /**
   * @member {FabricErrorError} [failureError] Denotes the failure encountered
   * in performing restore operation.
   */
  failureError?: FabricErrorError;
}

/**
 * @interface
 * An interface representing BackupPartitionDescription.
 * Describes the parameters for triggering partition's backup.
 *
 */
export interface BackupPartitionDescription {
  /**
   * @member {BackupStorageDescriptionUnion} [backupStorage] Specifies the
   * details of the backup storage where to save the backup.
   */
  backupStorage?: BackupStorageDescriptionUnion;
}

/**
 * @interface
 * An interface representing BackupInfo.
 * Represents a backup point which can be used to trigger a restore.
 *
 */
export interface BackupInfo {
  /**
   * @member {string} [backupId] Unique backup ID .
   */
  backupId?: string;
  /**
   * @member {string} [backupChainId] Unique backup chain ID. All backups part
   * of the same chain has the same backup chain id. A backup chain is
   * comprised of 1 full backup and multiple incremental backups.
   */
  backupChainId?: string;
  /**
   * @member {string} [applicationName] Name of the Service Fabric application
   * this partition backup belongs to.
   */
  applicationName?: string;
  /**
   * @member {string} [serviceName] Name of the Service Fabric service this
   * partition backup belongs to.
   */
  serviceName?: string;
  /**
   * @member {PartitionInformationUnion} [partitionInformation] Information
   * about the partition to which this backup belongs to
   */
  partitionInformation?: PartitionInformationUnion;
  /**
   * @member {string} [backupLocation] Location of the backup, relative to the
   * backup store.
   */
  backupLocation?: string;
  /**
   * @member {BackupType} [backupType] Describes the type of backup, whether
   * its full or incremental. Possible values include: 'Invalid', 'Full',
   * 'Incremental'
   */
  backupType?: BackupType;
  /**
   * @member {BackupEpoch} [epochOfLastBackupRecord] Epoch of the last record
   * in this backup.
   */
  epochOfLastBackupRecord?: BackupEpoch;
  /**
   * @member {string} [lsnOfLastBackupRecord] LSN of the last record in this
   * backup.
   */
  lsnOfLastBackupRecord?: string;
  /**
   * @member {Date} [creationTimeUtc] The date time when this backup was taken.
   */
  creationTimeUtc?: Date;
  /**
   * @member {FabricErrorError} [failureError] Denotes the failure encountered
   * in getting backup point information.
   */
  failureError?: FabricErrorError;
}

/**
 * @interface
 * An interface representing PagedBackupInfoList.
 * The list of backups. The list is paged when all of the results cannot fit in
 * a single message. The next set of results can be obtained by executing the
 * same query with the continuation token provided in this list.
 *
 */
export interface PagedBackupInfoList {
  /**
   * @member {string} [continuationToken] The continuation token parameter is
   * used to obtain next set of results. The continuation token is included in
   * the response of the API when the results from the system do not fit in a
   * single response. When this value is passed to the next API call, the API
   * returns next set of results. If there are no further results, then the
   * continuation token is not included in the response.
   */
  continuationToken?: string;
  /**
   * @member {BackupInfo[]} [items] List of backup information.
   */
  items?: BackupInfo[];
}

/**
 * @interface
 * An interface representing AzureBlobBackupStorageDescription.
 * Describes the parameters for Azure blob store used for storing and
 * enumerating backups.
 *
 */
export interface AzureBlobBackupStorageDescription {
  /**
   * @member {string} storageKind Polymorphic Discriminator
   */
  storageKind: "AzureBlobStore";
  /**
   * @member {string} [friendlyName] Friendly name for this backup storage.
   */
  friendlyName?: string;
  /**
   * @member {string} connectionString The connection string to connect to the
   * Azure blob store.
   */
  connectionString: string;
  /**
   * @member {string} containerName The name of the container in the blob store
   * to store and enumerate backups from.
   */
  containerName: string;
}

/**
 * @interface
 * An interface representing FileShareBackupStorageDescription.
 * Describes the parameters for file share storage used for storing or
 * enumerating backups.
 *
 */
export interface FileShareBackupStorageDescription {
  /**
   * @member {string} storageKind Polymorphic Discriminator
   */
  storageKind: "FileShare";
  /**
   * @member {string} [friendlyName] Friendly name for this backup storage.
   */
  friendlyName?: string;
  /**
   * @member {string} path UNC path of the file share where to store or
   * enumerate backups from.
   */
  path: string;
  /**
   * @member {string} [primaryUserName] Primary user name to access the file
   * share.
   */
  primaryUserName?: string;
  /**
   * @member {string} [primaryPassword] Primary password to access the share
   * location.
   */
  primaryPassword?: string;
  /**
   * @member {string} [secondaryUserName] Secondary user name to access the
   * file share.
   */
  secondaryUserName?: string;
  /**
   * @member {string} [secondaryPassword] Secondary password to access the
   * share location
   */
  secondaryPassword?: string;
}

/**
 * @interface
 * An interface representing FrequencyBasedBackupScheduleDescription.
 * Describes the frequency based backup schedule.
 *
 */
export interface FrequencyBasedBackupScheduleDescription {
  /**
   * @member {string} scheduleKind Polymorphic Discriminator
   */
  scheduleKind: "FrequencyBased";
  /**
   * @member {string} interval Defines the interval with which backups are
   * periodically taken. It should be specified in ISO8601 format. Timespan in
   * seconds is not supported and will be ignored while creating the policy.
   */
  interval: string;
}

/**
 * @interface
 * An interface representing TimeBasedBackupScheduleDescription.
 * Describes the time based backup schedule.
 *
 */
export interface TimeBasedBackupScheduleDescription {
  /**
   * @member {string} scheduleKind Polymorphic Discriminator
   */
  scheduleKind: "TimeBased";
  /**
   * @member {BackupScheduleFrequencyType} scheduleFrequencyType Describes the
   * frequency with which to run the time based backup schedule. Possible
   * values include: 'Invalid', 'Daily', 'Weekly'
   */
  scheduleFrequencyType: BackupScheduleFrequencyType;
  /**
   * @member {DayOfWeek[]} [runDays] List of days of a week when to trigger the
   * periodic backup. This is valid only when the backup schedule frequency
   * type is weekly.
   */
  runDays?: DayOfWeek[];
  /**
   * @member {Date[] | string[]} runTimes Represents the list of exact time
   * during the day in ISO8601 format. Like '19:00:00' will represent '7PM'
   * during the day. Date specified along with time will be ignored.
   */
  runTimes: Date[] | string[];
}

/**
 * @interface
 * An interface representing BackupProgressInfo.
 * Describes the progress of a partition's backup.
 *
 */
export interface BackupProgressInfo {
  /**
   * @member {BackupState} [backupState] Represents the current state of the
   * partition backup operation. Possible values include: 'Invalid',
   * 'Accepted', 'BackupInProgress', 'Success', 'Failure', 'Timeout'
   */
  backupState?: BackupState;
  /**
   * @member {Date} [timeStampUtc] TimeStamp in UTC when operation succeeded or
   * failed.
   */
  timeStampUtc?: Date;
  /**
   * @member {string} [backupId] Unique ID of the newly created backup.
   */
  backupId?: string;
  /**
   * @member {string} [backupLocation] Location, relative to the backup store,
   * of the newly created backup.
   */
  backupLocation?: string;
  /**
   * @member {BackupEpoch} [epochOfLastBackupRecord] Specifies the epoch of the
   * last record included in backup.
   */
  epochOfLastBackupRecord?: BackupEpoch;
  /**
   * @member {string} [lsnOfLastBackupRecord] The LSN of last record included
   * in backup.
   */
  lsnOfLastBackupRecord?: string;
  /**
   * @member {FabricErrorError} [failureError] Denotes the failure encountered
   * in performing backup operation.
   */
  failureError?: FabricErrorError;
}

/**
 * @interface
 * An interface representing PartitionBackupConfigurationInfo.
 * Backup configuration information, for a specific partition, specifying what
 * backup policy is being applied and suspend description, if any.
 *
 */
export interface PartitionBackupConfigurationInfo {
  /**
   * @member {string} kind Polymorphic Discriminator
   */
  kind: "Partition";
  /**
   * @member {string} [policyName] The name of the backup policy which is
   * applicable to this Service Fabric application or service or partition.
   */
  policyName?: string;
  /**
   * @member {BackupPolicyScope} [policyInheritedFrom] Specifies the scope at
   * which the backup policy is applied. Possible values include: 'Invalid',
   * 'Partition', 'Service', 'Application'
   */
  policyInheritedFrom?: BackupPolicyScope;
  /**
   * @member {BackupSuspensionInfo} [suspensionInfo] Describes the backup
   * suspension details.
   */
  suspensionInfo?: BackupSuspensionInfo;
  /**
   * @member {string} [serviceName] The full name of the service with 'fabric:'
   * URI scheme.
   */
  serviceName?: string;
  /**
   * @member {string} [partitionId] An internal ID used by Service Fabric to
   * uniquely identify a partition. This is a randomly generated GUID when the
   * service was created. The partition ID is unique and does not change for
   * the lifetime of the service. If the same service was deleted and recreated
   * the IDs of its partitions would be different.
   */
  partitionId?: string;
}

/**
 * Contains the possible cases for BackupEntity.
 */
export type BackupEntityUnion = BackupEntity | ApplicationBackupEntity | ServiceBackupEntity | PartitionBackupEntity;

/**
 * @interface
 * An interface representing BackupEntity.
 * Describes the Service Fabric entity that is configured for backup.
 *
 */
export interface BackupEntity {
  /**
   * @member {string} entityKind Polymorphic Discriminator
   */
  entityKind: "BackupEntity";
}

/**
 * @interface
 * An interface representing ApplicationBackupEntity.
 * Identifies the Service Fabric application which is being backed up.
 *
 */
export interface ApplicationBackupEntity {
  /**
   * @member {string} entityKind Polymorphic Discriminator
   */
  entityKind: "Application";
  /**
   * @member {string} [applicationName] The name of the application, including
   * the 'fabric:' URI scheme.
   */
  applicationName?: string;
}

/**
 * @interface
 * An interface representing ServiceBackupEntity.
 * Identifies the Service Fabric stateful service which is being backed up.
 *
 */
export interface ServiceBackupEntity {
  /**
   * @member {string} entityKind Polymorphic Discriminator
   */
  entityKind: "Service";
  /**
   * @member {string} [serviceName] The full name of the service with 'fabric:'
   * URI scheme.
   */
  serviceName?: string;
}

/**
 * @interface
 * An interface representing PartitionBackupEntity.
 * Identifies the Service Fabric stateful partition which is being backed up.
 *
 */
export interface PartitionBackupEntity {
  /**
   * @member {string} entityKind Polymorphic Discriminator
   */
  entityKind: "Partition";
  /**
   * @member {string} [serviceName] The full name of the service with 'fabric:'
   * URI scheme.
   */
  serviceName?: string;
  /**
   * @member {string} [partitionId] An internal ID used by Service Fabric to
   * uniquely identify a partition. This is a randomly generated GUID when the
   * service was created. The partition ID is unique and does not change for
   * the lifetime of the service. If the same service was deleted and recreated
   * the IDs of its partitions would be different.
   */
  partitionId?: string;
}

/**
 * @interface
 * An interface representing EnableBackupDescription.
 * Specifies the parameters needed to enable periodic backup.
 *
 */
export interface EnableBackupDescription {
  /**
   * @member {string} backupPolicyName Name of the backup policy to be used for
   * enabling periodic backups.
   */
  backupPolicyName: string;
}

/**
 * @interface
 * An interface representing PagedBackupEntityList.
 * The list of backup entities that are being periodically backed. The list is
 * paged when all of the results cannot fit in a single message. The next set
 * of results can be obtained by executing the same query with the continuation
 * token provided in this list.
 *
 */
export interface PagedBackupEntityList {
  /**
   * @member {string} [continuationToken] The continuation token parameter is
   * used to obtain next set of results. The continuation token is included in
   * the response of the API when the results from the system do not fit in a
   * single response. When this value is passed to the next API call, the API
   * returns next set of results. If there are no further results, then the
   * continuation token is not included in the response.
   */
  continuationToken?: string;
  /**
   * @member {BackupEntityUnion[]} [items] List of backup entity information.
   */
  items?: BackupEntityUnion[];
}

/**
 * @interface
 * An interface representing GetBackupByStorageQueryDescription.
 * Describes additional filters to be applied, while listing backups, and
 * backup storage details from where to fetch the backups.
 *
 */
export interface GetBackupByStorageQueryDescription {
  /**
   * @member {Date} [startDateTimeFilter] Specifies the start date time in
   * ISO8601 from which to enumerate backups. If not specified, backups are
   * enumerated from the beginning.
   */
  startDateTimeFilter?: Date;
  /**
   * @member {Date} [endDateTimeFilter] Specifies the end date time in ISO8601
   * till which to enumerate backups. If not specified, backups are enumerated
   * till the end.
   */
  endDateTimeFilter?: Date;
  /**
   * @member {boolean} [latest] If specified as true, gets the most recent
   * backup (within the specified time range) for every partition under the
   * specified backup entity. Default value: false .
   */
  latest?: boolean;
  /**
   * @member {BackupStorageDescriptionUnion} storage Describes the parameters
   * for the backup storage from where to enumerate backups. This is optional
   * and by default backups are enumerated from the backup storage where this
   * backup entity is currently being backed up (as specified in backup
   * policy). This parameter is useful to be able to enumerate backups from
   * another cluster where you may intend to restore.
   */
  storage: BackupStorageDescriptionUnion;
  /**
   * @member {BackupEntityUnion} backupEntity Indicates the entity for which to
   * enumerate backups.
   */
  backupEntity: BackupEntityUnion;
}

/**
 * @interface
 * An interface representing NodeImpact.
 * Describes the expected impact of a repair to a particular node.
 *
 * This type supports the Service Fabric platform; it is not meant to be used
 * directly from your code.
 *
 */
export interface NodeImpact {
  /**
   * @member {string} nodeName The name of the impacted node.
   */
  nodeName: string;
  /**
   * @member {ImpactLevel} [impactLevel] The level of impact expected. Possible
   * values include: 'Invalid', 'None', 'Restart', 'RemoveData', 'RemoveNode'
   */
  impactLevel?: ImpactLevel;
}

/**
 * Contains the possible cases for RepairImpactDescriptionBase.
 */
export type RepairImpactDescriptionBaseUnion = RepairImpactDescriptionBase | NodeRepairImpactDescription;

/**
 * @interface
 * An interface representing RepairImpactDescriptionBase.
 * Describes the expected impact of executing a repair task.
 *
 * This type supports the Service Fabric platform; it is not meant to be used
 * directly from your code.
 *
 */
export interface RepairImpactDescriptionBase {
  /**
   * @member {string} kind Polymorphic Discriminator
   */
  kind: "RepairImpactDescriptionBase";
}

/**
 * @interface
 * An interface representing NodeRepairImpactDescription.
 * Describes the expected impact of a repair on a set of nodes.
 *
 * This type supports the Service Fabric platform; it is not meant to be used
 * directly from your code.
 *
 */
export interface NodeRepairImpactDescription {
  /**
   * @member {string} kind Polymorphic Discriminator
   */
  kind: "Node";
  /**
   * @member {NodeImpact[]} [nodeImpactList] The list of nodes impacted by a
   * repair action and their respective expected impact.
   */
  nodeImpactList?: NodeImpact[];
}

/**
 * Contains the possible cases for RepairTargetDescriptionBase.
 */
export type RepairTargetDescriptionBaseUnion = RepairTargetDescriptionBase | NodeRepairTargetDescription;

/**
 * @interface
 * An interface representing RepairTargetDescriptionBase.
 * Describes the entities targeted by a repair action.
 *
 * This type supports the Service Fabric platform; it is not meant to be used
 * directly from your code.
 *
 */
export interface RepairTargetDescriptionBase {
  /**
   * @member {string} kind Polymorphic Discriminator
   */
  kind: "RepairTargetDescriptionBase";
}

/**
 * @interface
 * An interface representing NodeRepairTargetDescription.
 * Describes the list of nodes targeted by a repair action.
 *
 * This type supports the Service Fabric platform; it is not meant to be used
 * directly from your code.
 *
 */
export interface NodeRepairTargetDescription {
  /**
   * @member {string} kind Polymorphic Discriminator
   */
  kind: "Node";
  /**
   * @member {string[]} [nodeNames] The list of nodes targeted by a repair
   * action.
   */
  nodeNames?: string[];
}

/**
 * @interface
 * An interface representing RepairTaskHistory.
 * A record of the times when the repair task entered each state.
 *
 * This type supports the Service Fabric platform; it is not meant to be used
 * directly from your code.
 *
 */
export interface RepairTaskHistory {
  /**
   * @member {Date} [createdUtcTimestamp] The time when the repair task entered
   * the Created state.
   */
  createdUtcTimestamp?: Date;
  /**
   * @member {Date} [claimedUtcTimestamp] The time when the repair task entered
   * the Claimed state.
   */
  claimedUtcTimestamp?: Date;
  /**
   * @member {Date} [preparingUtcTimestamp] The time when the repair task
   * entered the Preparing state.
   */
  preparingUtcTimestamp?: Date;
  /**
   * @member {Date} [approvedUtcTimestamp] The time when the repair task
   * entered the Approved state
   */
  approvedUtcTimestamp?: Date;
  /**
   * @member {Date} [executingUtcTimestamp] The time when the repair task
   * entered the Executing state
   */
  executingUtcTimestamp?: Date;
  /**
   * @member {Date} [restoringUtcTimestamp] The time when the repair task
   * entered the Restoring state
   */
  restoringUtcTimestamp?: Date;
  /**
   * @member {Date} [completedUtcTimestamp] The time when the repair task
   * entered the Completed state
   */
  completedUtcTimestamp?: Date;
  /**
   * @member {Date} [preparingHealthCheckStartUtcTimestamp] The time when the
   * repair task started the health check in the Preparing state.
   */
  preparingHealthCheckStartUtcTimestamp?: Date;
  /**
   * @member {Date} [preparingHealthCheckEndUtcTimestamp] The time when the
   * repair task completed the health check in the Preparing state.
   */
  preparingHealthCheckEndUtcTimestamp?: Date;
  /**
   * @member {Date} [restoringHealthCheckStartUtcTimestamp] The time when the
   * repair task started the health check in the Restoring state.
   */
  restoringHealthCheckStartUtcTimestamp?: Date;
  /**
   * @member {Date} [restoringHealthCheckEndUtcTimestamp] The time when the
   * repair task completed the health check in the Restoring state.
   */
  restoringHealthCheckEndUtcTimestamp?: Date;
}

/**
 * @interface
 * An interface representing RepairTask.
 * Represents a repair task, which includes information about what kind of
 * repair was requested, what its progress is, and what its final result was.
 *
 * This type supports the Service Fabric platform; it is not meant to be used
 * directly from your code.
 *
 */
export interface RepairTask {
  /**
   * @member {string} taskId The ID of the repair task.
   */
  taskId: string;
  /**
   * @member {string} [version] The version of the repair task.
   * When creating a new repair task, the version must be set to zero.  When
   * updating a repair task,
   * the version is used for optimistic concurrency checks.  If the version is
   * set to zero, the update will not check for write conflicts.  If the
   * version is set to a non-zero value, then the
   * update will only succeed if the actual current version of the repair task
   * matches this value.
   */
  version?: string;
  /**
   * @member {string} [description] A description of the purpose of the repair
   * task, or other informational details.
   * May be set when the repair task is created, and is immutable once set.
   */
  description?: string;
  /**
   * @member {State} state The workflow state of the repair task. Valid initial
   * states are Created, Claimed, and Preparing. Possible values include:
   * 'Invalid', 'Created', 'Claimed', 'Preparing', 'Approved', 'Executing',
   * 'Restoring', 'Completed'
   */
  state: State;
  /**
   * @member {number} [flags] A bitwise-OR of the following values, which gives
   * additional details about the status of the repair task.
   * - 1 - Cancellation of the repair has been requested
   * - 2 - Abort of the repair has been requested
   * - 4 - Approval of the repair was forced via client request
   */
  flags?: number;
  /**
   * @member {string} action The requested repair action. Must be specified
   * when the repair task is created, and is immutable once set.
   */
  action: string;
  /**
   * @member {RepairTargetDescriptionBaseUnion} [target] The target object
   * determines what actions the system will take to prepare for the impact of
   * the repair, prior to approving execution of the repair.
   * May be set when the repair task is created, and is immutable once set.
   */
  target?: RepairTargetDescriptionBaseUnion;
  /**
   * @member {string} [executor] The name of the repair executor. Must be
   * specified in Claimed and later states, and is immutable once set.
   */
  executor?: string;
  /**
   * @member {string} [executorData] A data string that the repair executor can
   * use to store its internal state.
   */
  executorData?: string;
  /**
   * @member {RepairImpactDescriptionBaseUnion} [impact] The impact object
   * determines what actions the system will take to prepare for the impact of
   * the repair, prior to approving execution of the repair.
   * Impact must be specified by the repair executor when transitioning to the
   * Preparing state, and is immutable once set.
   */
  impact?: RepairImpactDescriptionBaseUnion;
  /**
   * @member {ResultStatus} [resultStatus] A value describing the overall
   * result of the repair task execution. Must be specified in the Restoring
   * and later states, and is immutable once set. Possible values include:
   * 'Invalid', 'Succeeded', 'Cancelled', 'Interrupted', 'Failed', 'Pending'
   */
  resultStatus?: ResultStatus;
  /**
   * @member {number} [resultCode] A numeric value providing additional details
   * about the result of the repair task execution.
   * May be specified in the Restoring and later states, and is immutable once
   * set.
   */
  resultCode?: number;
  /**
   * @member {string} [resultDetails] A string providing additional details
   * about the result of the repair task execution.
   * May be specified in the Restoring and later states, and is immutable once
   * set.
   */
  resultDetails?: string;
  /**
   * @member {RepairTaskHistory} [history] An object that contains timestamps
   * of the repair task's state transitions.
   * These timestamps are updated by the system, and cannot be directly
   * modified.
   */
  history?: RepairTaskHistory;
  /**
   * @member {RepairTaskHealthCheckState} [preparingHealthCheckState] The
   * workflow state of the health check when the repair task is in the
   * Preparing state. Possible values include: 'NotStarted', 'InProgress',
   * 'Succeeded', 'Skipped', 'TimedOut'
   */
  preparingHealthCheckState?: RepairTaskHealthCheckState;
  /**
   * @member {RepairTaskHealthCheckState} [restoringHealthCheckState] The
   * workflow state of the health check when the repair task is in the
   * Restoring state. Possible values include: 'NotStarted', 'InProgress',
   * 'Succeeded', 'Skipped', 'TimedOut'
   */
  restoringHealthCheckState?: RepairTaskHealthCheckState;
  /**
   * @member {boolean} [performPreparingHealthCheck] A value to determine if
   * health checks will be performed when the repair task enters the Preparing
   * state.
   */
  performPreparingHealthCheck?: boolean;
  /**
   * @member {boolean} [performRestoringHealthCheck] A value to determine if
   * health checks will be performed when the repair task enters the Restoring
   * state.
   */
  performRestoringHealthCheck?: boolean;
}

/**
 * @interface
 * An interface representing RepairTaskApproveDescription.
 * Describes a request for forced approval of a repair task.
 *
 * This type supports the Service Fabric platform; it is not meant to be used
 * directly from your code.
 *
 */
export interface RepairTaskApproveDescription {
  /**
   * @member {string} taskId The ID of the repair task.
   */
  taskId: string;
  /**
   * @member {string} [version] The current version number of the repair task.
   * If non-zero, then the request will only succeed if this value matches the
   * actual current version of the repair task. If zero, then no version check
   * is performed.
   */
  version?: string;
}

/**
 * @interface
 * An interface representing RepairTaskCancelDescription.
 * Describes a request to cancel a repair task.
 *
 * This type supports the Service Fabric platform; it is not meant to be used
 * directly from your code.
 *
 */
export interface RepairTaskCancelDescription {
  /**
   * @member {string} taskId The ID of the repair task.
   */
  taskId: string;
  /**
   * @member {string} [version] The current version number of the repair task.
   * If non-zero, then the request will only succeed if this value matches the
   * actual current version of the repair task. If zero, then no version check
   * is performed.
   */
  version?: string;
  /**
   * @member {boolean} [requestAbort] _True_ if the repair should be stopped as
   * soon as possible even if it has already started executing. _False_ if the
   * repair should be cancelled only if execution has not yet started.
   */
  requestAbort?: boolean;
}

/**
 * @interface
 * An interface representing RepairTaskDeleteDescription.
 * Describes a request to delete a completed repair task.
 *
 * This type supports the Service Fabric platform; it is not meant to be used
 * directly from your code.
 *
 */
export interface RepairTaskDeleteDescription {
  /**
   * @member {string} taskId The ID of the completed repair task to be deleted.
   */
  taskId: string;
  /**
   * @member {string} [version] The current version number of the repair task.
   * If non-zero, then the request will only succeed if this value matches the
   * actual current version of the repair task. If zero, then no version check
   * is performed.
   */
  version?: string;
}

/**
 * @interface
 * An interface representing RepairTaskUpdateHealthPolicyDescription.
 * Describes a request to update the health policy of a repair task.
 *
 * This type supports the Service Fabric platform; it is not meant to be used
 * directly from your code.
 *
 */
export interface RepairTaskUpdateHealthPolicyDescription {
  /**
   * @member {string} taskId The ID of the repair task to be updated.
   */
  taskId: string;
  /**
   * @member {string} [version] The current version number of the repair task.
   * If non-zero, then the request will only succeed if this value matches the
   * actual current value of the repair task. If zero, then no version check is
   * performed.
   */
  version?: string;
  /**
   * @member {boolean} [performPreparingHealthCheck] A boolean indicating if
   * health check is to be performed in the Preparing stage of the repair task.
   * If not specified the existing value should not be altered. Otherwise,
   * specify the desired new value.
   */
  performPreparingHealthCheck?: boolean;
  /**
   * @member {boolean} [performRestoringHealthCheck] A boolean indicating if
   * health check is to be performed in the Restoring stage of the repair task.
   * If not specified the existing value should not be altered. Otherwise,
   * specify the desired new value.
   */
  performRestoringHealthCheck?: boolean;
}

/**
 * @interface
 * An interface representing RepairTaskUpdateInfo.
 * Describes the result of an operation that created or updated a repair task.
 *
 * This type supports the Service Fabric platform; it is not meant to be used
 * directly from your code.
 *
 */
export interface RepairTaskUpdateInfo {
  /**
   * @member {string} version The new version of the repair task.
   */
  version: string;
}

/**
 * @interface
 * An interface representing UploadChunkRange.
 * Information about which portion of the file to upload.
 *
 */
export interface UploadChunkRange {
  /**
   * @member {string} [startPosition] The start position of the portion of the
   * file. It's represented by the number of bytes.
   */
  startPosition?: string;
  /**
   * @member {string} [endPosition] The end position of the portion of the
   * file. It's represented by the number of bytes.
   */
  endPosition?: string;
}

/**
 * @interface
 * An interface representing UploadSessionInfo.
 * Information about an image store upload session. A session is associated
 * with a relative path in the image store.
 *
 */
export interface UploadSessionInfo {
  /**
   * @member {string} [storeRelativePath] The remote location within image
   * store. This path is relative to the image store root.
   */
  storeRelativePath?: string;
  /**
   * @member {string} [sessionId] A unique ID of the upload session. A session
   * ID can be reused only if the session was committed or removed.
   */
  sessionId?: string;
  /**
   * @member {Date} [modifiedDate] The date and time when the upload session
   * was last modified.
   */
  modifiedDate?: Date;
  /**
   * @member {string} [fileSize] The size in bytes of the uploading file.
   */
  fileSize?: string;
  /**
   * @member {UploadChunkRange[]} [expectedRanges] List of chunk ranges that
   * image store has not received yet.
   */
  expectedRanges?: UploadChunkRange[];
}

/**
 * @interface
 * An interface representing UploadSession.
 * Information about a image store upload session
 *
 */
export interface UploadSession {
  /**
   * @member {UploadSessionInfo[]} [uploadSessions] When querying upload
   * session by upload session ID, the result contains only one upload session.
   * When querying upload session by image store relative path, the result
   * might contain multiple upload sessions.
   */
  uploadSessions?: UploadSessionInfo[];
}

/**
 * @interface
 * An interface representing ContainerLogs.
 * Container logs.
 *
 */
export interface ContainerLogs {
  /**
   * @member {string} [content] Container logs.
   */
  content?: string;
}

/**
 * @interface
 * An interface representing AveragePartitionLoadScalingTrigger.
 * Represents a scaling trigger related to an average load of a metric/resource
 * of a partition.
 *
 */
export interface AveragePartitionLoadScalingTrigger {
  /**
   * @member {string} kind Polymorphic Discriminator
   */
  kind: "AveragePartitionLoad";
  /**
   * @member {string} metricName The name of the metric for which usage should
   * be tracked.
   */
  metricName: string;
  /**
   * @member {string} lowerLoadThreshold The lower limit of the load below
   * which a scale in operation should be performed.
   */
  lowerLoadThreshold: string;
  /**
   * @member {string} upperLoadThreshold The upper limit of the load beyond
   * which a scale out operation should be performed.
   */
  upperLoadThreshold: string;
  /**
   * @member {number} scaleIntervalInSeconds The period in seconds on which a
   * decision is made whether to scale or not.
   */
  scaleIntervalInSeconds: number;
}

/**
 * @interface
 * An interface representing AverageServiceLoadScalingTrigger.
 * Represents a scaling policy related to an average load of a metric/resource
 * of a service.
 *
 */
export interface AverageServiceLoadScalingTrigger {
  /**
   * @member {string} kind Polymorphic Discriminator
   */
  kind: "AverageServiceLoad";
  /**
   * @member {string} metricName The name of the metric for which usage should
   * be tracked.
   */
  metricName: string;
  /**
   * @member {string} lowerLoadThreshold The lower limit of the load below
   * which a scale in operation should be performed.
   */
  lowerLoadThreshold: string;
  /**
   * @member {string} upperLoadThreshold The upper limit of the load beyond
   * which a scale out operation should be performed.
   */
  upperLoadThreshold: string;
  /**
   * @member {number} scaleIntervalInSeconds The period in seconds on which a
   * decision is made whether to scale or not.
   */
  scaleIntervalInSeconds: number;
}

/**
 * @interface
 * An interface representing PartitionInstanceCountScaleMechanism.
 * Represents a scaling mechanism for adding or removing instances of stateless
 * service partition.
 *
 */
export interface PartitionInstanceCountScaleMechanism {
  /**
   * @member {string} kind Polymorphic Discriminator
   */
  kind: "PartitionInstanceCount";
  /**
   * @member {number} minInstanceCount Minimum number of instances of the
   * partition.
   */
  minInstanceCount: number;
  /**
   * @member {number} maxInstanceCount Maximum number of instances of the
   * partition.
   */
  maxInstanceCount: number;
  /**
   * @member {number} scaleIncrement The number of instances to add or remove
   * during a scaling operation.
   */
  scaleIncrement: number;
}

/**
 * @interface
 * An interface representing AddRemoveIncrementalNamedPartitionScalingMechanism.
 * Represents a scaling mechanism for adding or removing named partitions of a
 * stateless service. Partition names are in the format '0','1''N-1'
 *
 */
export interface AddRemoveIncrementalNamedPartitionScalingMechanism {
  /**
   * @member {string} kind Polymorphic Discriminator
   */
  kind: "AddRemoveIncrementalNamedPartition";
  /**
   * @member {number} minPartitionCount Minimum number of named partitions of
   * the service.
   */
  minPartitionCount: number;
  /**
   * @member {number} maxPartitionCount Maximum number of named partitions of
   * the service.
   */
  maxPartitionCount: number;
  /**
   * @member {number} scaleIncrement The number of instances to add or remove
   * during a scaling operation.
   */
  scaleIncrement: number;
}

/**
 * @interface
 * An interface representing ApplicationCreatedEvent.
 * Application Created event.
 *
 */
export interface ApplicationCreatedEvent {
  /**
   * @member {string} kind Polymorphic Discriminator
   */
  kind: "ApplicationCreated";
  /**
   * @member {string} eventInstanceId The identifier for the FabricEvent
   * instance.
   */
  eventInstanceId: string;
  /**
   * @member {Date} timeStamp The time event was logged.
   */
  timeStamp: Date;
  /**
   * @member {boolean} [hasCorrelatedEvents] Shows there is existing related
   * events available.
   */
  hasCorrelatedEvents?: boolean;
  /**
   * @member {string} applicationId The identity of the application. This is an
   * encoded representation of the application name. This is used in the REST
   * APIs to identify the application resource.
   * Starting in version 6.0, hierarchical names are delimited with the "\~"
   * character. For example, if the application name is "fabric:/myapp/app1",
   * the application identity would be "myapp\~app1" in 6.0+ and "myapp/app1"
   * in previous versions.
   */
  applicationId: string;
  /**
   * @member {string} applicationTypeName Application type name.
   */
  applicationTypeName: string;
  /**
   * @member {string} applicationTypeVersion Application type version.
   */
  applicationTypeVersion: string;
  /**
   * @member {string} applicationDefinitionKind Application definition kind.
   */
  applicationDefinitionKind: string;
}

/**
 * @interface
 * An interface representing ApplicationDeletedEvent.
 * Application Deleted event.
 *
 */
export interface ApplicationDeletedEvent {
  /**
   * @member {string} kind Polymorphic Discriminator
   */
  kind: "ApplicationDeleted";
  /**
   * @member {string} eventInstanceId The identifier for the FabricEvent
   * instance.
   */
  eventInstanceId: string;
  /**
   * @member {Date} timeStamp The time event was logged.
   */
  timeStamp: Date;
  /**
   * @member {boolean} [hasCorrelatedEvents] Shows there is existing related
   * events available.
   */
  hasCorrelatedEvents?: boolean;
  /**
   * @member {string} applicationId The identity of the application. This is an
   * encoded representation of the application name. This is used in the REST
   * APIs to identify the application resource.
   * Starting in version 6.0, hierarchical names are delimited with the "\~"
   * character. For example, if the application name is "fabric:/myapp/app1",
   * the application identity would be "myapp\~app1" in 6.0+ and "myapp/app1"
   * in previous versions.
   */
  applicationId: string;
  /**
   * @member {string} applicationTypeName Application type name.
   */
  applicationTypeName: string;
  /**
   * @member {string} applicationTypeVersion Application type version.
   */
  applicationTypeVersion: string;
}

/**
 * @interface
 * An interface representing ApplicationHealthReportCreatedEvent.
 * Application Health Report Created event.
 *
 */
export interface ApplicationHealthReportCreatedEvent {
  /**
   * @member {string} kind Polymorphic Discriminator
   */
  kind: "ApplicationHealthReportCreated";
  /**
   * @member {string} eventInstanceId The identifier for the FabricEvent
   * instance.
   */
  eventInstanceId: string;
  /**
   * @member {Date} timeStamp The time event was logged.
   */
  timeStamp: Date;
  /**
   * @member {boolean} [hasCorrelatedEvents] Shows there is existing related
   * events available.
   */
  hasCorrelatedEvents?: boolean;
  /**
   * @member {string} applicationId The identity of the application. This is an
   * encoded representation of the application name. This is used in the REST
   * APIs to identify the application resource.
   * Starting in version 6.0, hierarchical names are delimited with the "\~"
   * character. For example, if the application name is "fabric:/myapp/app1",
   * the application identity would be "myapp\~app1" in 6.0+ and "myapp/app1"
   * in previous versions.
   */
  applicationId: string;
  /**
   * @member {number} applicationInstanceId Id of Application instance.
   */
  applicationInstanceId: number;
  /**
   * @member {string} sourceId Id of report source.
   */
  sourceId: string;
  /**
   * @member {string} property Describes the property.
   */
  property: string;
  /**
   * @member {string} healthState Describes the property health state.
   */
  healthState: string;
  /**
   * @member {number} timeToLiveMs Time to live in milli-seconds.
   */
  timeToLiveMs: number;
  /**
   * @member {number} sequenceNumber Sequence number of report.
   */
  sequenceNumber: number;
  /**
   * @member {string} description Description of report.
   */
  description: string;
  /**
   * @member {boolean} removeWhenExpired Indicates the removal when it expires.
   */
  removeWhenExpired: boolean;
  /**
   * @member {Date} sourceUtcTimestamp Source time.
   */
  sourceUtcTimestamp: Date;
}

/**
 * @interface
 * An interface representing ApplicationHealthReportExpiredEvent.
 * Application Health Report Expired event.
 *
 */
export interface ApplicationHealthReportExpiredEvent {
  /**
   * @member {string} kind Polymorphic Discriminator
   */
  kind: "ApplicationHealthReportExpired";
  /**
   * @member {string} eventInstanceId The identifier for the FabricEvent
   * instance.
   */
  eventInstanceId: string;
  /**
   * @member {Date} timeStamp The time event was logged.
   */
  timeStamp: Date;
  /**
   * @member {boolean} [hasCorrelatedEvents] Shows there is existing related
   * events available.
   */
  hasCorrelatedEvents?: boolean;
  /**
   * @member {string} applicationId The identity of the application. This is an
   * encoded representation of the application name. This is used in the REST
   * APIs to identify the application resource.
   * Starting in version 6.0, hierarchical names are delimited with the "\~"
   * character. For example, if the application name is "fabric:/myapp/app1",
   * the application identity would be "myapp\~app1" in 6.0+ and "myapp/app1"
   * in previous versions.
   */
  applicationId: string;
  /**
   * @member {number} applicationInstanceId Id of Application instance.
   */
  applicationInstanceId: number;
  /**
   * @member {string} sourceId Id of report source.
   */
  sourceId: string;
  /**
   * @member {string} property Describes the property.
   */
  property: string;
  /**
   * @member {string} healthState Describes the property health state.
   */
  healthState: string;
  /**
   * @member {number} timeToLiveMs Time to live in milli-seconds.
   */
  timeToLiveMs: number;
  /**
   * @member {number} sequenceNumber Sequence number of report.
   */
  sequenceNumber: number;
  /**
   * @member {string} description Description of report.
   */
  description: string;
  /**
   * @member {boolean} removeWhenExpired Indicates the removal when it expires.
   */
  removeWhenExpired: boolean;
  /**
   * @member {Date} sourceUtcTimestamp Source time.
   */
  sourceUtcTimestamp: Date;
}

/**
 * @interface
 * An interface representing ApplicationUpgradeCompleteEvent.
 * Application Upgrade Complete event.
 *
 */
export interface ApplicationUpgradeCompleteEvent {
  /**
   * @member {string} kind Polymorphic Discriminator
   */
  kind: "ApplicationUpgradeComplete";
  /**
   * @member {string} eventInstanceId The identifier for the FabricEvent
   * instance.
   */
  eventInstanceId: string;
  /**
   * @member {Date} timeStamp The time event was logged.
   */
  timeStamp: Date;
  /**
   * @member {boolean} [hasCorrelatedEvents] Shows there is existing related
   * events available.
   */
  hasCorrelatedEvents?: boolean;
  /**
   * @member {string} applicationId The identity of the application. This is an
   * encoded representation of the application name. This is used in the REST
   * APIs to identify the application resource.
   * Starting in version 6.0, hierarchical names are delimited with the "\~"
   * character. For example, if the application name is "fabric:/myapp/app1",
   * the application identity would be "myapp\~app1" in 6.0+ and "myapp/app1"
   * in previous versions.
   */
  applicationId: string;
  /**
   * @member {string} applicationTypeName Application type name.
   */
  applicationTypeName: string;
  /**
   * @member {string} applicationTypeVersion Application type version.
   */
  applicationTypeVersion: string;
  /**
   * @member {number} overallUpgradeElapsedTimeInMs Overall upgrade time in
   * milli-seconds.
   */
  overallUpgradeElapsedTimeInMs: number;
}

/**
 * @interface
 * An interface representing ApplicationUpgradeDomainCompleteEvent.
 * Application Upgrade Domain Complete event.
 *
 */
export interface ApplicationUpgradeDomainCompleteEvent {
  /**
   * @member {string} kind Polymorphic Discriminator
   */
  kind: "ApplicationUpgradeDomainComplete";
  /**
   * @member {string} eventInstanceId The identifier for the FabricEvent
   * instance.
   */
  eventInstanceId: string;
  /**
   * @member {Date} timeStamp The time event was logged.
   */
  timeStamp: Date;
  /**
   * @member {boolean} [hasCorrelatedEvents] Shows there is existing related
   * events available.
   */
  hasCorrelatedEvents?: boolean;
  /**
   * @member {string} applicationId The identity of the application. This is an
   * encoded representation of the application name. This is used in the REST
   * APIs to identify the application resource.
   * Starting in version 6.0, hierarchical names are delimited with the "\~"
   * character. For example, if the application name is "fabric:/myapp/app1",
   * the application identity would be "myapp\~app1" in 6.0+ and "myapp/app1"
   * in previous versions.
   */
  applicationId: string;
  /**
   * @member {string} applicationTypeName Application type name.
   */
  applicationTypeName: string;
  /**
   * @member {string} currentApplicationTypeVersion Current Application type
   * version.
   */
  currentApplicationTypeVersion: string;
  /**
   * @member {string} applicationTypeVersion Target Application type version.
   */
  applicationTypeVersion: string;
  /**
   * @member {string} upgradeState State of upgrade.
   */
  upgradeState: string;
  /**
   * @member {string} upgradeDomains Upgrade domains.
   */
  upgradeDomains: string;
  /**
   * @member {number} upgradeDomainElapsedTimeInMs Upgrade time of domain in
   * milli-seconds.
   */
  upgradeDomainElapsedTimeInMs: number;
}

/**
 * @interface
 * An interface representing ApplicationUpgradeRollbackCompleteEvent.
 * Application Upgrade Rollback Complete event.
 *
 */
export interface ApplicationUpgradeRollbackCompleteEvent {
  /**
   * @member {string} kind Polymorphic Discriminator
   */
  kind: "ApplicationUpgradeRollbackComplete";
  /**
   * @member {string} eventInstanceId The identifier for the FabricEvent
   * instance.
   */
  eventInstanceId: string;
  /**
   * @member {Date} timeStamp The time event was logged.
   */
  timeStamp: Date;
  /**
   * @member {boolean} [hasCorrelatedEvents] Shows there is existing related
   * events available.
   */
  hasCorrelatedEvents?: boolean;
  /**
   * @member {string} applicationId The identity of the application. This is an
   * encoded representation of the application name. This is used in the REST
   * APIs to identify the application resource.
   * Starting in version 6.0, hierarchical names are delimited with the "\~"
   * character. For example, if the application name is "fabric:/myapp/app1",
   * the application identity would be "myapp\~app1" in 6.0+ and "myapp/app1"
   * in previous versions.
   */
  applicationId: string;
  /**
   * @member {string} applicationTypeName Application type name.
   */
  applicationTypeName: string;
  /**
   * @member {string} applicationTypeVersion Application type version.
   */
  applicationTypeVersion: string;
  /**
   * @member {string} failureReason Describes reason of failure.
   */
  failureReason: string;
  /**
   * @member {number} overallUpgradeElapsedTimeInMs Overall upgrade time in
   * milli-seconds.
   */
  overallUpgradeElapsedTimeInMs: number;
}

/**
 * @interface
 * An interface representing ApplicationUpgradeRollbackStartEvent.
 * Application Upgrade Rollback Start event.
 *
 */
export interface ApplicationUpgradeRollbackStartEvent {
  /**
   * @member {string} kind Polymorphic Discriminator
   */
  kind: "ApplicationUpgradeRollbackStart";
  /**
   * @member {string} eventInstanceId The identifier for the FabricEvent
   * instance.
   */
  eventInstanceId: string;
  /**
   * @member {Date} timeStamp The time event was logged.
   */
  timeStamp: Date;
  /**
   * @member {boolean} [hasCorrelatedEvents] Shows there is existing related
   * events available.
   */
  hasCorrelatedEvents?: boolean;
  /**
   * @member {string} applicationId The identity of the application. This is an
   * encoded representation of the application name. This is used in the REST
   * APIs to identify the application resource.
   * Starting in version 6.0, hierarchical names are delimited with the "\~"
   * character. For example, if the application name is "fabric:/myapp/app1",
   * the application identity would be "myapp\~app1" in 6.0+ and "myapp/app1"
   * in previous versions.
   */
  applicationId: string;
  /**
   * @member {string} applicationTypeName Application type name.
   */
  applicationTypeName: string;
  /**
   * @member {string} currentApplicationTypeVersion Current Application type
   * version.
   */
  currentApplicationTypeVersion: string;
  /**
   * @member {string} applicationTypeVersion Target Application type version.
   */
  applicationTypeVersion: string;
  /**
   * @member {string} failureReason Describes reason of failure.
   */
  failureReason: string;
  /**
   * @member {number} overallUpgradeElapsedTimeInMs Overall upgrade time in
   * milli-seconds.
   */
  overallUpgradeElapsedTimeInMs: number;
}

/**
 * @interface
 * An interface representing ApplicationUpgradeStartEvent.
 * Application Upgrade Start event.
 *
 */
export interface ApplicationUpgradeStartEvent {
  /**
   * @member {string} kind Polymorphic Discriminator
   */
  kind: "ApplicationUpgradeStart";
  /**
   * @member {string} eventInstanceId The identifier for the FabricEvent
   * instance.
   */
  eventInstanceId: string;
  /**
   * @member {Date} timeStamp The time event was logged.
   */
  timeStamp: Date;
  /**
   * @member {boolean} [hasCorrelatedEvents] Shows there is existing related
   * events available.
   */
  hasCorrelatedEvents?: boolean;
  /**
   * @member {string} applicationId The identity of the application. This is an
   * encoded representation of the application name. This is used in the REST
   * APIs to identify the application resource.
   * Starting in version 6.0, hierarchical names are delimited with the "\~"
   * character. For example, if the application name is "fabric:/myapp/app1",
   * the application identity would be "myapp\~app1" in 6.0+ and "myapp/app1"
   * in previous versions.
   */
  applicationId: string;
  /**
   * @member {string} applicationTypeName Application type name.
   */
  applicationTypeName: string;
  /**
   * @member {string} currentApplicationTypeVersion Current Application type
   * version.
   */
  currentApplicationTypeVersion: string;
  /**
   * @member {string} applicationTypeVersion Target Application type version.
   */
  applicationTypeVersion: string;
  /**
   * @member {string} upgradeType Type of upgrade.
   */
  upgradeType: string;
  /**
   * @member {string} rollingUpgradeMode Mode of upgrade.
   */
  rollingUpgradeMode: string;
  /**
   * @member {string} failureAction Action if failed.
   */
  failureAction: string;
}

/**
 * @interface
 * An interface representing DeployedApplicationHealthReportCreatedEvent.
 * Deployed Application Health Report Created event.
 *
 */
export interface DeployedApplicationHealthReportCreatedEvent {
  /**
   * @member {string} kind Polymorphic Discriminator
   */
  kind: "DeployedApplicationHealthReportCreated";
  /**
   * @member {string} eventInstanceId The identifier for the FabricEvent
   * instance.
   */
  eventInstanceId: string;
  /**
   * @member {Date} timeStamp The time event was logged.
   */
  timeStamp: Date;
  /**
   * @member {boolean} [hasCorrelatedEvents] Shows there is existing related
   * events available.
   */
  hasCorrelatedEvents?: boolean;
  /**
   * @member {string} applicationId The identity of the application. This is an
   * encoded representation of the application name. This is used in the REST
   * APIs to identify the application resource.
   * Starting in version 6.0, hierarchical names are delimited with the "\~"
   * character. For example, if the application name is "fabric:/myapp/app1",
   * the application identity would be "myapp\~app1" in 6.0+ and "myapp/app1"
   * in previous versions.
   */
  applicationId: string;
  /**
   * @member {number} applicationInstanceId Id of Application instance.
   */
  applicationInstanceId: number;
  /**
   * @member {string} nodeName The name of a Service Fabric node.
   */
  nodeName: string;
  /**
   * @member {string} sourceId Id of report source.
   */
  sourceId: string;
  /**
   * @member {string} property Describes the property.
   */
  property: string;
  /**
   * @member {string} healthState Describes the property health state.
   */
  healthState: string;
  /**
   * @member {number} timeToLiveMs Time to live in milli-seconds.
   */
  timeToLiveMs: number;
  /**
   * @member {number} sequenceNumber Sequence number of report.
   */
  sequenceNumber: number;
  /**
   * @member {string} description Description of report.
   */
  description: string;
  /**
   * @member {boolean} removeWhenExpired Indicates the removal when it expires.
   */
  removeWhenExpired: boolean;
  /**
   * @member {Date} sourceUtcTimestamp Source time.
   */
  sourceUtcTimestamp: Date;
}

/**
 * @interface
 * An interface representing DeployedApplicationHealthReportExpiredEvent.
 * Deployed Application Health Report Expired event.
 *
 */
export interface DeployedApplicationHealthReportExpiredEvent {
  /**
   * @member {string} kind Polymorphic Discriminator
   */
  kind: "DeployedApplicationHealthReportExpired";
  /**
   * @member {string} eventInstanceId The identifier for the FabricEvent
   * instance.
   */
  eventInstanceId: string;
  /**
   * @member {Date} timeStamp The time event was logged.
   */
  timeStamp: Date;
  /**
   * @member {boolean} [hasCorrelatedEvents] Shows there is existing related
   * events available.
   */
  hasCorrelatedEvents?: boolean;
  /**
   * @member {string} applicationId The identity of the application. This is an
   * encoded representation of the application name. This is used in the REST
   * APIs to identify the application resource.
   * Starting in version 6.0, hierarchical names are delimited with the "\~"
   * character. For example, if the application name is "fabric:/myapp/app1",
   * the application identity would be "myapp\~app1" in 6.0+ and "myapp/app1"
   * in previous versions.
   */
  applicationId: string;
  /**
   * @member {number} applicationInstanceId Id of Application instance.
   */
  applicationInstanceId: number;
  /**
   * @member {string} nodeName The name of a Service Fabric node.
   */
  nodeName: string;
  /**
   * @member {string} sourceId Id of report source.
   */
  sourceId: string;
  /**
   * @member {string} property Describes the property.
   */
  property: string;
  /**
   * @member {string} healthState Describes the property health state.
   */
  healthState: string;
  /**
   * @member {number} timeToLiveMs Time to live in milli-seconds.
   */
  timeToLiveMs: number;
  /**
   * @member {number} sequenceNumber Sequence number of report.
   */
  sequenceNumber: number;
  /**
   * @member {string} description Description of report.
   */
  description: string;
  /**
   * @member {boolean} removeWhenExpired Indicates the removal when it expires.
   */
  removeWhenExpired: boolean;
  /**
   * @member {Date} sourceUtcTimestamp Source time.
   */
  sourceUtcTimestamp: Date;
}

/**
 * @interface
 * An interface representing ProcessDeactivatedEvent.
 * Process Deactivated event.
 *
 */
export interface ProcessDeactivatedEvent {
  /**
   * @member {string} kind Polymorphic Discriminator
   */
  kind: "ProcessDeactivated";
  /**
   * @member {string} eventInstanceId The identifier for the FabricEvent
   * instance.
   */
  eventInstanceId: string;
  /**
   * @member {Date} timeStamp The time event was logged.
   */
  timeStamp: Date;
  /**
   * @member {boolean} [hasCorrelatedEvents] Shows there is existing related
   * events available.
   */
  hasCorrelatedEvents?: boolean;
  /**
   * @member {string} applicationId The identity of the application. This is an
   * encoded representation of the application name. This is used in the REST
   * APIs to identify the application resource.
   * Starting in version 6.0, hierarchical names are delimited with the "\~"
   * character. For example, if the application name is "fabric:/myapp/app1",
   * the application identity would be "myapp\~app1" in 6.0+ and "myapp/app1"
   * in previous versions.
   */
  applicationId: string;
  /**
   * @member {string} serviceName Name of Service.
   */
  serviceName: string;
  /**
   * @member {string} servicePackageName Name of Service package.
   */
  servicePackageName: string;
  /**
   * @member {string} servicePackageActivationId Activation Id of Service
   * package.
   */
  servicePackageActivationId: string;
  /**
   * @member {boolean} isExclusive Indicates IsExclusive flag.
   */
  isExclusive: boolean;
  /**
   * @member {string} codePackageName Name of Code package.
   */
  codePackageName: string;
  /**
   * @member {string} entryPointType Type of EntryPoint.
   */
  entryPointType: string;
  /**
   * @member {string} exeName Name of executable.
   */
  exeName: string;
  /**
   * @member {number} processId Process Id.
   */
  processId: number;
  /**
   * @member {string} hostId Host Id.
   */
  hostId: string;
  /**
   * @member {number} exitCode Exit code of process.
   */
  exitCode: number;
  /**
   * @member {boolean} unexpectedTermination Indicates if termination is
   * unexpected.
   */
  unexpectedTermination: boolean;
  /**
   * @member {Date} startTime Start time of process.
   */
  startTime: Date;
}

/**
 * @interface
 * An interface representing ContainerDeactivatedEvent.
 * Container Deactivated event.
 *
 */
export interface ContainerDeactivatedEvent {
  /**
   * @member {string} kind Polymorphic Discriminator
   */
  kind: "ContainerDeactivated";
  /**
   * @member {string} eventInstanceId The identifier for the FabricEvent
   * instance.
   */
  eventInstanceId: string;
  /**
   * @member {Date} timeStamp The time event was logged.
   */
  timeStamp: Date;
  /**
   * @member {boolean} [hasCorrelatedEvents] Shows there is existing related
   * events available.
   */
  hasCorrelatedEvents?: boolean;
  /**
   * @member {string} applicationId The identity of the application. This is an
   * encoded representation of the application name. This is used in the REST
   * APIs to identify the application resource.
   * Starting in version 6.0, hierarchical names are delimited with the "\~"
   * character. For example, if the application name is "fabric:/myapp/app1",
   * the application identity would be "myapp\~app1" in 6.0+ and "myapp/app1"
   * in previous versions.
   */
  applicationId: string;
  /**
   * @member {string} serviceName Name of Service.
   */
  serviceName: string;
  /**
   * @member {string} servicePackageName Name of Service package.
   */
  servicePackageName: string;
  /**
   * @member {string} servicePackageActivationId Activation Id of Service
   * package.
   */
  servicePackageActivationId: string;
  /**
   * @member {boolean} isExclusive Indicates IsExclusive flag.
   */
  isExclusive: boolean;
  /**
   * @member {string} codePackageName Name of Code package.
   */
  codePackageName: string;
  /**
   * @member {string} entryPointType Type of EntryPoint.
   */
  entryPointType: string;
  /**
   * @member {string} imageName Name of Container image.
   */
  imageName: string;
  /**
   * @member {string} containerName Name of Container.
   */
  containerName: string;
  /**
   * @member {string} hostId Host Id.
   */
  hostId: string;
  /**
   * @member {number} exitCode Exit code of process.
   */
  exitCode: number;
  /**
   * @member {boolean} unexpectedTermination Indicates if termination is
   * unexpected.
   */
  unexpectedTermination: boolean;
  /**
   * @member {Date} startTime Start time of process.
   */
  startTime: Date;
}

/**
 * @interface
 * An interface representing NodeAbortedEvent.
 * Node Aborted event.
 *
 */
export interface NodeAbortedEvent {
  /**
   * @member {string} kind Polymorphic Discriminator
   */
  kind: "NodeAborted";
  /**
   * @member {string} eventInstanceId The identifier for the FabricEvent
   * instance.
   */
  eventInstanceId: string;
  /**
   * @member {Date} timeStamp The time event was logged.
   */
  timeStamp: Date;
  /**
   * @member {boolean} [hasCorrelatedEvents] Shows there is existing related
   * events available.
   */
  hasCorrelatedEvents?: boolean;
  /**
   * @member {string} nodeName The name of a Service Fabric node.
   */
  nodeName: string;
  /**
   * @member {number} nodeInstance Id of Node instance.
   */
  nodeInstance: number;
  /**
   * @member {string} nodeId Id of Node.
   */
  nodeId: string;
  /**
   * @member {string} upgradeDomain Upgrade domain of Node.
   */
  upgradeDomain: string;
  /**
   * @member {string} faultDomain Fault domain of Node.
   */
  faultDomain: string;
  /**
   * @member {string} ipAddressOrFQDN IP address or FQDN.
   */
  ipAddressOrFQDN: string;
  /**
   * @member {string} hostname Name of Host.
   */
  hostname: string;
  /**
   * @member {boolean} isSeedNode Indicates if it is seed node.
   */
  isSeedNode: boolean;
  /**
   * @member {string} nodeVersion Version of Node.
   */
  nodeVersion: string;
}

/**
 * @interface
 * An interface representing NodeAbortingEvent.
 * Node Aborting event.
 *
 */
export interface NodeAbortingEvent {
  /**
   * @member {string} kind Polymorphic Discriminator
   */
  kind: "NodeAborting";
  /**
   * @member {string} eventInstanceId The identifier for the FabricEvent
   * instance.
   */
  eventInstanceId: string;
  /**
   * @member {Date} timeStamp The time event was logged.
   */
  timeStamp: Date;
  /**
   * @member {boolean} [hasCorrelatedEvents] Shows there is existing related
   * events available.
   */
  hasCorrelatedEvents?: boolean;
  /**
   * @member {string} nodeName The name of a Service Fabric node.
   */
  nodeName: string;
  /**
   * @member {number} nodeInstance Id of Node instance.
   */
  nodeInstance: number;
  /**
   * @member {string} nodeId Id of Node.
   */
  nodeId: string;
  /**
   * @member {string} upgradeDomain Upgrade domain of Node.
   */
  upgradeDomain: string;
  /**
   * @member {string} faultDomain Fault domain of Node.
   */
  faultDomain: string;
  /**
   * @member {string} ipAddressOrFQDN IP address or FQDN.
   */
  ipAddressOrFQDN: string;
  /**
   * @member {string} hostname Name of Host.
   */
  hostname: string;
  /**
   * @member {boolean} isSeedNode Indicates if it is seed node.
   */
  isSeedNode: boolean;
  /**
   * @member {string} nodeVersion Version of Node.
   */
  nodeVersion: string;
}

/**
 * @interface
 * An interface representing NodeAddedEvent.
 * Node Added event.
 *
 */
export interface NodeAddedEvent {
  /**
   * @member {string} kind Polymorphic Discriminator
   */
  kind: "NodeAdded";
  /**
   * @member {string} eventInstanceId The identifier for the FabricEvent
   * instance.
   */
  eventInstanceId: string;
  /**
   * @member {Date} timeStamp The time event was logged.
   */
  timeStamp: Date;
  /**
   * @member {boolean} [hasCorrelatedEvents] Shows there is existing related
   * events available.
   */
  hasCorrelatedEvents?: boolean;
  /**
   * @member {string} nodeName The name of a Service Fabric node.
   */
  nodeName: string;
  /**
   * @member {string} nodeId Id of Node.
   */
  nodeId: string;
  /**
   * @member {number} nodeInstance Id of Node instance.
   */
  nodeInstance: number;
  /**
   * @member {string} nodeType Type of Node.
   */
  nodeType: string;
  /**
   * @member {string} fabricVersion Fabric version.
   */
  fabricVersion: string;
  /**
   * @member {string} ipAddressOrFQDN IP address or FQDN.
   */
  ipAddressOrFQDN: string;
  /**
   * @member {string} nodeCapacities Capacities.
   */
  nodeCapacities: string;
}

/**
 * @interface
 * An interface representing NodeCloseEvent.
 * Node Close event.
 *
 */
export interface NodeCloseEvent {
  /**
   * @member {string} kind Polymorphic Discriminator
   */
  kind: "NodeClose";
  /**
   * @member {string} eventInstanceId The identifier for the FabricEvent
   * instance.
   */
  eventInstanceId: string;
  /**
   * @member {Date} timeStamp The time event was logged.
   */
  timeStamp: Date;
  /**
   * @member {boolean} [hasCorrelatedEvents] Shows there is existing related
   * events available.
   */
  hasCorrelatedEvents?: boolean;
  /**
   * @member {string} nodeName The name of a Service Fabric node.
   */
  nodeName: string;
  /**
   * @member {string} nodeId Id of Node.
   */
  nodeId: string;
  /**
   * @member {string} nodeInstance Id of Node instance.
   */
  nodeInstance: string;
  /**
   * @member {string} error Describes error.
   */
  error: string;
}

/**
 * @interface
 * An interface representing NodeClosingEvent.
 * Node Closing event.
 *
 */
export interface NodeClosingEvent {
  /**
   * @member {string} kind Polymorphic Discriminator
   */
  kind: "NodeClosing";
  /**
   * @member {string} eventInstanceId The identifier for the FabricEvent
   * instance.
   */
  eventInstanceId: string;
  /**
   * @member {Date} timeStamp The time event was logged.
   */
  timeStamp: Date;
  /**
   * @member {boolean} [hasCorrelatedEvents] Shows there is existing related
   * events available.
   */
  hasCorrelatedEvents?: boolean;
  /**
   * @member {string} nodeName The name of a Service Fabric node.
   */
  nodeName: string;
  /**
   * @member {number} nodeInstance Id of Node instance.
   */
  nodeInstance: number;
  /**
   * @member {string} nodeId Id of Node.
   */
  nodeId: string;
  /**
   * @member {string} upgradeDomain Upgrade domain of Node.
   */
  upgradeDomain: string;
  /**
   * @member {string} faultDomain Fault domain of Node.
   */
  faultDomain: string;
  /**
   * @member {string} ipAddressOrFQDN IP address or FQDN.
   */
  ipAddressOrFQDN: string;
  /**
   * @member {string} hostname Name of Host.
   */
  hostname: string;
  /**
   * @member {boolean} isSeedNode Indicates if it is seed node.
   */
  isSeedNode: boolean;
  /**
   * @member {string} nodeVersion Version of Node.
   */
  nodeVersion: string;
}

/**
 * @interface
 * An interface representing NodeDeactivateCompleteEvent.
 * Node Deactivate Complete event.
 *
 */
export interface NodeDeactivateCompleteEvent {
  /**
   * @member {string} kind Polymorphic Discriminator
   */
  kind: "NodeDeactivateComplete";
  /**
   * @member {string} eventInstanceId The identifier for the FabricEvent
   * instance.
   */
  eventInstanceId: string;
  /**
   * @member {Date} timeStamp The time event was logged.
   */
  timeStamp: Date;
  /**
   * @member {boolean} [hasCorrelatedEvents] Shows there is existing related
   * events available.
   */
  hasCorrelatedEvents?: boolean;
  /**
   * @member {string} nodeName The name of a Service Fabric node.
   */
  nodeName: string;
  /**
   * @member {number} nodeInstance Id of Node instance.
   */
  nodeInstance: number;
  /**
   * @member {string} effectiveDeactivateIntent Describes deactivate intent.
   */
  effectiveDeactivateIntent: string;
  /**
   * @member {string} batchIdsWithDeactivateIntent Batch Ids.
   */
  batchIdsWithDeactivateIntent: string;
  /**
   * @member {Date} startTime Start time.
   */
  startTime: Date;
}

/**
 * @interface
 * An interface representing NodeDeactivateStartEvent.
 * Node Deactivate Start event.
 *
 */
export interface NodeDeactivateStartEvent {
  /**
   * @member {string} kind Polymorphic Discriminator
   */
  kind: "NodeDeactivateStart";
  /**
   * @member {string} eventInstanceId The identifier for the FabricEvent
   * instance.
   */
  eventInstanceId: string;
  /**
   * @member {Date} timeStamp The time event was logged.
   */
  timeStamp: Date;
  /**
   * @member {boolean} [hasCorrelatedEvents] Shows there is existing related
   * events available.
   */
  hasCorrelatedEvents?: boolean;
  /**
   * @member {string} nodeName The name of a Service Fabric node.
   */
  nodeName: string;
  /**
   * @member {number} nodeInstance Id of Node instance.
   */
  nodeInstance: number;
  /**
   * @member {string} batchId Batch Id.
   */
  batchId: string;
  /**
   * @member {string} deactivateIntent Describes deactivate intent.
   */
  deactivateIntent: string;
}

/**
 * @interface
 * An interface representing NodeDownEvent.
 * Node Down event.
 *
 */
export interface NodeDownEvent {
  /**
   * @member {string} kind Polymorphic Discriminator
   */
  kind: "NodeDown";
  /**
   * @member {string} eventInstanceId The identifier for the FabricEvent
   * instance.
   */
  eventInstanceId: string;
  /**
   * @member {Date} timeStamp The time event was logged.
   */
  timeStamp: Date;
  /**
   * @member {boolean} [hasCorrelatedEvents] Shows there is existing related
   * events available.
   */
  hasCorrelatedEvents?: boolean;
  /**
   * @member {string} nodeName The name of a Service Fabric node.
   */
  nodeName: string;
  /**
   * @member {number} nodeInstance Id of Node instance.
   */
  nodeInstance: number;
  /**
   * @member {Date} lastNodeUpAt Time when Node was last up.
   */
  lastNodeUpAt: Date;
}

/**
 * @interface
 * An interface representing NodeHealthReportCreatedEvent.
 * Node Health Report Created event.
 *
 */
export interface NodeHealthReportCreatedEvent {
  /**
   * @member {string} kind Polymorphic Discriminator
   */
  kind: "NodeHealthReportCreated";
  /**
   * @member {string} eventInstanceId The identifier for the FabricEvent
   * instance.
   */
  eventInstanceId: string;
  /**
   * @member {Date} timeStamp The time event was logged.
   */
  timeStamp: Date;
  /**
   * @member {boolean} [hasCorrelatedEvents] Shows there is existing related
   * events available.
   */
  hasCorrelatedEvents?: boolean;
  /**
   * @member {string} nodeName The name of a Service Fabric node.
   */
  nodeName: string;
  /**
   * @member {number} nodeInstanceId Id of Node instance.
   */
  nodeInstanceId: number;
  /**
   * @member {string} sourceId Id of report source.
   */
  sourceId: string;
  /**
   * @member {string} property Describes the property.
   */
  property: string;
  /**
   * @member {string} healthState Describes the property health state.
   */
  healthState: string;
  /**
   * @member {number} timeToLiveMs Time to live in milli-seconds.
   */
  timeToLiveMs: number;
  /**
   * @member {number} sequenceNumber Sequence number of report.
   */
  sequenceNumber: number;
  /**
   * @member {string} description Description of report.
   */
  description: string;
  /**
   * @member {boolean} removeWhenExpired Indicates the removal when it expires.
   */
  removeWhenExpired: boolean;
  /**
   * @member {Date} sourceUtcTimestamp Source time.
   */
  sourceUtcTimestamp: Date;
}

/**
 * @interface
 * An interface representing NodeHealthReportExpiredEvent.
 * Node Health Report Expired event.
 *
 */
export interface NodeHealthReportExpiredEvent {
  /**
   * @member {string} kind Polymorphic Discriminator
   */
  kind: "NodeHealthReportExpired";
  /**
   * @member {string} eventInstanceId The identifier for the FabricEvent
   * instance.
   */
  eventInstanceId: string;
  /**
   * @member {Date} timeStamp The time event was logged.
   */
  timeStamp: Date;
  /**
   * @member {boolean} [hasCorrelatedEvents] Shows there is existing related
   * events available.
   */
  hasCorrelatedEvents?: boolean;
  /**
   * @member {string} nodeName The name of a Service Fabric node.
   */
  nodeName: string;
  /**
   * @member {number} nodeInstanceId Id of Node instance.
   */
  nodeInstanceId: number;
  /**
   * @member {string} sourceId Id of report source.
   */
  sourceId: string;
  /**
   * @member {string} property Describes the property.
   */
  property: string;
  /**
   * @member {string} healthState Describes the property health state.
   */
  healthState: string;
  /**
   * @member {number} timeToLiveMs Time to live in milli-seconds.
   */
  timeToLiveMs: number;
  /**
   * @member {number} sequenceNumber Sequence number of report.
   */
  sequenceNumber: number;
  /**
   * @member {string} description Description of report.
   */
  description: string;
  /**
   * @member {boolean} removeWhenExpired Indicates the removal when it expires.
   */
  removeWhenExpired: boolean;
  /**
   * @member {Date} sourceUtcTimestamp Source time.
   */
  sourceUtcTimestamp: Date;
}

/**
 * @interface
 * An interface representing NodeOpenedSuccessEvent.
 * Node Opened Success event.
 *
 */
export interface NodeOpenedSuccessEvent {
  /**
   * @member {string} kind Polymorphic Discriminator
   */
  kind: "NodeOpenedSuccess";
  /**
   * @member {string} eventInstanceId The identifier for the FabricEvent
   * instance.
   */
  eventInstanceId: string;
  /**
   * @member {Date} timeStamp The time event was logged.
   */
  timeStamp: Date;
  /**
   * @member {boolean} [hasCorrelatedEvents] Shows there is existing related
   * events available.
   */
  hasCorrelatedEvents?: boolean;
  /**
   * @member {string} nodeName The name of a Service Fabric node.
   */
  nodeName: string;
  /**
   * @member {number} nodeInstance Id of Node instance.
   */
  nodeInstance: number;
  /**
   * @member {string} nodeId Id of Node.
   */
  nodeId: string;
  /**
   * @member {string} upgradeDomain Upgrade domain of Node.
   */
  upgradeDomain: string;
  /**
   * @member {string} faultDomain Fault domain of Node.
   */
  faultDomain: string;
  /**
   * @member {string} ipAddressOrFQDN IP address or FQDN.
   */
  ipAddressOrFQDN: string;
  /**
   * @member {string} hostname Name of Host.
   */
  hostname: string;
  /**
   * @member {boolean} isSeedNode Indicates if it is seed node.
   */
  isSeedNode: boolean;
  /**
   * @member {string} nodeVersion Version of Node.
   */
  nodeVersion: string;
}

/**
 * @interface
 * An interface representing NodeOpenFailedEvent.
 * Node Open Failed event.
 *
 */
export interface NodeOpenFailedEvent {
  /**
   * @member {string} kind Polymorphic Discriminator
   */
  kind: "NodeOpenFailed";
  /**
   * @member {string} eventInstanceId The identifier for the FabricEvent
   * instance.
   */
  eventInstanceId: string;
  /**
   * @member {Date} timeStamp The time event was logged.
   */
  timeStamp: Date;
  /**
   * @member {boolean} [hasCorrelatedEvents] Shows there is existing related
   * events available.
   */
  hasCorrelatedEvents?: boolean;
  /**
   * @member {string} nodeName The name of a Service Fabric node.
   */
  nodeName: string;
  /**
   * @member {number} nodeInstance Id of Node instance.
   */
  nodeInstance: number;
  /**
   * @member {string} nodeId Id of Node.
   */
  nodeId: string;
  /**
   * @member {string} upgradeDomain Upgrade domain of Node.
   */
  upgradeDomain: string;
  /**
   * @member {string} faultDomain Fault domain of Node.
   */
  faultDomain: string;
  /**
   * @member {string} ipAddressOrFQDN IP address or FQDN.
   */
  ipAddressOrFQDN: string;
  /**
   * @member {string} hostname Name of Host.
   */
  hostname: string;
  /**
   * @member {boolean} isSeedNode Indicates if it is seed node.
   */
  isSeedNode: boolean;
  /**
   * @member {string} nodeVersion Version of Node.
   */
  nodeVersion: string;
  /**
   * @member {string} error Describes the error.
   */
  error: string;
}

/**
 * @interface
 * An interface representing NodeOpeningEvent.
 * Node Opening event.
 *
 */
export interface NodeOpeningEvent {
  /**
   * @member {string} kind Polymorphic Discriminator
   */
  kind: "NodeOpening";
  /**
   * @member {string} eventInstanceId The identifier for the FabricEvent
   * instance.
   */
  eventInstanceId: string;
  /**
   * @member {Date} timeStamp The time event was logged.
   */
  timeStamp: Date;
  /**
   * @member {boolean} [hasCorrelatedEvents] Shows there is existing related
   * events available.
   */
  hasCorrelatedEvents?: boolean;
  /**
   * @member {string} nodeName The name of a Service Fabric node.
   */
  nodeName: string;
  /**
   * @member {number} nodeInstance Id of Node instance.
   */
  nodeInstance: number;
  /**
   * @member {string} nodeId Id of Node.
   */
  nodeId: string;
  /**
   * @member {string} upgradeDomain Upgrade domain of Node.
   */
  upgradeDomain: string;
  /**
   * @member {string} faultDomain Fault domain of Node.
   */
  faultDomain: string;
  /**
   * @member {string} ipAddressOrFQDN IP address or FQDN.
   */
  ipAddressOrFQDN: string;
  /**
   * @member {string} hostname Name of Host.
   */
  hostname: string;
  /**
   * @member {boolean} isSeedNode Indicates if it is seed node.
   */
  isSeedNode: boolean;
  /**
   * @member {string} nodeVersion Version of Node.
   */
  nodeVersion: string;
}

/**
 * @interface
 * An interface representing NodeRemovedEvent.
 * Node Removed event.
 *
 */
export interface NodeRemovedEvent {
  /**
   * @member {string} kind Polymorphic Discriminator
   */
  kind: "NodeRemoved";
  /**
   * @member {string} eventInstanceId The identifier for the FabricEvent
   * instance.
   */
  eventInstanceId: string;
  /**
   * @member {Date} timeStamp The time event was logged.
   */
  timeStamp: Date;
  /**
   * @member {boolean} [hasCorrelatedEvents] Shows there is existing related
   * events available.
   */
  hasCorrelatedEvents?: boolean;
  /**
   * @member {string} nodeName The name of a Service Fabric node.
   */
  nodeName: string;
  /**
   * @member {string} nodeId Id of Node.
   */
  nodeId: string;
  /**
   * @member {number} nodeInstance Id of Node instance.
   */
  nodeInstance: number;
  /**
   * @member {string} nodeType Type of Node.
   */
  nodeType: string;
  /**
   * @member {string} fabricVersion Fabric version.
   */
  fabricVersion: string;
  /**
   * @member {string} ipAddressOrFQDN IP address or FQDN.
   */
  ipAddressOrFQDN: string;
  /**
   * @member {string} nodeCapacities Capacities.
   */
  nodeCapacities: string;
}

/**
 * @interface
 * An interface representing NodeUpEvent.
 * Node Up event.
 *
 */
export interface NodeUpEvent {
  /**
   * @member {string} kind Polymorphic Discriminator
   */
  kind: "NodeUp";
  /**
   * @member {string} eventInstanceId The identifier for the FabricEvent
   * instance.
   */
  eventInstanceId: string;
  /**
   * @member {Date} timeStamp The time event was logged.
   */
  timeStamp: Date;
  /**
   * @member {boolean} [hasCorrelatedEvents] Shows there is existing related
   * events available.
   */
  hasCorrelatedEvents?: boolean;
  /**
   * @member {string} nodeName The name of a Service Fabric node.
   */
  nodeName: string;
  /**
   * @member {number} nodeInstance Id of Node instance.
   */
  nodeInstance: number;
  /**
   * @member {Date} lastNodeDownAt Time when Node was last down.
   */
  lastNodeDownAt: Date;
}

/**
 * @interface
 * An interface representing PartitionHealthReportCreatedEvent.
 * Partition Health Report Created event.
 *
 */
export interface PartitionHealthReportCreatedEvent {
  /**
   * @member {string} kind Polymorphic Discriminator
   */
  kind: "PartitionHealthReportCreated";
  /**
   * @member {string} eventInstanceId The identifier for the FabricEvent
   * instance.
   */
  eventInstanceId: string;
  /**
   * @member {Date} timeStamp The time event was logged.
   */
  timeStamp: Date;
  /**
   * @member {boolean} [hasCorrelatedEvents] Shows there is existing related
   * events available.
   */
  hasCorrelatedEvents?: boolean;
  /**
   * @member {string} partitionId An internal ID used by Service Fabric to
   * uniquely identify a partition. This is a randomly generated GUID when the
   * service was created. The partition ID is unique and does not change for
   * the lifetime of the service. If the same service was deleted and recreated
   * the IDs of its partitions would be different.
   */
  partitionId: string;
  /**
   * @member {string} sourceId Id of report source.
   */
  sourceId: string;
  /**
   * @member {string} property Describes the property.
   */
  property: string;
  /**
   * @member {string} healthState Describes the property health state.
   */
  healthState: string;
  /**
   * @member {number} timeToLiveMs Time to live in milli-seconds.
   */
  timeToLiveMs: number;
  /**
   * @member {number} sequenceNumber Sequence number of report.
   */
  sequenceNumber: number;
  /**
   * @member {string} description Description of report.
   */
  description: string;
  /**
   * @member {boolean} removeWhenExpired Indicates the removal when it expires.
   */
  removeWhenExpired: boolean;
  /**
   * @member {Date} sourceUtcTimestamp Source time.
   */
  sourceUtcTimestamp: Date;
}

/**
 * @interface
 * An interface representing PartitionHealthReportExpiredEvent.
 * Partition Health Report Expired event.
 *
 */
export interface PartitionHealthReportExpiredEvent {
  /**
   * @member {string} kind Polymorphic Discriminator
   */
  kind: "PartitionHealthReportExpired";
  /**
   * @member {string} eventInstanceId The identifier for the FabricEvent
   * instance.
   */
  eventInstanceId: string;
  /**
   * @member {Date} timeStamp The time event was logged.
   */
  timeStamp: Date;
  /**
   * @member {boolean} [hasCorrelatedEvents] Shows there is existing related
   * events available.
   */
  hasCorrelatedEvents?: boolean;
  /**
   * @member {string} partitionId An internal ID used by Service Fabric to
   * uniquely identify a partition. This is a randomly generated GUID when the
   * service was created. The partition ID is unique and does not change for
   * the lifetime of the service. If the same service was deleted and recreated
   * the IDs of its partitions would be different.
   */
  partitionId: string;
  /**
   * @member {string} sourceId Id of report source.
   */
  sourceId: string;
  /**
   * @member {string} property Describes the property.
   */
  property: string;
  /**
   * @member {string} healthState Describes the property health state.
   */
  healthState: string;
  /**
   * @member {number} timeToLiveMs Time to live in milli-seconds.
   */
  timeToLiveMs: number;
  /**
   * @member {number} sequenceNumber Sequence number of report.
   */
  sequenceNumber: number;
  /**
   * @member {string} description Description of report.
   */
  description: string;
  /**
   * @member {boolean} removeWhenExpired Indicates the removal when it expires.
   */
  removeWhenExpired: boolean;
  /**
   * @member {Date} sourceUtcTimestamp Source time.
   */
  sourceUtcTimestamp: Date;
}

/**
 * @interface
 * An interface representing PartitionReconfigurationCompletedEvent.
 * Partition Reconfiguration Completed event.
 *
 */
export interface PartitionReconfigurationCompletedEvent {
  /**
   * @member {string} kind Polymorphic Discriminator
   */
  kind: "PartitionReconfigurationCompleted";
  /**
   * @member {string} eventInstanceId The identifier for the FabricEvent
   * instance.
   */
  eventInstanceId: string;
  /**
   * @member {Date} timeStamp The time event was logged.
   */
  timeStamp: Date;
  /**
   * @member {boolean} [hasCorrelatedEvents] Shows there is existing related
   * events available.
   */
  hasCorrelatedEvents?: boolean;
  /**
   * @member {string} partitionId An internal ID used by Service Fabric to
   * uniquely identify a partition. This is a randomly generated GUID when the
   * service was created. The partition ID is unique and does not change for
   * the lifetime of the service. If the same service was deleted and recreated
   * the IDs of its partitions would be different.
   */
  partitionId: string;
  /**
   * @member {string} nodeName The name of a Service Fabric node.
   */
  nodeName: string;
  /**
   * @member {string} nodeInstanceId Id of Node instance.
   */
  nodeInstanceId: string;
  /**
   * @member {string} serviceType Type of Service.
   */
  serviceType: string;
  /**
   * @member {number} ccEpochDataLossVersion CcEpochDataLoss version.
   */
  ccEpochDataLossVersion: number;
  /**
   * @member {number} ccEpochConfigVersion CcEpochConfig version.
   */
  ccEpochConfigVersion: number;
  /**
   * @member {string} reconfigType Type of reconfiguration.
   */
  reconfigType: string;
  /**
   * @member {string} result Describes reconfiguration result.
   */
  result: string;
  /**
   * @member {number} phase0DurationMs Duration of Phase0 in milli-seconds.
   */
  phase0DurationMs: number;
  /**
   * @member {number} phase1DurationMs Duration of Phase1 in milli-seconds.
   */
  phase1DurationMs: number;
  /**
   * @member {number} phase2DurationMs Duration of Phase2 in milli-seconds.
   */
  phase2DurationMs: number;
  /**
   * @member {number} phase3DurationMs Duration of Phase3 in milli-seconds.
   */
  phase3DurationMs: number;
  /**
   * @member {number} phase4DurationMs Duration of Phase4 in milli-seconds.
   */
  phase4DurationMs: number;
  /**
   * @member {number} totalDurationMs Total duration in milli-seconds.
   */
  totalDurationMs: number;
}

/**
 * @interface
 * An interface representing PartitionPrimaryMoveAnalysisEvent.
 * Partition Primary Move Analysis event.
 *
 */
export interface PartitionPrimaryMoveAnalysisEvent {
  /**
   * @member {string} kind Polymorphic Discriminator
   */
  kind: "PartitionPrimaryMoveAnalysis";
  /**
   * @member {string} eventInstanceId The identifier for the FabricEvent
   * instance.
   */
  eventInstanceId: string;
  /**
   * @member {Date} timeStamp The time event was logged.
   */
  timeStamp: Date;
  /**
   * @member {boolean} [hasCorrelatedEvents] Shows there is existing related
   * events available.
   */
  hasCorrelatedEvents?: boolean;
  /**
   * @member {string} partitionId An internal ID used by Service Fabric to
   * uniquely identify a partition. This is a randomly generated GUID when the
   * service was created. The partition ID is unique and does not change for
   * the lifetime of the service. If the same service was deleted and recreated
   * the IDs of its partitions would be different.
   */
  partitionId: string;
  /**
   * @member {AnalysisEventMetadata} metadata Metadata about an Analysis Event.
   */
  metadata: AnalysisEventMetadata;
  /**
   * @member {Date} whenMoveCompleted Time when the move was completed.
   */
  whenMoveCompleted: Date;
  /**
   * @member {string} previousNode The name of a Service Fabric node.
   */
  previousNode: string;
  /**
   * @member {string} currentNode The name of a Service Fabric node.
   */
  currentNode: string;
  /**
   * @member {string} moveReason Move reason.
   */
  moveReason: string;
  /**
   * @member {string} relevantTraces Relevant traces.
   */
  relevantTraces: string;
}

/**
 * @interface
 * An interface representing ServiceCreatedEvent.
 * Service Created event.
 *
 */
export interface ServiceCreatedEvent {
  /**
   * @member {string} kind Polymorphic Discriminator
   */
  kind: "ServiceCreated";
  /**
   * @member {string} eventInstanceId The identifier for the FabricEvent
   * instance.
   */
  eventInstanceId: string;
  /**
   * @member {Date} timeStamp The time event was logged.
   */
  timeStamp: Date;
  /**
   * @member {boolean} [hasCorrelatedEvents] Shows there is existing related
   * events available.
   */
  hasCorrelatedEvents?: boolean;
  /**
   * @member {string} serviceId The identity of the service. This ID is an
   * encoded representation of the service name. This is used in the REST APIs
   * to identify the service resource.
   * Starting in version 6.0, hierarchical names are delimited with the "\~"
   * character. For example, if the service name is "fabric:/myapp/app1/svc1",
   * the service identity would be "myapp~app1\~svc1" in 6.0+ and
   * "myapp/app1/svc1" in previous versions.
   */
  serviceId: string;
  /**
   * @member {string} serviceTypeName Service type name.
   */
  serviceTypeName: string;
  /**
   * @member {string} applicationName Application name.
   */
  applicationName: string;
  /**
   * @member {string} applicationTypeName Application type name.
   */
  applicationTypeName: string;
  /**
   * @member {number} serviceInstance Id of Service instance.
   */
  serviceInstance: number;
  /**
   * @member {boolean} isStateful Indicates if Service is stateful.
   */
  isStateful: boolean;
  /**
   * @member {number} partitionCount Number of partitions.
   */
  partitionCount: number;
  /**
   * @member {number} targetReplicaSetSize Size of target replicas set.
   */
  targetReplicaSetSize: number;
  /**
   * @member {number} minReplicaSetSize Minimum size of replicas set.
   */
  minReplicaSetSize: number;
  /**
   * @member {string} servicePackageVersion Version of Service package.
   */
  servicePackageVersion: string;
  /**
   * @member {string} partitionId An internal ID used by Service Fabric to
   * uniquely identify a partition. This is a randomly generated GUID when the
   * service was created. The partition ID is unique and does not change for
   * the lifetime of the service. If the same service was deleted and recreated
   * the IDs of its partitions would be different.
   */
  partitionId: string;
}

/**
 * @interface
 * An interface representing ServiceDeletedEvent.
 * Service Deleted event.
 *
 */
export interface ServiceDeletedEvent {
  /**
   * @member {string} kind Polymorphic Discriminator
   */
  kind: "ServiceDeleted";
  /**
   * @member {string} eventInstanceId The identifier for the FabricEvent
   * instance.
   */
  eventInstanceId: string;
  /**
   * @member {Date} timeStamp The time event was logged.
   */
  timeStamp: Date;
  /**
   * @member {boolean} [hasCorrelatedEvents] Shows there is existing related
   * events available.
   */
  hasCorrelatedEvents?: boolean;
  /**
   * @member {string} serviceId The identity of the service. This ID is an
   * encoded representation of the service name. This is used in the REST APIs
   * to identify the service resource.
   * Starting in version 6.0, hierarchical names are delimited with the "\~"
   * character. For example, if the service name is "fabric:/myapp/app1/svc1",
   * the service identity would be "myapp~app1\~svc1" in 6.0+ and
   * "myapp/app1/svc1" in previous versions.
   */
  serviceId: string;
  /**
   * @member {string} serviceTypeName Service type name.
   */
  serviceTypeName: string;
  /**
   * @member {string} applicationName Application name.
   */
  applicationName: string;
  /**
   * @member {string} applicationTypeName Application type name.
   */
  applicationTypeName: string;
  /**
   * @member {number} serviceInstance Id of Service instance.
   */
  serviceInstance: number;
  /**
   * @member {boolean} isStateful Indicates if Service is stateful.
   */
  isStateful: boolean;
  /**
   * @member {number} partitionCount Number of partitions.
   */
  partitionCount: number;
  /**
   * @member {number} targetReplicaSetSize Size of target replicas set.
   */
  targetReplicaSetSize: number;
  /**
   * @member {number} minReplicaSetSize Minimum size of replicas set.
   */
  minReplicaSetSize: number;
  /**
   * @member {string} servicePackageVersion Version of Service package.
   */
  servicePackageVersion: string;
}

/**
 * @interface
 * An interface representing ServiceHealthReportCreatedEvent.
 * Service Health Report Created event.
 *
 */
export interface ServiceHealthReportCreatedEvent {
  /**
   * @member {string} kind Polymorphic Discriminator
   */
  kind: "ServiceHealthReportCreated";
  /**
   * @member {string} eventInstanceId The identifier for the FabricEvent
   * instance.
   */
  eventInstanceId: string;
  /**
   * @member {Date} timeStamp The time event was logged.
   */
  timeStamp: Date;
  /**
   * @member {boolean} [hasCorrelatedEvents] Shows there is existing related
   * events available.
   */
  hasCorrelatedEvents?: boolean;
  /**
   * @member {string} serviceId The identity of the service. This ID is an
   * encoded representation of the service name. This is used in the REST APIs
   * to identify the service resource.
   * Starting in version 6.0, hierarchical names are delimited with the "\~"
   * character. For example, if the service name is "fabric:/myapp/app1/svc1",
   * the service identity would be "myapp~app1\~svc1" in 6.0+ and
   * "myapp/app1/svc1" in previous versions.
   */
  serviceId: string;
  /**
   * @member {number} instanceId Id of Service instance.
   */
  instanceId: number;
  /**
   * @member {string} sourceId Id of report source.
   */
  sourceId: string;
  /**
   * @member {string} property Describes the property.
   */
  property: string;
  /**
   * @member {string} healthState Describes the property health state.
   */
  healthState: string;
  /**
   * @member {number} timeToLiveMs Time to live in milli-seconds.
   */
  timeToLiveMs: number;
  /**
   * @member {number} sequenceNumber Sequence number of report.
   */
  sequenceNumber: number;
  /**
   * @member {string} description Description of report.
   */
  description: string;
  /**
   * @member {boolean} removeWhenExpired Indicates the removal when it expires.
   */
  removeWhenExpired: boolean;
  /**
   * @member {Date} sourceUtcTimestamp Source time.
   */
  sourceUtcTimestamp: Date;
}

/**
 * @interface
 * An interface representing ServiceHealthReportExpiredEvent.
 * Service Health Report Expired event.
 *
 */
export interface ServiceHealthReportExpiredEvent {
  /**
   * @member {string} kind Polymorphic Discriminator
   */
  kind: "ServiceHealthReportExpired";
  /**
   * @member {string} eventInstanceId The identifier for the FabricEvent
   * instance.
   */
  eventInstanceId: string;
  /**
   * @member {Date} timeStamp The time event was logged.
   */
  timeStamp: Date;
  /**
   * @member {boolean} [hasCorrelatedEvents] Shows there is existing related
   * events available.
   */
  hasCorrelatedEvents?: boolean;
  /**
   * @member {string} serviceId The identity of the service. This ID is an
   * encoded representation of the service name. This is used in the REST APIs
   * to identify the service resource.
   * Starting in version 6.0, hierarchical names are delimited with the "\~"
   * character. For example, if the service name is "fabric:/myapp/app1/svc1",
   * the service identity would be "myapp~app1\~svc1" in 6.0+ and
   * "myapp/app1/svc1" in previous versions.
   */
  serviceId: string;
  /**
   * @member {number} instanceId Id of Service instance.
   */
  instanceId: number;
  /**
   * @member {string} sourceId Id of report source.
   */
  sourceId: string;
  /**
   * @member {string} property Describes the property.
   */
  property: string;
  /**
   * @member {string} healthState Describes the property health state.
   */
  healthState: string;
  /**
   * @member {number} timeToLiveMs Time to live in milli-seconds.
   */
  timeToLiveMs: number;
  /**
   * @member {number} sequenceNumber Sequence number of report.
   */
  sequenceNumber: number;
  /**
   * @member {string} description Description of report.
   */
  description: string;
  /**
   * @member {boolean} removeWhenExpired Indicates the removal when it expires.
   */
  removeWhenExpired: boolean;
  /**
   * @member {Date} sourceUtcTimestamp Source time.
   */
  sourceUtcTimestamp: Date;
}

/**
 * @interface
 * An interface representing DeployedServiceHealthReportCreatedEvent.
 * Deployed Service Health Report Created event.
 *
 */
export interface DeployedServiceHealthReportCreatedEvent {
  /**
   * @member {string} kind Polymorphic Discriminator
   */
  kind: "DeployedServiceHealthReportCreated";
  /**
   * @member {string} eventInstanceId The identifier for the FabricEvent
   * instance.
   */
  eventInstanceId: string;
  /**
   * @member {Date} timeStamp The time event was logged.
   */
  timeStamp: Date;
  /**
   * @member {boolean} [hasCorrelatedEvents] Shows there is existing related
   * events available.
   */
  hasCorrelatedEvents?: boolean;
  /**
   * @member {string} applicationId The identity of the application. This is an
   * encoded representation of the application name. This is used in the REST
   * APIs to identify the application resource.
   * Starting in version 6.0, hierarchical names are delimited with the "\~"
   * character. For example, if the application name is "fabric:/myapp/app1",
   * the application identity would be "myapp\~app1" in 6.0+ and "myapp/app1"
   * in previous versions.
   */
  applicationId: string;
  /**
   * @member {string} serviceManifestName Service manifest name.
   */
  serviceManifestName: string;
  /**
   * @member {number} servicePackageInstanceId Id of Service package instance.
   */
  servicePackageInstanceId: number;
  /**
   * @member {string} servicePackageActivationId Id of Service package
   * activation.
   */
  servicePackageActivationId: string;
  /**
   * @member {string} nodeName The name of a Service Fabric node.
   */
  nodeName: string;
  /**
   * @member {string} sourceId Id of report source.
   */
  sourceId: string;
  /**
   * @member {string} property Describes the property.
   */
  property: string;
  /**
   * @member {string} healthState Describes the property health state.
   */
  healthState: string;
  /**
   * @member {number} tTLTimespan Time to live in milli-seconds.
   */
  tTLTimespan: number;
  /**
   * @member {number} sequenceNumber Sequence number of report.
   */
  sequenceNumber: number;
  /**
   * @member {string} description Description of report.
   */
  description: string;
  /**
   * @member {boolean} removeWhenExpired Indicates the removal when it expires.
   */
  removeWhenExpired: boolean;
  /**
   * @member {Date} sourceUtcTimestamp Source time.
   */
  sourceUtcTimestamp: Date;
}

/**
 * @interface
 * An interface representing DeployedServiceHealthReportExpiredEvent.
 * Deployed Service Health Report Expired event.
 *
 */
export interface DeployedServiceHealthReportExpiredEvent {
  /**
   * @member {string} kind Polymorphic Discriminator
   */
  kind: "DeployedServiceHealthReportExpired";
  /**
   * @member {string} eventInstanceId The identifier for the FabricEvent
   * instance.
   */
  eventInstanceId: string;
  /**
   * @member {Date} timeStamp The time event was logged.
   */
  timeStamp: Date;
  /**
   * @member {boolean} [hasCorrelatedEvents] Shows there is existing related
   * events available.
   */
  hasCorrelatedEvents?: boolean;
  /**
   * @member {string} applicationId The identity of the application. This is an
   * encoded representation of the application name. This is used in the REST
   * APIs to identify the application resource.
   * Starting in version 6.0, hierarchical names are delimited with the "\~"
   * character. For example, if the application name is "fabric:/myapp/app1",
   * the application identity would be "myapp\~app1" in 6.0+ and "myapp/app1"
   * in previous versions.
   */
  applicationId: string;
  /**
   * @member {string} serviceManifest Service manifest name.
   */
  serviceManifest: string;
  /**
   * @member {number} servicePackageInstanceId Id of Service package instance.
   */
  servicePackageInstanceId: number;
  /**
   * @member {string} servicePackageActivationId Id of Service package
   * activation.
   */
  servicePackageActivationId: string;
  /**
   * @member {string} nodeName The name of a Service Fabric node.
   */
  nodeName: string;
  /**
   * @member {string} sourceId Id of report source.
   */
  sourceId: string;
  /**
   * @member {string} property Describes the property.
   */
  property: string;
  /**
   * @member {string} healthState Describes the property health state.
   */
  healthState: string;
  /**
   * @member {number} tTLTimespan Time to live in milli-seconds.
   */
  tTLTimespan: number;
  /**
   * @member {number} sequenceNumber Sequence number of report.
   */
  sequenceNumber: number;
  /**
   * @member {string} description Description of report.
   */
  description: string;
  /**
   * @member {boolean} removeWhenExpired Indicates the removal when it expires.
   */
  removeWhenExpired: boolean;
  /**
   * @member {Date} sourceUtcTimestamp Source time.
   */
  sourceUtcTimestamp: Date;
}

/**
 * @interface
 * An interface representing StatefulReplicaHealthReportCreatedEvent.
 * Stateful Replica Health Report Created event.
 *
 */
export interface StatefulReplicaHealthReportCreatedEvent {
  /**
   * @member {string} kind Polymorphic Discriminator
   */
  kind: "StatefulReplicaHealthReportCreated";
  /**
   * @member {string} eventInstanceId The identifier for the FabricEvent
   * instance.
   */
  eventInstanceId: string;
  /**
   * @member {Date} timeStamp The time event was logged.
   */
  timeStamp: Date;
  /**
   * @member {boolean} [hasCorrelatedEvents] Shows there is existing related
   * events available.
   */
  hasCorrelatedEvents?: boolean;
  /**
   * @member {string} partitionId An internal ID used by Service Fabric to
   * uniquely identify a partition. This is a randomly generated GUID when the
   * service was created. The partition ID is unique and does not change for
   * the lifetime of the service. If the same service was deleted and recreated
   * the IDs of its partitions would be different.
   */
  partitionId: string;
  /**
   * @member {number} replicaId Id of a stateful service replica. ReplicaId is
   * used by Service Fabric to uniquely identify a replica of a partition. It
   * is unique within a partition and does not change for the lifetime of the
   * replica. If a replica gets dropped and another replica gets created on the
   * same node for the same partition, it will get a different value for the
   * id. Sometimes the id of a stateless service instance is also referred as a
   * replica id.
   */
  replicaId: number;
  /**
   * @member {number} replicaInstanceId Id of Replica instance.
   */
  replicaInstanceId: number;
  /**
   * @member {string} sourceId Id of report source.
   */
  sourceId: string;
  /**
   * @member {string} property Describes the property.
   */
  property: string;
  /**
   * @member {string} healthState Describes the property health state.
   */
  healthState: string;
  /**
   * @member {number} timeToLiveMs Time to live in milli-seconds.
   */
  timeToLiveMs: number;
  /**
   * @member {number} sequenceNumber Sequence number of report.
   */
  sequenceNumber: number;
  /**
   * @member {string} description Description of report.
   */
  description: string;
  /**
   * @member {boolean} removeWhenExpired Indicates the removal when it expires.
   */
  removeWhenExpired: boolean;
  /**
   * @member {Date} sourceUtcTimestamp Source time.
   */
  sourceUtcTimestamp: Date;
}

/**
 * @interface
 * An interface representing StatefulReplicaHealthReportExpiredEvent.
 * Stateful Replica Health Report Expired event.
 *
 */
export interface StatefulReplicaHealthReportExpiredEvent {
  /**
   * @member {string} kind Polymorphic Discriminator
   */
  kind: "StatefulReplicaHealthReportExpired";
  /**
   * @member {string} eventInstanceId The identifier for the FabricEvent
   * instance.
   */
  eventInstanceId: string;
  /**
   * @member {Date} timeStamp The time event was logged.
   */
  timeStamp: Date;
  /**
   * @member {boolean} [hasCorrelatedEvents] Shows there is existing related
   * events available.
   */
  hasCorrelatedEvents?: boolean;
  /**
   * @member {string} partitionId An internal ID used by Service Fabric to
   * uniquely identify a partition. This is a randomly generated GUID when the
   * service was created. The partition ID is unique and does not change for
   * the lifetime of the service. If the same service was deleted and recreated
   * the IDs of its partitions would be different.
   */
  partitionId: string;
  /**
   * @member {number} replicaId Id of a stateful service replica. ReplicaId is
   * used by Service Fabric to uniquely identify a replica of a partition. It
   * is unique within a partition and does not change for the lifetime of the
   * replica. If a replica gets dropped and another replica gets created on the
   * same node for the same partition, it will get a different value for the
   * id. Sometimes the id of a stateless service instance is also referred as a
   * replica id.
   */
  replicaId: number;
  /**
   * @member {number} replicaInstanceId Id of Replica instance.
   */
  replicaInstanceId: number;
  /**
   * @member {string} sourceId Id of report source.
   */
  sourceId: string;
  /**
   * @member {string} property Describes the property.
   */
  property: string;
  /**
   * @member {string} healthState Describes the property health state.
   */
  healthState: string;
  /**
   * @member {number} timeToLiveMs Time to live in milli-seconds.
   */
  timeToLiveMs: number;
  /**
   * @member {number} sequenceNumber Sequence number of report.
   */
  sequenceNumber: number;
  /**
   * @member {string} description Description of report.
   */
  description: string;
  /**
   * @member {boolean} removeWhenExpired Indicates the removal when it expires.
   */
  removeWhenExpired: boolean;
  /**
   * @member {Date} sourceUtcTimestamp Source time.
   */
  sourceUtcTimestamp: Date;
}

/**
 * @interface
 * An interface representing StatelessReplicaHealthReportCreatedEvent.
 * Stateless Replica Health Report Created event.
 *
 */
export interface StatelessReplicaHealthReportCreatedEvent {
  /**
   * @member {string} kind Polymorphic Discriminator
   */
  kind: "StatelessReplicaHealthReportCreated";
  /**
   * @member {string} eventInstanceId The identifier for the FabricEvent
   * instance.
   */
  eventInstanceId: string;
  /**
   * @member {Date} timeStamp The time event was logged.
   */
  timeStamp: Date;
  /**
   * @member {boolean} [hasCorrelatedEvents] Shows there is existing related
   * events available.
   */
  hasCorrelatedEvents?: boolean;
  /**
   * @member {string} partitionId An internal ID used by Service Fabric to
   * uniquely identify a partition. This is a randomly generated GUID when the
   * service was created. The partition ID is unique and does not change for
   * the lifetime of the service. If the same service was deleted and recreated
   * the IDs of its partitions would be different.
   */
  partitionId: string;
  /**
   * @member {number} replicaId Id of a stateful service replica. ReplicaId is
   * used by Service Fabric to uniquely identify a replica of a partition. It
   * is unique within a partition and does not change for the lifetime of the
   * replica. If a replica gets dropped and another replica gets created on the
   * same node for the same partition, it will get a different value for the
   * id. Sometimes the id of a stateless service instance is also referred as a
   * replica id.
   */
  replicaId: number;
  /**
   * @member {string} sourceId Id of report source.
   */
  sourceId: string;
  /**
   * @member {string} property Describes the property.
   */
  property: string;
  /**
   * @member {string} healthState Describes the property health state.
   */
  healthState: string;
  /**
   * @member {number} timeToLiveMs Time to live in milli-seconds.
   */
  timeToLiveMs: number;
  /**
   * @member {number} sequenceNumber Sequence number of report.
   */
  sequenceNumber: number;
  /**
   * @member {string} description Description of report.
   */
  description: string;
  /**
   * @member {boolean} removeWhenExpired Indicates the removal when it expires.
   */
  removeWhenExpired: boolean;
  /**
   * @member {Date} sourceUtcTimestamp Source time.
   */
  sourceUtcTimestamp: Date;
}

/**
 * @interface
 * An interface representing StatelessReplicaHealthReportExpiredEvent.
 * Stateless Replica Health Report Expired event.
 *
 */
export interface StatelessReplicaHealthReportExpiredEvent {
  /**
   * @member {string} kind Polymorphic Discriminator
   */
  kind: "StatelessReplicaHealthReportExpired";
  /**
   * @member {string} eventInstanceId The identifier for the FabricEvent
   * instance.
   */
  eventInstanceId: string;
  /**
   * @member {Date} timeStamp The time event was logged.
   */
  timeStamp: Date;
  /**
   * @member {boolean} [hasCorrelatedEvents] Shows there is existing related
   * events available.
   */
  hasCorrelatedEvents?: boolean;
  /**
   * @member {string} partitionId An internal ID used by Service Fabric to
   * uniquely identify a partition. This is a randomly generated GUID when the
   * service was created. The partition ID is unique and does not change for
   * the lifetime of the service. If the same service was deleted and recreated
   * the IDs of its partitions would be different.
   */
  partitionId: string;
  /**
   * @member {number} replicaId Id of a stateful service replica. ReplicaId is
   * used by Service Fabric to uniquely identify a replica of a partition. It
   * is unique within a partition and does not change for the lifetime of the
   * replica. If a replica gets dropped and another replica gets created on the
   * same node for the same partition, it will get a different value for the
   * id. Sometimes the id of a stateless service instance is also referred as a
   * replica id.
   */
  replicaId: number;
  /**
   * @member {string} sourceId Id of report source.
   */
  sourceId: string;
  /**
   * @member {string} property Describes the property.
   */
  property: string;
  /**
   * @member {string} healthState Describes the property health state.
   */
  healthState: string;
  /**
   * @member {number} timeToLiveMs Time to live in milli-seconds.
   */
  timeToLiveMs: number;
  /**
   * @member {number} sequenceNumber Sequence number of report.
   */
  sequenceNumber: number;
  /**
   * @member {string} description Description of report.
   */
  description: string;
  /**
   * @member {boolean} removeWhenExpired Indicates the removal when it expires.
   */
  removeWhenExpired: boolean;
  /**
   * @member {Date} sourceUtcTimestamp Source time.
   */
  sourceUtcTimestamp: Date;
}

/**
 * @interface
 * An interface representing ClusterHealthReportCreatedEvent.
 * Cluster Health Report Created event.
 *
 */
export interface ClusterHealthReportCreatedEvent {
  /**
   * @member {string} kind Polymorphic Discriminator
   */
  kind: "ClusterHealthReportCreated";
  /**
   * @member {string} eventInstanceId The identifier for the FabricEvent
   * instance.
   */
  eventInstanceId: string;
  /**
   * @member {Date} timeStamp The time event was logged.
   */
  timeStamp: Date;
  /**
   * @member {boolean} [hasCorrelatedEvents] Shows there is existing related
   * events available.
   */
  hasCorrelatedEvents?: boolean;
  /**
   * @member {string} sourceId Id of report source.
   */
  sourceId: string;
  /**
   * @member {string} property Describes the property.
   */
  property: string;
  /**
   * @member {string} healthState Describes the property health state.
   */
  healthState: string;
  /**
   * @member {number} timeToLiveMs Time to live in milli-seconds.
   */
  timeToLiveMs: number;
  /**
   * @member {number} sequenceNumber Sequence number of report.
   */
  sequenceNumber: number;
  /**
   * @member {string} description Description of report.
   */
  description: string;
  /**
   * @member {boolean} removeWhenExpired Indicates the removal when it expires.
   */
  removeWhenExpired: boolean;
  /**
   * @member {Date} sourceUtcTimestamp Source time.
   */
  sourceUtcTimestamp: Date;
}

/**
 * @interface
 * An interface representing ClusterHealthReportExpiredEvent.
 * Cluster Health Report Expired event.
 *
 */
export interface ClusterHealthReportExpiredEvent {
  /**
   * @member {string} kind Polymorphic Discriminator
   */
  kind: "ClusterHealthReportExpired";
  /**
   * @member {string} eventInstanceId The identifier for the FabricEvent
   * instance.
   */
  eventInstanceId: string;
  /**
   * @member {Date} timeStamp The time event was logged.
   */
  timeStamp: Date;
  /**
   * @member {boolean} [hasCorrelatedEvents] Shows there is existing related
   * events available.
   */
  hasCorrelatedEvents?: boolean;
  /**
   * @member {string} sourceId Id of report source.
   */
  sourceId: string;
  /**
   * @member {string} property Describes the property.
   */
  property: string;
  /**
   * @member {string} healthState Describes the property health state.
   */
  healthState: string;
  /**
   * @member {number} timeToLiveMs Time to live in milli-seconds.
   */
  timeToLiveMs: number;
  /**
   * @member {number} sequenceNumber Sequence number of report.
   */
  sequenceNumber: number;
  /**
   * @member {string} description Description of report.
   */
  description: string;
  /**
   * @member {boolean} removeWhenExpired Indicates the removal when it expires.
   */
  removeWhenExpired: boolean;
  /**
   * @member {Date} sourceUtcTimestamp Source time.
   */
  sourceUtcTimestamp: Date;
}

/**
 * @interface
 * An interface representing ClusterUpgradeCompleteEvent.
 * Cluster Upgrade Complete event.
 *
 */
export interface ClusterUpgradeCompleteEvent {
  /**
   * @member {string} kind Polymorphic Discriminator
   */
  kind: "ClusterUpgradeComplete";
  /**
   * @member {string} eventInstanceId The identifier for the FabricEvent
   * instance.
   */
  eventInstanceId: string;
  /**
   * @member {Date} timeStamp The time event was logged.
   */
  timeStamp: Date;
  /**
   * @member {boolean} [hasCorrelatedEvents] Shows there is existing related
   * events available.
   */
  hasCorrelatedEvents?: boolean;
  /**
   * @member {string} targetClusterVersion Target Cluster version.
   */
  targetClusterVersion: string;
  /**
   * @member {number} overallUpgradeElapsedTimeInMs Overall duration of upgrade
   * in milli-seconds.
   */
  overallUpgradeElapsedTimeInMs: number;
}

/**
 * @interface
 * An interface representing ClusterUpgradeDomainCompleteEvent.
 * Cluster Upgrade Domain Complete event.
 *
 */
export interface ClusterUpgradeDomainCompleteEvent {
  /**
   * @member {string} kind Polymorphic Discriminator
   */
  kind: "ClusterUpgradeDomainComplete";
  /**
   * @member {string} eventInstanceId The identifier for the FabricEvent
   * instance.
   */
  eventInstanceId: string;
  /**
   * @member {Date} timeStamp The time event was logged.
   */
  timeStamp: Date;
  /**
   * @member {boolean} [hasCorrelatedEvents] Shows there is existing related
   * events available.
   */
  hasCorrelatedEvents?: boolean;
  /**
   * @member {string} targetClusterVersion Target Cluster version.
   */
  targetClusterVersion: string;
  /**
   * @member {string} upgradeState State of upgrade.
   */
  upgradeState: string;
  /**
   * @member {string} upgradeDomains Upgrade domains.
   */
  upgradeDomains: string;
  /**
   * @member {number} upgradeDomainElapsedTimeInMs Duration of domain upgrade
   * in milli-seconds.
   */
  upgradeDomainElapsedTimeInMs: number;
}

/**
 * @interface
 * An interface representing ClusterUpgradeRollbackCompleteEvent.
 * Cluster Upgrade Rollback Complete event.
 *
 */
export interface ClusterUpgradeRollbackCompleteEvent {
  /**
   * @member {string} kind Polymorphic Discriminator
   */
  kind: "ClusterUpgradeRollbackComplete";
  /**
   * @member {string} eventInstanceId The identifier for the FabricEvent
   * instance.
   */
  eventInstanceId: string;
  /**
   * @member {Date} timeStamp The time event was logged.
   */
  timeStamp: Date;
  /**
   * @member {boolean} [hasCorrelatedEvents] Shows there is existing related
   * events available.
   */
  hasCorrelatedEvents?: boolean;
  /**
   * @member {string} targetClusterVersion Target Cluster version.
   */
  targetClusterVersion: string;
  /**
   * @member {string} failureReason Describes failure.
   */
  failureReason: string;
  /**
   * @member {number} overallUpgradeElapsedTimeInMs Overall duration of upgrade
   * in milli-seconds.
   */
  overallUpgradeElapsedTimeInMs: number;
}

/**
 * @interface
 * An interface representing ClusterUpgradeRollbackStartEvent.
 * Cluster Upgrade Rollback Start event.
 *
 */
export interface ClusterUpgradeRollbackStartEvent {
  /**
   * @member {string} kind Polymorphic Discriminator
   */
  kind: "ClusterUpgradeRollbackStart";
  /**
   * @member {string} eventInstanceId The identifier for the FabricEvent
   * instance.
   */
  eventInstanceId: string;
  /**
   * @member {Date} timeStamp The time event was logged.
   */
  timeStamp: Date;
  /**
   * @member {boolean} [hasCorrelatedEvents] Shows there is existing related
   * events available.
   */
  hasCorrelatedEvents?: boolean;
  /**
   * @member {string} targetClusterVersion Target Cluster version.
   */
  targetClusterVersion: string;
  /**
   * @member {string} failureReason Describes failure.
   */
  failureReason: string;
  /**
   * @member {number} overallUpgradeElapsedTimeInMs Overall duration of upgrade
   * in milli-seconds.
   */
  overallUpgradeElapsedTimeInMs: number;
}

/**
 * @interface
 * An interface representing ClusterUpgradeStartEvent.
 * Cluster Upgrade Start event.
 *
 */
export interface ClusterUpgradeStartEvent {
  /**
   * @member {string} kind Polymorphic Discriminator
   */
  kind: "ClusterUpgradeStart";
  /**
   * @member {string} eventInstanceId The identifier for the FabricEvent
   * instance.
   */
  eventInstanceId: string;
  /**
   * @member {Date} timeStamp The time event was logged.
   */
  timeStamp: Date;
  /**
   * @member {boolean} [hasCorrelatedEvents] Shows there is existing related
   * events available.
   */
  hasCorrelatedEvents?: boolean;
  /**
   * @member {string} currentClusterVersion Current Cluster version.
   */
  currentClusterVersion: string;
  /**
   * @member {string} targetClusterVersion Target Cluster version.
   */
  targetClusterVersion: string;
  /**
   * @member {string} upgradeType Type of upgrade.
   */
  upgradeType: string;
  /**
   * @member {string} rollingUpgradeMode Mode of upgrade.
   */
  rollingUpgradeMode: string;
  /**
   * @member {string} failureAction Action if failed.
   */
  failureAction: string;
}

/**
 * @interface
 * An interface representing ChaosStoppedEvent.
 * Chaos Stopped event.
 *
 */
export interface ChaosStoppedEvent {
  /**
   * @member {string} kind Polymorphic Discriminator
   */
  kind: "ChaosStopped";
  /**
   * @member {string} eventInstanceId The identifier for the FabricEvent
   * instance.
   */
  eventInstanceId: string;
  /**
   * @member {Date} timeStamp The time event was logged.
   */
  timeStamp: Date;
  /**
   * @member {boolean} [hasCorrelatedEvents] Shows there is existing related
   * events available.
   */
  hasCorrelatedEvents?: boolean;
  /**
   * @member {string} reason Describes reason.
   */
  reason: string;
}

/**
 * @interface
 * An interface representing ChaosStartedEvent.
 * Chaos Started event.
 *
 */
export interface ChaosStartedEvent {
  /**
   * @member {string} kind Polymorphic Discriminator
   */
  kind: "ChaosStarted";
  /**
   * @member {string} eventInstanceId The identifier for the FabricEvent
   * instance.
   */
  eventInstanceId: string;
  /**
   * @member {Date} timeStamp The time event was logged.
   */
  timeStamp: Date;
  /**
   * @member {boolean} [hasCorrelatedEvents] Shows there is existing related
   * events available.
   */
  hasCorrelatedEvents?: boolean;
  /**
   * @member {number} maxConcurrentFaults Maximum number of concurrent faults.
   */
  maxConcurrentFaults: number;
  /**
   * @member {number} timeToRunInSeconds Time to run in seconds.
   */
  timeToRunInSeconds: number;
  /**
   * @member {number} maxClusterStabilizationTimeoutInSeconds Maximum timeout
   * for cluster stabilization in seconds.
   */
  maxClusterStabilizationTimeoutInSeconds: number;
  /**
   * @member {number} waitTimeBetweenIterationsInSeconds Wait time between
   * iterations in seconds.
   */
  waitTimeBetweenIterationsInSeconds: number;
  /**
   * @member {number} waitTimeBetweenFautlsInSeconds Wait time between faults
   * in seconds.
   */
  waitTimeBetweenFautlsInSeconds: number;
  /**
   * @member {boolean} moveReplicaFaultEnabled Indicates MoveReplica fault is
   * enabled.
   */
  moveReplicaFaultEnabled: boolean;
  /**
   * @member {string} includedNodeTypeList List of included Node types.
   */
  includedNodeTypeList: string;
  /**
   * @member {string} includedApplicationList List of included Applications.
   */
  includedApplicationList: string;
  /**
   * @member {string} clusterHealthPolicy Health policy.
   */
  clusterHealthPolicy: string;
  /**
   * @member {string} chaosContext Chaos Context.
   */
  chaosContext: string;
}

/**
 * @interface
 * An interface representing ChaosRestartNodeFaultCompletedEvent.
 * Chaos Restart Node Fault Completed event.
 *
 */
export interface ChaosRestartNodeFaultCompletedEvent {
  /**
   * @member {string} kind Polymorphic Discriminator
   */
  kind: "ChaosRestartNodeFaultCompleted";
  /**
   * @member {string} eventInstanceId The identifier for the FabricEvent
   * instance.
   */
  eventInstanceId: string;
  /**
   * @member {Date} timeStamp The time event was logged.
   */
  timeStamp: Date;
  /**
   * @member {boolean} [hasCorrelatedEvents] Shows there is existing related
   * events available.
   */
  hasCorrelatedEvents?: boolean;
  /**
   * @member {string} nodeName The name of a Service Fabric node.
   */
  nodeName: string;
  /**
   * @member {number} nodeInstanceId Id of Node instance.
   */
  nodeInstanceId: number;
  /**
   * @member {string} faultGroupId Id of fault group.
   */
  faultGroupId: string;
  /**
   * @member {string} faultId Id of fault.
   */
  faultId: string;
}

/**
 * @interface
 * An interface representing ChaosRestartCodePackageFaultScheduledEvent.
 * Chaos Restart Code Package Fault Scheduled event.
 *
 */
export interface ChaosRestartCodePackageFaultScheduledEvent {
  /**
   * @member {string} kind Polymorphic Discriminator
   */
  kind: "ChaosRestartCodePackageFaultScheduled";
  /**
   * @member {string} eventInstanceId The identifier for the FabricEvent
   * instance.
   */
  eventInstanceId: string;
  /**
   * @member {Date} timeStamp The time event was logged.
   */
  timeStamp: Date;
  /**
   * @member {boolean} [hasCorrelatedEvents] Shows there is existing related
   * events available.
   */
  hasCorrelatedEvents?: boolean;
  /**
   * @member {string} applicationId The identity of the application. This is an
   * encoded representation of the application name. This is used in the REST
   * APIs to identify the application resource.
   * Starting in version 6.0, hierarchical names are delimited with the "\~"
   * character. For example, if the application name is "fabric:/myapp/app1",
   * the application identity would be "myapp\~app1" in 6.0+ and "myapp/app1"
   * in previous versions.
   */
  applicationId: string;
  /**
   * @member {string} faultGroupId Id of fault group.
   */
  faultGroupId: string;
  /**
   * @member {string} faultId Id of fault.
   */
  faultId: string;
  /**
   * @member {string} nodeName The name of a Service Fabric node.
   */
  nodeName: string;
  /**
   * @member {string} serviceManifestName Service manifest name.
   */
  serviceManifestName: string;
  /**
   * @member {string} codePackageName Code package name.
   */
  codePackageName: string;
  /**
   * @member {string} servicePackageActivationId Id of Service package
   * activation.
   */
  servicePackageActivationId: string;
}

/**
 * @interface
 * An interface representing ChaosRestartCodePackageFaultCompletedEvent.
 * Chaos Restart Code Package Fault Completed event.
 *
 */
export interface ChaosRestartCodePackageFaultCompletedEvent {
  /**
   * @member {string} kind Polymorphic Discriminator
   */
  kind: "ChaosRestartCodePackageFaultCompleted";
  /**
   * @member {string} eventInstanceId The identifier for the FabricEvent
   * instance.
   */
  eventInstanceId: string;
  /**
   * @member {Date} timeStamp The time event was logged.
   */
  timeStamp: Date;
  /**
   * @member {boolean} [hasCorrelatedEvents] Shows there is existing related
   * events available.
   */
  hasCorrelatedEvents?: boolean;
  /**
   * @member {string} applicationId The identity of the application. This is an
   * encoded representation of the application name. This is used in the REST
   * APIs to identify the application resource.
   * Starting in version 6.0, hierarchical names are delimited with the "\~"
   * character. For example, if the application name is "fabric:/myapp/app1",
   * the application identity would be "myapp\~app1" in 6.0+ and "myapp/app1"
   * in previous versions.
   */
  applicationId: string;
  /**
   * @member {string} faultGroupId Id of fault group.
   */
  faultGroupId: string;
  /**
   * @member {string} faultId Id of fault.
   */
  faultId: string;
  /**
   * @member {string} nodeName The name of a Service Fabric node.
   */
  nodeName: string;
  /**
   * @member {string} serviceManifestName Service manifest name.
   */
  serviceManifestName: string;
  /**
   * @member {string} codePackageName Code package name.
   */
  codePackageName: string;
  /**
   * @member {string} servicePackageActivationId Id of Service package
   * activation.
   */
  servicePackageActivationId: string;
}

/**
 * @interface
 * An interface representing ChaosRemoveReplicaFaultScheduledEvent.
 * Chaos Remove Replica Fault Scheduled event.
 *
 */
export interface ChaosRemoveReplicaFaultScheduledEvent {
  /**
   * @member {string} kind Polymorphic Discriminator
   */
  kind: "ChaosRemoveReplicaFaultScheduled";
  /**
   * @member {string} eventInstanceId The identifier for the FabricEvent
   * instance.
   */
  eventInstanceId: string;
  /**
   * @member {Date} timeStamp The time event was logged.
   */
  timeStamp: Date;
  /**
   * @member {boolean} [hasCorrelatedEvents] Shows there is existing related
   * events available.
   */
  hasCorrelatedEvents?: boolean;
  /**
   * @member {string} partitionId An internal ID used by Service Fabric to
   * uniquely identify a partition. This is a randomly generated GUID when the
   * service was created. The partition ID is unique and does not change for
   * the lifetime of the service. If the same service was deleted and recreated
   * the IDs of its partitions would be different.
   */
  partitionId: string;
  /**
   * @member {number} replicaId Id of a stateful service replica. ReplicaId is
   * used by Service Fabric to uniquely identify a replica of a partition. It
   * is unique within a partition and does not change for the lifetime of the
   * replica. If a replica gets dropped and another replica gets created on the
   * same node for the same partition, it will get a different value for the
   * id. Sometimes the id of a stateless service instance is also referred as a
   * replica id.
   */
  replicaId: number;
  /**
   * @member {string} faultGroupId Id of fault group.
   */
  faultGroupId: string;
  /**
   * @member {string} faultId Id of fault.
   */
  faultId: string;
  /**
   * @member {string} serviceUri Service name.
   */
  serviceUri: string;
}

/**
 * @interface
 * An interface representing ChaosRemoveReplicaFaultCompletedEvent.
 * Chaos Remove Replica Fault Completed event.
 *
 */
export interface ChaosRemoveReplicaFaultCompletedEvent {
  /**
   * @member {string} kind Polymorphic Discriminator
   */
  kind: "ChaosRemoveReplicaFaultCompleted";
  /**
   * @member {string} eventInstanceId The identifier for the FabricEvent
   * instance.
   */
  eventInstanceId: string;
  /**
   * @member {Date} timeStamp The time event was logged.
   */
  timeStamp: Date;
  /**
   * @member {boolean} [hasCorrelatedEvents] Shows there is existing related
   * events available.
   */
  hasCorrelatedEvents?: boolean;
  /**
   * @member {string} partitionId An internal ID used by Service Fabric to
   * uniquely identify a partition. This is a randomly generated GUID when the
   * service was created. The partition ID is unique and does not change for
   * the lifetime of the service. If the same service was deleted and recreated
   * the IDs of its partitions would be different.
   */
  partitionId: string;
  /**
   * @member {number} replicaId Id of a stateful service replica. ReplicaId is
   * used by Service Fabric to uniquely identify a replica of a partition. It
   * is unique within a partition and does not change for the lifetime of the
   * replica. If a replica gets dropped and another replica gets created on the
   * same node for the same partition, it will get a different value for the
   * id. Sometimes the id of a stateless service instance is also referred as a
   * replica id.
   */
  replicaId: number;
  /**
   * @member {string} faultGroupId Id of fault group.
   */
  faultGroupId: string;
  /**
   * @member {string} faultId Id of fault.
   */
  faultId: string;
  /**
   * @member {string} serviceUri Service name.
   */
  serviceUri: string;
}

/**
 * @interface
 * An interface representing ChaosMoveSecondaryFaultScheduledEvent.
 * Chaos Move Secondary Fault Scheduled event.
 *
 */
export interface ChaosMoveSecondaryFaultScheduledEvent {
  /**
   * @member {string} kind Polymorphic Discriminator
   */
  kind: "ChaosMoveSecondaryFaultScheduled";
  /**
   * @member {string} eventInstanceId The identifier for the FabricEvent
   * instance.
   */
  eventInstanceId: string;
  /**
   * @member {Date} timeStamp The time event was logged.
   */
  timeStamp: Date;
  /**
   * @member {boolean} [hasCorrelatedEvents] Shows there is existing related
   * events available.
   */
  hasCorrelatedEvents?: boolean;
  /**
   * @member {string} partitionId An internal ID used by Service Fabric to
   * uniquely identify a partition. This is a randomly generated GUID when the
   * service was created. The partition ID is unique and does not change for
   * the lifetime of the service. If the same service was deleted and recreated
   * the IDs of its partitions would be different.
   */
  partitionId: string;
  /**
   * @member {string} faultGroupId Id of fault group.
   */
  faultGroupId: string;
  /**
   * @member {string} faultId Id of fault.
   */
  faultId: string;
  /**
   * @member {string} serviceName Service name.
   */
  serviceName: string;
  /**
   * @member {string} sourceNode The name of a Service Fabric node.
   */
  sourceNode: string;
  /**
   * @member {string} destinationNode The name of a Service Fabric node.
   */
  destinationNode: string;
  /**
   * @member {boolean} forcedMove Indicates a forced move.
   */
  forcedMove: boolean;
}

/**
 * @interface
 * An interface representing ChaosMovePrimaryFaultScheduledEvent.
 * Chaos Move Primary Fault Scheduled event.
 *
 */
export interface ChaosMovePrimaryFaultScheduledEvent {
  /**
   * @member {string} kind Polymorphic Discriminator
   */
  kind: "ChaosMovePrimaryFaultScheduled";
  /**
   * @member {string} eventInstanceId The identifier for the FabricEvent
   * instance.
   */
  eventInstanceId: string;
  /**
   * @member {Date} timeStamp The time event was logged.
   */
  timeStamp: Date;
  /**
   * @member {boolean} [hasCorrelatedEvents] Shows there is existing related
   * events available.
   */
  hasCorrelatedEvents?: boolean;
  /**
   * @member {string} partitionId An internal ID used by Service Fabric to
   * uniquely identify a partition. This is a randomly generated GUID when the
   * service was created. The partition ID is unique and does not change for
   * the lifetime of the service. If the same service was deleted and recreated
   * the IDs of its partitions would be different.
   */
  partitionId: string;
  /**
   * @member {string} faultGroupId Id of fault group.
   */
  faultGroupId: string;
  /**
   * @member {string} faultId Id of fault.
   */
  faultId: string;
  /**
   * @member {string} serviceName Service name.
   */
  serviceName: string;
  /**
   * @member {string} nodeTo The name of a Service Fabric node.
   */
  nodeTo: string;
  /**
   * @member {boolean} forcedMove Indicates a forced move.
   */
  forcedMove: boolean;
}

/**
 * @interface
 * An interface representing ChaosRestartReplicaFaultScheduledEvent.
 * Chaos Restart Replica Fault Scheduled event.
 *
 */
export interface ChaosRestartReplicaFaultScheduledEvent {
  /**
   * @member {string} kind Polymorphic Discriminator
   */
  kind: "ChaosRestartReplicaFaultScheduled";
  /**
   * @member {string} eventInstanceId The identifier for the FabricEvent
   * instance.
   */
  eventInstanceId: string;
  /**
   * @member {Date} timeStamp The time event was logged.
   */
  timeStamp: Date;
  /**
   * @member {boolean} [hasCorrelatedEvents] Shows there is existing related
   * events available.
   */
  hasCorrelatedEvents?: boolean;
  /**
   * @member {string} partitionId An internal ID used by Service Fabric to
   * uniquely identify a partition. This is a randomly generated GUID when the
   * service was created. The partition ID is unique and does not change for
   * the lifetime of the service. If the same service was deleted and recreated
   * the IDs of its partitions would be different.
   */
  partitionId: string;
  /**
   * @member {number} replicaId Id of a stateful service replica. ReplicaId is
   * used by Service Fabric to uniquely identify a replica of a partition. It
   * is unique within a partition and does not change for the lifetime of the
   * replica. If a replica gets dropped and another replica gets created on the
   * same node for the same partition, it will get a different value for the
   * id. Sometimes the id of a stateless service instance is also referred as a
   * replica id.
   */
  replicaId: number;
  /**
   * @member {string} faultGroupId Id of fault group.
   */
  faultGroupId: string;
  /**
   * @member {string} faultId Id of fault.
   */
  faultId: string;
  /**
   * @member {string} serviceUri Service name.
   */
  serviceUri: string;
}

/**
 * @interface
 * An interface representing ChaosRestartNodeFaultScheduledEvent.
 * Chaos Restart Node Fault Scheduled event.
 *
 */
export interface ChaosRestartNodeFaultScheduledEvent {
  /**
   * @member {string} kind Polymorphic Discriminator
   */
  kind: "ChaosRestartNodeFaultScheduled";
  /**
   * @member {string} eventInstanceId The identifier for the FabricEvent
   * instance.
   */
  eventInstanceId: string;
  /**
   * @member {Date} timeStamp The time event was logged.
   */
  timeStamp: Date;
  /**
   * @member {boolean} [hasCorrelatedEvents] Shows there is existing related
   * events available.
   */
  hasCorrelatedEvents?: boolean;
  /**
   * @member {string} nodeName The name of a Service Fabric node.
   */
  nodeName: string;
  /**
   * @member {number} nodeInstanceId Id of Node instance.
   */
  nodeInstanceId: number;
  /**
   * @member {string} faultGroupId Id of fault group.
   */
  faultGroupId: string;
  /**
   * @member {string} faultId Id of fault.
   */
  faultId: string;
}

/**
 * @interface
 * An interface representing ServiceResourceDescription.
 * Describes a service fabric service resource.
 *
 */
export interface ServiceResourceDescription {
  /**
   * @member {OperatingSystemTypes} osType The Operating system type required
   * by the code in service. Possible values include: 'Linux', 'Windows'
   */
  osType: OperatingSystemTypes;
  /**
   * @member {ContainerCodePackageProperties[]} codePackages Describes the set
   * of code packages that forms the service. A code package describes the
   * container and the properties for running it. All the code packages are
   * started together on the same host and share the same context (network,
   * process etc.).
   */
  codePackages: ContainerCodePackageProperties[];
  /**
   * @member {NetworkRef[]} [networkRefs] The names of the private networks
   * that this service needs to be part of.
   */
  networkRefs?: NetworkRef[];
  /**
   * @member {DiagnosticsRef} [diagnostics] Reference to sinks in
   * DiagnosticsDescription.
   */
  diagnostics?: DiagnosticsRef;
  /**
   * @member {string} [description] User readable description of the service.
   */
  description?: string;
  /**
   * @member {number} [replicaCount] The number of replicas of the service to
   * create. Defaults to 1 if not specified.
   */
  replicaCount?: number;
  /**
   * @member {HealthState} [healthState] The health state of a Service Fabric
   * entity such as Cluster, Node, Application, Service, Partition, Replica
   * etc. Possible values include: 'Invalid', 'Ok', 'Warning', 'Error',
   * 'Unknown'
   */
  healthState?: HealthState;
  /**
   * @member {ServiceResourceStatus} [status] Represents the status of the
   * service. Possible values include: 'Unknown', 'Active', 'Upgrading',
   * 'Deleting', 'Creating', 'Failed'
   * **NOTE: This property will not be serialized. It can only be populated by
   * the server.**
   */
  readonly status?: ServiceResourceStatus;
  /**
   * @member {string} name Service resource name.
   */
  name: string;
}

/**
 * @interface
 * An interface representing DiagnosticsSinkProperties.
 * Properties of a DiagnosticsSink.
 *
 */
export interface DiagnosticsSinkProperties {
  /**
   * @member {string} kind Polymorphic Discriminator
   */
  kind: "DiagnosticsSinkProperties";
  /**
   * @member {string} [name] Name of the sink. This value is referenced by
   * DiagnosticsReferenceDescription
   */
  name?: string;
  /**
   * @member {string} [description] A description of the sink.
   */
  description?: string;
}

/**
 * @interface
 * An interface representing DiagnosticsDescription.
 * Describes the diagnostics options available
 *
 */
export interface DiagnosticsDescription {
  /**
   * @member {DiagnosticsSinkProperties[]} [sinks] List of supported sinks that
   * can be referenced.
   */
  sinks?: DiagnosticsSinkProperties[];
  /**
   * @member {boolean} [enabled] Status of whether or not sinks are enabled.
   */
  enabled?: boolean;
  /**
   * @member {string[]} [defaultSinkRefs] The sinks to be used if diagnostics
   * is enabled. Sink choices can be overridden at the service and code package
   * level.
   */
  defaultSinkRefs?: string[];
}

/**
 * @interface
 * An interface representing ApplicationResourceDescription.
 * Describes a service fabric application resource.
 *
 */
export interface ApplicationResourceDescription {
  /**
   * @member {string} [description] User readable description of the
   * application.
   */
  description?: string;
  /**
   * @member {string} [debugParams] Internal use.
   */
  debugParams?: string;
  /**
   * @member {ServiceResourceDescription[]} [services] describes the services
   * in the application.
   */
  services?: ServiceResourceDescription[];
  /**
   * @member {HealthState} [healthState] Describes the health state of an
   * application resource. Possible values include: 'Invalid', 'Ok', 'Warning',
   * 'Error', 'Unknown'
   * **NOTE: This property will not be serialized. It can only be populated by
   * the server.**
   */
  readonly healthState?: HealthState;
  /**
   * @member {string} [unhealthyEvaluation] When the application's health state
   * is not 'Ok', this additional details from service fabric Health Manager
   * for the user to know why the application is marked unhealthy.
   * **NOTE: This property will not be serialized. It can only be populated by
   * the server.**
   */
  readonly unhealthyEvaluation?: string;
  /**
   * @member {ApplicationResourceStatus} [status] Status of the application
   * resource. Possible values include: 'Invalid', 'Ready', 'Upgrading',
   * 'Creating', 'Deleting', 'Failed'
   * **NOTE: This property will not be serialized. It can only be populated by
   * the server.**
   */
  readonly status?: ApplicationResourceStatus;
  /**
   * @member {string} [statusDetails] Gives additional information about the
   * current status of the application deployment.
   * **NOTE: This property will not be serialized. It can only be populated by
   * the server.**
   */
  readonly statusDetails?: string;
  /**
   * @member {string[]} [serviceNames] Names of the services in the
   * application.
   * **NOTE: This property will not be serialized. It can only be populated by
   * the server.**
   */
  readonly serviceNames?: string[];
  /**
   * @member {DiagnosticsDescription} [diagnostics] Describes the diagnostics
   * definition and usage for an application resource.
   */
  diagnostics?: DiagnosticsDescription;
  /**
   * @member {string} name Application resource name.
   */
  name: string;
}

/**
 * @interface
 * An interface representing PagedServiceResourceDescriptionList.
 * The list of service resources in the cluster. The list is paged when all of
 * the results cannot fit in a single message. The next set of results can be
 * obtained by executing the same query with the continuation token provided in
 * this list.
 *
 */
export interface PagedServiceResourceDescriptionList {
  /**
   * @member {string} [continuationToken] The continuation token parameter is
   * used to obtain next set of results. The continuation token is included in
   * the response of the API when the results from the system do not fit in a
   * single response. When this value is passed to the next API call, the API
   * returns next set of results. If there are no further results, then the
   * continuation token is not included in the response.
   */
  continuationToken?: string;
  /**
   * @member {ServiceResourceDescription[]} [items] List of service resource
   * description.
   */
  items?: ServiceResourceDescription[];
}

/**
 * @interface
 * An interface representing ServiceReplicaProperties.
 * Describes the properties of a service replica.
 *
 */
export interface ServiceReplicaProperties {
  /**
   * @member {OperatingSystemTypes} osType The Operating system type required
   * by the code in service. Possible values include: 'Linux', 'Windows'
   */
  osType: OperatingSystemTypes;
  /**
   * @member {ContainerCodePackageProperties[]} codePackages Describes the set
   * of code packages that forms the service. A code package describes the
   * container and the properties for running it. All the code packages are
   * started together on the same host and share the same context (network,
   * process etc.).
   */
  codePackages: ContainerCodePackageProperties[];
  /**
   * @member {NetworkRef[]} [networkRefs] The names of the private networks
   * that this service needs to be part of.
   */
  networkRefs?: NetworkRef[];
  /**
   * @member {DiagnosticsRef} [diagnostics] Reference to sinks in
   * DiagnosticsDescription.
   */
  diagnostics?: DiagnosticsRef;
}

/**
 * @interface
 * An interface representing ServiceResourceReplicaDescription.
 * Describes a replica of a service resource.
 *
 * @extends ServiceReplicaProperties
 */
export interface ServiceResourceReplicaDescription extends ServiceReplicaProperties {
  /**
   * @member {string} replicaName Name of the replica.
   */
  replicaName: string;
}

/**
 * @interface
 * An interface representing PagedServiceResourceReplicaDescriptionList.
 * The list of service resources in the cluster. The list is paged when all of
 * the results cannot fit in a single message. The next set of results can be
 * obtained by executing the same query with the continuation token provided in
 * this list.
 *
 */
export interface PagedServiceResourceReplicaDescriptionList {
  /**
   * @member {string} [continuationToken] The continuation token parameter is
   * used to obtain next set of results. The continuation token is included in
   * the response of the API when the results from the system do not fit in a
   * single response. When this value is passed to the next API call, the API
   * returns next set of results. If there are no further results, then the
   * continuation token is not included in the response.
   */
  continuationToken?: string;
  /**
   * @member {ServiceResourceReplicaDescription[]} [items] List of service
   * resource description.
   */
  items?: ServiceResourceReplicaDescription[];
}

/**
 * @interface
 * An interface representing VolumeProviderParametersAzureFile.
 * This type describes a volume provided by an Azure Files file share.
 *
 */
export interface VolumeProviderParametersAzureFile {
  /**
   * @member {string} accountName Name of the Azure storage account for the
   * File Share.
   */
  accountName: string;
  /**
   * @member {string} [accountKey] Access key of the Azure storage account for
   * the File Share.
   */
  accountKey?: string;
  /**
   * @member {string} shareName Name of the Azure Files file share that
   * provides storage for the volume.
   */
  shareName: string;
}

/**
 * @interface
 * An interface representing VolumeResourceDescription.
 * Describes a service fabric volume resource.
 *
 */
export interface VolumeResourceDescription {
  /**
   * @member {string} [description] User readable description of the volume.
   */
  description?: string;
  /**
   * @member {VolumeProviderParametersAzureFile} [azureFileParameters] This
   * type describes a volume provided by an Azure Files file share.
   */
  azureFileParameters?: VolumeProviderParametersAzureFile;
  /**
   * @member {string} name Volume resource name.
   */
  name: string;
}

/**
 * @interface
 * An interface representing ImageRegistryCredential.
 * Image registry credential.
 *
 */
export interface ImageRegistryCredential {
  /**
   * @member {string} server Docker image registry server, without protocol
   * such as `http` and `https`.
   */
  server: string;
  /**
   * @member {string} username The username for the private registry.
   */
  username: string;
  /**
   * @member {string} [password] The password for the private registry.
   */
  password?: string;
}

/**
 * @interface
 * An interface representing EnvironmentVariable.
 * Describes an environment variable for the container.
 *
 */
export interface EnvironmentVariable {
  /**
   * @member {string} [name] The name of the environment variable.
   */
  name?: string;
  /**
   * @member {string} [value] The value of the environment variable.
   */
  value?: string;
}

/**
 * @interface
 * An interface representing Setting.
 * Describes a setting for the container.
 *
 */
export interface Setting {
  /**
   * @member {string} [name] The name of the setting.
   */
  name?: string;
  /**
   * @member {string} [value] The value of the setting.
   */
  value?: string;
}

/**
 * @interface
 * An interface representing ContainerLabel.
 * Describes a container label.
 *
 */
export interface ContainerLabel {
  /**
   * @member {string} name The name of the container label.
   */
  name: string;
  /**
   * @member {string} value The value of the container label.
   */
  value: string;
}

/**
 * @interface
 * An interface representing EndpointProperties.
 * Describes a container endpoint.
 *
 */
export interface EndpointProperties {
  /**
   * @member {string} name The name of the endpoint.
   */
  name: string;
  /**
   * @member {number} [port] Port used by the container.
   */
  port?: number;
}

/**
 * @interface
 * An interface representing ResourceRequests.
 * This type describes the requested resources for a given container. It
 * describes the least amount of resources required for the container. A
 * container can consume more than requested resources up to the specified
 * limits before being restarted. Currently, the requested resources are
 * treated as limits.
 *
 */
export interface ResourceRequests {
  /**
   * @member {number} memoryInGB The memory request in GB for this container.
   */
  memoryInGB: number;
  /**
   * @member {number} cpu Requested number of CPU cores. At present, only full
   * cores are supported.
   */
  cpu: number;
}

/**
 * @interface
 * An interface representing ResourceLimits.
 * This type describes the resource limits for a given container. It describes
 * the most amount of resources a container is allowed to use before being
 * restarted.
 *
 */
export interface ResourceLimits {
  /**
   * @member {number} [memoryInGB] The memory limit in GB.
   */
  memoryInGB?: number;
  /**
   * @member {number} [cpu] CPU limits in cores. At present, only full cores
   * are supported.
   */
  cpu?: number;
}

/**
 * @interface
 * An interface representing ResourceRequirements.
 * This type describes the resource requirements for a container or a service.
 *
 */
export interface ResourceRequirements {
  /**
   * @member {ResourceRequests} requests Describes the requested resources for
   * a given container.
   */
  requests: ResourceRequests;
  /**
   * @member {ResourceLimits} [limits] Describes the maximum limits on the
   * resources for a given container.
   */
  limits?: ResourceLimits;
}

/**
 * @interface
 * An interface representing ContainerVolume.
 * Describes how a volume is attached to a container.
 *
 */
export interface ContainerVolume {
  /**
   * @member {string} name Name of the volume.
   */
  name: string;
  /**
   * @member {boolean} [readOnly] The flag indicating whether the volume is
   * read only. Default is 'false'.
   */
  readOnly?: boolean;
  /**
   * @member {string} destinationPath The path within the container at which
   * the volume should be mounted. Only valid path characters are allowed.
   */
  destinationPath: string;
}

/**
 * @interface
 * An interface representing ContainerState.
 * The container state.
 *
 */
export interface ContainerState {
  /**
   * @member {string} [state] The state of this container
   */
  state?: string;
  /**
   * @member {Date} [startTime] Date/time when the container state started.
   */
  startTime?: Date;
  /**
   * @member {string} [exitCode] The container exit code.
   */
  exitCode?: string;
  /**
   * @member {Date} [finishTime] Date/time when the container state finished.
   */
  finishTime?: Date;
  /**
   * @member {string} [detailStatus] Human-readable status of this state.
   */
  detailStatus?: string;
}

/**
 * @interface
 * An interface representing ContainerEvent.
 * A container event.
 *
 */
export interface ContainerEvent {
  /**
   * @member {string} [name] The name of the container event.
   */
  name?: string;
  /**
   * @member {number} [count] The count of the event.
   */
  count?: number;
  /**
   * @member {string} [firstTimestamp] Date/time of the first event.
   */
  firstTimestamp?: string;
  /**
   * @member {string} [lastTimestamp] Date/time of the last event.
   */
  lastTimestamp?: string;
  /**
   * @member {string} [message] The event message
   */
  message?: string;
  /**
   * @member {string} [type] The event type.
   */
  type?: string;
}

/**
 * @interface
 * An interface representing ContainerInstanceView.
 * Runtime information of a container instance.
 *
 */
export interface ContainerInstanceView {
  /**
   * @member {number} [restartCount] The number of times the container has been
   * restarted.
   */
  restartCount?: number;
  /**
   * @member {ContainerState} [currentState] Current container instance state.
   */
  currentState?: ContainerState;
  /**
   * @member {ContainerState} [previousState] Previous container instance
   * state.
   */
  previousState?: ContainerState;
  /**
   * @member {ContainerEvent[]} [events] The events of this container instance.
   */
  events?: ContainerEvent[];
}

/**
 * @interface
 * An interface representing DiagnosticsRef.
 * Reference to sinks in DiagnosticsDescription.
 *
 */
export interface DiagnosticsRef {
  /**
   * @member {boolean} [enabled] Status of whether or not sinks are enabled.
   */
  enabled?: boolean;
  /**
   * @member {string[]} [sinkRefs] List of sinks to be used if enabled.
   * References the list of sinks in DiagnosticsDescription.
   */
  sinkRefs?: string[];
}

/**
 * @interface
 * An interface representing ContainerCodePackageProperties.
 * Describes a container and its runtime properties.
 *
 */
export interface ContainerCodePackageProperties {
  /**
   * @member {string} name The name of the code package.
   */
  name: string;
  /**
   * @member {string} image The Container image to use.
   */
  image: string;
  /**
   * @member {ImageRegistryCredential} [imageRegistryCredential] Image registry
   * credential.
   */
  imageRegistryCredential?: ImageRegistryCredential;
  /**
   * @member {string} [entrypoint] Override for the default entry point in the
   * container.
   */
  entrypoint?: string;
  /**
   * @member {string[]} [commands] Command array to execute within the
   * container in exec form.
   */
  commands?: string[];
  /**
   * @member {EnvironmentVariable[]} [environmentVariables] The environment
   * variables to set in this container
   */
  environmentVariables?: EnvironmentVariable[];
  /**
   * @member {Setting[]} [settings] The settings to set in this container. The
   * setting file path can be fetched from environment variable
   * "Fabric_SettingPath". The path for Windows container is "C:\\secrets". The
   * path for Linux container is "/var/secrets".
   */
  settings?: Setting[];
  /**
   * @member {ContainerLabel[]} [labels] The labels to set in this container.
   */
  labels?: ContainerLabel[];
  /**
   * @member {EndpointProperties[]} [endpoints] The endpoints exposed by this
   * container.
   */
  endpoints?: EndpointProperties[];
  /**
   * @member {ResourceRequirements} resources This type describes the resource
   * requirements for a container or a service.
   */
  resources: ResourceRequirements;
  /**
   * @member {ContainerVolume[]} [volumeRefs] The volumes to be attached to the
   * container.
   */
  volumeRefs?: ContainerVolume[];
  /**
   * @member {ContainerInstanceView} [instanceView] Runtime information of a
   * container instance.
   * **NOTE: This property will not be serialized. It can only be populated by
   * the server.**
   */
  readonly instanceView?: ContainerInstanceView;
  /**
   * @member {DiagnosticsRef} [diagnostics] Reference to sinks in
   * DiagnosticsDescription.
   */
  diagnostics?: DiagnosticsRef;
}

/**
 * @interface
 * An interface representing NetworkRef.
 * Describes a network reference in a service.
 *
 */
export interface NetworkRef {
  /**
   * @member {string} [name] Name of the network.
   */
  name?: string;
}

/**
 * @interface
 * An interface representing ServiceFabricClientOptions.
 * @extends ServiceClientOptions
 */
export interface ServiceFabricClientOptions extends ServiceClientOptions {
  /**
   * @member {string} [baseUri]
   */
  baseUri?: string;
}

/**
 * @interface
 * An interface representing ServiceFabricClientGetClusterManifestOptionalParams.
 * Optional Parameters.
 *
 * @extends RequestOptionsBase
 */
export interface ServiceFabricClientGetClusterManifestOptionalParams extends msRest.RequestOptionsBase {
  /**
   * @member {number} [timeoutParameter] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds. Default value: 60 .
   */
  timeoutParameter?: number;
}

/**
 * @interface
 * An interface representing ServiceFabricClientGetClusterHealthOptionalParams.
 * Optional Parameters.
 *
 * @extends RequestOptionsBase
 */
export interface ServiceFabricClientGetClusterHealthOptionalParams extends msRest.RequestOptionsBase {
  /**
   * @member {number} [nodesHealthStateFilter] Allows filtering of the node
   * health state objects returned in the result of cluster health query
   * based on their health state. The possible values for this parameter
   * include integer value of one of the
   * following health states. Only nodes that match the filter are returned.
   * All nodes are used to evaluate the aggregated health state.
   * If not specified, all entries are returned.
   * The state values are flag-based enumeration, so the value could be a
   * combination of these values obtained using bitwise 'OR' operator.
   * For example, if the provided value is 6 then health state of nodes with
   * HealthState value of OK (2) and Warning (4) are returned.
   *
   * - Default - Default value. Matches any HealthState. The value is zero.
   * - None - Filter that doesn't match any HealthState value. Used in order to
   * return no results on a given collection of states. The value is 1.
   * - Ok - Filter that matches input with HealthState value Ok. The value is
   * 2.
   * - Warning - Filter that matches input with HealthState value Warning. The
   * value is 4.
   * - Error - Filter that matches input with HealthState value Error. The
   * value is 8.
   * - All - Filter that matches input with any HealthState value. The value is
   * 65535. Default value: 0 .
   */
  nodesHealthStateFilter?: number;
  /**
   * @member {number} [applicationsHealthStateFilter] Allows filtering of the
   * application health state objects returned in the result of cluster health
   * query based on their health state.
   * The possible values for this parameter include integer value obtained from
   * members or bitwise operations
   * on members of HealthStateFilter enumeration. Only applications that match
   * the filter are returned.
   * All applications are used to evaluate the aggregated health state. If not
   * specified, all entries are returned.
   * The state values are flag-based enumeration, so the value could be a
   * combination of these values obtained using bitwise 'OR' operator.
   * For example, if the provided value is 6 then health state of applications
   * with HealthState value of OK (2) and Warning (4) are returned.
   *
   * - Default - Default value. Matches any HealthState. The value is zero.
   * - None - Filter that doesn't match any HealthState value. Used in order to
   * return no results on a given collection of states. The value is 1.
   * - Ok - Filter that matches input with HealthState value Ok. The value is
   * 2.
   * - Warning - Filter that matches input with HealthState value Warning. The
   * value is 4.
   * - Error - Filter that matches input with HealthState value Error. The
   * value is 8.
   * - All - Filter that matches input with any HealthState value. The value is
   * 65535. Default value: 0 .
   */
  applicationsHealthStateFilter?: number;
  /**
   * @member {number} [eventsHealthStateFilter] Allows filtering the collection
   * of HealthEvent objects returned based on health state.
   * The possible values for this parameter include integer value of one of the
   * following health states.
   * Only events that match the filter are returned. All events are used to
   * evaluate the aggregated health state.
   * If not specified, all entries are returned. The state values are
   * flag-based enumeration, so the value could be a combination of these
   * values, obtained using the bitwise 'OR' operator. For example, If the
   * provided value is 6 then all of the events with HealthState value of OK
   * (2) and Warning (4) are returned.
   *
   * - Default - Default value. Matches any HealthState. The value is zero.
   * - None - Filter that doesn't match any HealthState value. Used in order to
   * return no results on a given collection of states. The value is 1.
   * - Ok - Filter that matches input with HealthState value Ok. The value is
   * 2.
   * - Warning - Filter that matches input with HealthState value Warning. The
   * value is 4.
   * - Error - Filter that matches input with HealthState value Error. The
   * value is 8.
   * - All - Filter that matches input with any HealthState value. The value is
   * 65535. Default value: 0 .
   */
  eventsHealthStateFilter?: number;
  /**
   * @member {boolean} [excludeHealthStatistics] Indicates whether the health
   * statistics should be returned as part of the query result. False by
   * default.
   * The statistics show the number of children entities in health state Ok,
   * Warning, and Error. Default value: false .
   */
  excludeHealthStatistics?: boolean;
  /**
   * @member {boolean} [includeSystemApplicationHealthStatistics] Indicates
   * whether the health statistics should include the fabric:/System
   * application health statistics. False by default.
   * If IncludeSystemApplicationHealthStatistics is set to true, the health
   * statistics include the entities that belong to the fabric:/System
   * application.
   * Otherwise, the query result includes health statistics only for user
   * applications.
   * The health statistics must be included in the query result for this
   * parameter to be applied. Default value: false .
   */
  includeSystemApplicationHealthStatistics?: boolean;
  /**
   * @member {number} [timeoutParameter] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds. Default value: 60 .
   */
  timeoutParameter?: number;
}

/**
 * @interface
 * An interface representing ServiceFabricClientGetClusterHealthUsingPolicyOptionalParams.
 * Optional Parameters.
 *
 * @extends RequestOptionsBase
 */
export interface ServiceFabricClientGetClusterHealthUsingPolicyOptionalParams extends msRest.RequestOptionsBase {
  /**
   * @member {number} [nodesHealthStateFilter] Allows filtering of the node
   * health state objects returned in the result of cluster health query
   * based on their health state. The possible values for this parameter
   * include integer value of one of the
   * following health states. Only nodes that match the filter are returned.
   * All nodes are used to evaluate the aggregated health state.
   * If not specified, all entries are returned.
   * The state values are flag-based enumeration, so the value could be a
   * combination of these values obtained using bitwise 'OR' operator.
   * For example, if the provided value is 6 then health state of nodes with
   * HealthState value of OK (2) and Warning (4) are returned.
   *
   * - Default - Default value. Matches any HealthState. The value is zero.
   * - None - Filter that doesn't match any HealthState value. Used in order to
   * return no results on a given collection of states. The value is 1.
   * - Ok - Filter that matches input with HealthState value Ok. The value is
   * 2.
   * - Warning - Filter that matches input with HealthState value Warning. The
   * value is 4.
   * - Error - Filter that matches input with HealthState value Error. The
   * value is 8.
   * - All - Filter that matches input with any HealthState value. The value is
   * 65535. Default value: 0 .
   */
  nodesHealthStateFilter?: number;
  /**
   * @member {number} [applicationsHealthStateFilter] Allows filtering of the
   * application health state objects returned in the result of cluster health
   * query based on their health state.
   * The possible values for this parameter include integer value obtained from
   * members or bitwise operations
   * on members of HealthStateFilter enumeration. Only applications that match
   * the filter are returned.
   * All applications are used to evaluate the aggregated health state. If not
   * specified, all entries are returned.
   * The state values are flag-based enumeration, so the value could be a
   * combination of these values obtained using bitwise 'OR' operator.
   * For example, if the provided value is 6 then health state of applications
   * with HealthState value of OK (2) and Warning (4) are returned.
   *
   * - Default - Default value. Matches any HealthState. The value is zero.
   * - None - Filter that doesn't match any HealthState value. Used in order to
   * return no results on a given collection of states. The value is 1.
   * - Ok - Filter that matches input with HealthState value Ok. The value is
   * 2.
   * - Warning - Filter that matches input with HealthState value Warning. The
   * value is 4.
   * - Error - Filter that matches input with HealthState value Error. The
   * value is 8.
   * - All - Filter that matches input with any HealthState value. The value is
   * 65535. Default value: 0 .
   */
  applicationsHealthStateFilter?: number;
  /**
   * @member {number} [eventsHealthStateFilter] Allows filtering the collection
   * of HealthEvent objects returned based on health state.
   * The possible values for this parameter include integer value of one of the
   * following health states.
   * Only events that match the filter are returned. All events are used to
   * evaluate the aggregated health state.
   * If not specified, all entries are returned. The state values are
   * flag-based enumeration, so the value could be a combination of these
   * values, obtained using the bitwise 'OR' operator. For example, If the
   * provided value is 6 then all of the events with HealthState value of OK
   * (2) and Warning (4) are returned.
   *
   * - Default - Default value. Matches any HealthState. The value is zero.
   * - None - Filter that doesn't match any HealthState value. Used in order to
   * return no results on a given collection of states. The value is 1.
   * - Ok - Filter that matches input with HealthState value Ok. The value is
   * 2.
   * - Warning - Filter that matches input with HealthState value Warning. The
   * value is 4.
   * - Error - Filter that matches input with HealthState value Error. The
   * value is 8.
   * - All - Filter that matches input with any HealthState value. The value is
   * 65535. Default value: 0 .
   */
  eventsHealthStateFilter?: number;
  /**
   * @member {boolean} [excludeHealthStatistics] Indicates whether the health
   * statistics should be returned as part of the query result. False by
   * default.
   * The statistics show the number of children entities in health state Ok,
   * Warning, and Error. Default value: false .
   */
  excludeHealthStatistics?: boolean;
  /**
   * @member {boolean} [includeSystemApplicationHealthStatistics] Indicates
   * whether the health statistics should include the fabric:/System
   * application health statistics. False by default.
   * If IncludeSystemApplicationHealthStatistics is set to true, the health
   * statistics include the entities that belong to the fabric:/System
   * application.
   * Otherwise, the query result includes health statistics only for user
   * applications.
   * The health statistics must be included in the query result for this
   * parameter to be applied. Default value: false .
   */
  includeSystemApplicationHealthStatistics?: boolean;
  /**
   * @member {ClusterHealthPolicies} [clusterHealthPolicies] Describes the
   * health policies used to evaluate the cluster health.
   * If not present, the health evaluation uses the cluster health policy
   * defined in the cluster manifest or the default cluster health policy.
   * By default, each application is evaluated using its specific application
   * health policy, defined in the application manifest, or the default health
   * policy, if no policy is defined in manifest.
   * If the application health policy map is specified, and it has an entry for
   * an application, the specified application health policy
   * is used to evaluate the application health.
   */
  clusterHealthPolicies?: ClusterHealthPolicies;
  /**
   * @member {number} [timeoutParameter] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds. Default value: 60 .
   */
  timeoutParameter?: number;
}

/**
 * @interface
 * An interface representing ServiceFabricClientGetClusterHealthChunkOptionalParams.
 * Optional Parameters.
 *
 * @extends RequestOptionsBase
 */
export interface ServiceFabricClientGetClusterHealthChunkOptionalParams extends msRest.RequestOptionsBase {
  /**
   * @member {number} [timeoutParameter] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds. Default value: 60 .
   */
  timeoutParameter?: number;
}

/**
 * @interface
 * An interface representing ServiceFabricClientGetClusterHealthChunkUsingPolicyAndAdvancedFiltersOptionalParams.
 * Optional Parameters.
 *
 * @extends RequestOptionsBase
 */
export interface ServiceFabricClientGetClusterHealthChunkUsingPolicyAndAdvancedFiltersOptionalParams extends msRest.RequestOptionsBase {
  /**
   * @member {ClusterHealthChunkQueryDescription}
   * [clusterHealthChunkQueryDescription] Describes the cluster and application
   * health policies used to evaluate the cluster health and the filters to
   * select which cluster entities to be returned.
   * If the cluster health policy is present, it is used to evaluate the
   * cluster events and the cluster nodes. If not present, the health
   * evaluation uses the cluster health policy defined in the cluster manifest
   * or the default cluster health policy.
   * By default, each application is evaluated using its specific application
   * health policy, defined in the application manifest, or the default health
   * policy, if no policy is defined in manifest.
   * If the application health policy map is specified, and it has an entry for
   * an application, the specified application health policy
   * is used to evaluate the application health.
   * Users can specify very flexible filters to select which cluster entities
   * to include in response. The selection can be done based on the entities
   * health state and based on the hierarchy.
   * The query can return multi-level children of the entities based on the
   * specified filters. For example, it can return one application with a
   * specified name, and for this application, return
   * only services that are in Error or Warning, and all partitions and
   * replicas for one of these services.
   */
  clusterHealthChunkQueryDescription?: ClusterHealthChunkQueryDescription;
  /**
   * @member {number} [timeoutParameter] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds. Default value: 60 .
   */
  timeoutParameter?: number;
}

/**
 * @interface
 * An interface representing ServiceFabricClientReportClusterHealthOptionalParams.
 * Optional Parameters.
 *
 * @extends RequestOptionsBase
 */
export interface ServiceFabricClientReportClusterHealthOptionalParams extends msRest.RequestOptionsBase {
  /**
   * @member {boolean} [immediate] A flag that indicates whether the report
   * should be sent immediately.
   * A health report is sent to a Service Fabric gateway Application, which
   * forwards to the health store.
   * If Immediate is set to true, the report is sent immediately from HTTP
   * Gateway to the health store, regardless of the fabric client settings that
   * the HTTP Gateway Application is using.
   * This is useful for critical reports that should be sent as soon as
   * possible.
   * Depending on timing and other conditions, sending the report may still
   * fail, for example if the HTTP Gateway is closed or the message doesn't
   * reach the Gateway.
   * If Immediate is set to false, the report is sent based on the health
   * client settings from the HTTP Gateway. Therefore, it will be batched
   * according to the HealthReportSendInterval configuration.
   * This is the recommended setting because it allows the health client to
   * optimize health reporting messages to health store as well as health
   * report processing.
   * By default, reports are not sent immediately. Default value: false .
   */
  immediate?: boolean;
  /**
   * @member {number} [timeoutParameter] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds. Default value: 60 .
   */
  timeoutParameter?: number;
}

/**
 * @interface
 * An interface representing ServiceFabricClientGetProvisionedFabricCodeVersionInfoListOptionalParams.
 * Optional Parameters.
 *
 * @extends RequestOptionsBase
 */
export interface ServiceFabricClientGetProvisionedFabricCodeVersionInfoListOptionalParams extends msRest.RequestOptionsBase {
  /**
   * @member {string} [codeVersion] The product version of Service Fabric.
   */
  codeVersion?: string;
  /**
   * @member {number} [timeoutParameter] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds. Default value: 60 .
   */
  timeoutParameter?: number;
}

/**
 * @interface
 * An interface representing ServiceFabricClientGetProvisionedFabricConfigVersionInfoListOptionalParams.
 * Optional Parameters.
 *
 * @extends RequestOptionsBase
 */
export interface ServiceFabricClientGetProvisionedFabricConfigVersionInfoListOptionalParams extends msRest.RequestOptionsBase {
  /**
   * @member {string} [configVersion] The config version of Service Fabric.
   */
  configVersion?: string;
  /**
   * @member {number} [timeoutParameter] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds. Default value: 60 .
   */
  timeoutParameter?: number;
}

/**
 * @interface
 * An interface representing ServiceFabricClientGetClusterUpgradeProgressOptionalParams.
 * Optional Parameters.
 *
 * @extends RequestOptionsBase
 */
export interface ServiceFabricClientGetClusterUpgradeProgressOptionalParams extends msRest.RequestOptionsBase {
  /**
   * @member {number} [timeoutParameter] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds. Default value: 60 .
   */
  timeoutParameter?: number;
}

/**
 * @interface
 * An interface representing ServiceFabricClientGetClusterConfigurationOptionalParams.
 * Optional Parameters.
 *
 * @extends RequestOptionsBase
 */
export interface ServiceFabricClientGetClusterConfigurationOptionalParams extends msRest.RequestOptionsBase {
  /**
   * @member {number} [timeoutParameter] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds. Default value: 60 .
   */
  timeoutParameter?: number;
}

/**
 * @interface
 * An interface representing ServiceFabricClientGetClusterConfigurationUpgradeStatusOptionalParams.
 * Optional Parameters.
 *
 * @extends RequestOptionsBase
 */
export interface ServiceFabricClientGetClusterConfigurationUpgradeStatusOptionalParams extends msRest.RequestOptionsBase {
  /**
   * @member {number} [timeoutParameter] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds. Default value: 60 .
   */
  timeoutParameter?: number;
}

/**
 * @interface
 * An interface representing ServiceFabricClientGetUpgradeOrchestrationServiceStateOptionalParams.
 * Optional Parameters.
 *
 * @extends RequestOptionsBase
 */
export interface ServiceFabricClientGetUpgradeOrchestrationServiceStateOptionalParams extends msRest.RequestOptionsBase {
  /**
   * @member {number} [timeoutParameter] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds. Default value: 60 .
   */
  timeoutParameter?: number;
}

/**
 * @interface
 * An interface representing ServiceFabricClientSetUpgradeOrchestrationServiceStateOptionalParams.
 * Optional Parameters.
 *
 * @extends RequestOptionsBase
 */
export interface ServiceFabricClientSetUpgradeOrchestrationServiceStateOptionalParams extends msRest.RequestOptionsBase {
  /**
   * @member {number} [timeoutParameter] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds. Default value: 60 .
   */
  timeoutParameter?: number;
}

/**
 * @interface
 * An interface representing ServiceFabricClientProvisionClusterOptionalParams.
 * Optional Parameters.
 *
 * @extends RequestOptionsBase
 */
export interface ServiceFabricClientProvisionClusterOptionalParams extends msRest.RequestOptionsBase {
  /**
   * @member {number} [timeoutParameter] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds. Default value: 60 .
   */
  timeoutParameter?: number;
}

/**
 * @interface
 * An interface representing ServiceFabricClientUnprovisionClusterOptionalParams.
 * Optional Parameters.
 *
 * @extends RequestOptionsBase
 */
export interface ServiceFabricClientUnprovisionClusterOptionalParams extends msRest.RequestOptionsBase {
  /**
   * @member {number} [timeoutParameter] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds. Default value: 60 .
   */
  timeoutParameter?: number;
}

/**
 * @interface
 * An interface representing ServiceFabricClientRollbackClusterUpgradeOptionalParams.
 * Optional Parameters.
 *
 * @extends RequestOptionsBase
 */
export interface ServiceFabricClientRollbackClusterUpgradeOptionalParams extends msRest.RequestOptionsBase {
  /**
   * @member {number} [timeoutParameter] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds. Default value: 60 .
   */
  timeoutParameter?: number;
}

/**
 * @interface
 * An interface representing ServiceFabricClientResumeClusterUpgradeOptionalParams.
 * Optional Parameters.
 *
 * @extends RequestOptionsBase
 */
export interface ServiceFabricClientResumeClusterUpgradeOptionalParams extends msRest.RequestOptionsBase {
  /**
   * @member {number} [timeoutParameter] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds. Default value: 60 .
   */
  timeoutParameter?: number;
}

/**
 * @interface
 * An interface representing ServiceFabricClientStartClusterUpgradeOptionalParams.
 * Optional Parameters.
 *
 * @extends RequestOptionsBase
 */
export interface ServiceFabricClientStartClusterUpgradeOptionalParams extends msRest.RequestOptionsBase {
  /**
   * @member {number} [timeoutParameter] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds. Default value: 60 .
   */
  timeoutParameter?: number;
}

/**
 * @interface
 * An interface representing ServiceFabricClientStartClusterConfigurationUpgradeOptionalParams.
 * Optional Parameters.
 *
 * @extends RequestOptionsBase
 */
export interface ServiceFabricClientStartClusterConfigurationUpgradeOptionalParams extends msRest.RequestOptionsBase {
  /**
   * @member {number} [timeoutParameter] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds. Default value: 60 .
   */
  timeoutParameter?: number;
}

/**
 * @interface
 * An interface representing ServiceFabricClientUpdateClusterUpgradeOptionalParams.
 * Optional Parameters.
 *
 * @extends RequestOptionsBase
 */
export interface ServiceFabricClientUpdateClusterUpgradeOptionalParams extends msRest.RequestOptionsBase {
  /**
   * @member {number} [timeoutParameter] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds. Default value: 60 .
   */
  timeoutParameter?: number;
}

/**
 * @interface
 * An interface representing ServiceFabricClientGetAadMetadataOptionalParams.
 * Optional Parameters.
 *
 * @extends RequestOptionsBase
 */
export interface ServiceFabricClientGetAadMetadataOptionalParams extends msRest.RequestOptionsBase {
  /**
   * @member {number} [timeoutParameter] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds. Default value: 60 .
   */
  timeoutParameter?: number;
}

/**
 * @interface
 * An interface representing ServiceFabricClientGetNodeInfoListOptionalParams.
 * Optional Parameters.
 *
 * @extends RequestOptionsBase
 */
export interface ServiceFabricClientGetNodeInfoListOptionalParams extends msRest.RequestOptionsBase {
  /**
   * @member {string} [continuationToken] The continuation token parameter is
   * used to obtain next set of results. A continuation token with a non-empty
   * value is included in the response of the API when the results from the
   * system do not fit in a single response. When this value is passed to the
   * next API call, the API returns next set of results. If there are no
   * further results, then the continuation token does not contain a value. The
   * value of this parameter should not be URL encoded.
   */
  continuationToken?: string;
  /**
   * @member {NodeStatusFilter} [nodeStatusFilter] Allows filtering the nodes
   * based on the NodeStatus. Only the nodes that are matching the specified
   * filter value will be returned. The filter value can be one of the
   * following. Possible values include: 'default', 'all', 'up', 'down',
   * 'enabling', 'disabling', 'disabled', 'unknown', 'removed'. Default value:
   * 'default' .
   */
  nodeStatusFilter?: NodeStatusFilter;
  /**
   * @member {number} [maxResults] The maximum number of results to be returned
   * as part of the paged queries. This parameter defines the upper bound on
   * the number of results returned. The results returned can be less than the
   * specified maximum results if they do not fit in the message as per the max
   * message size restrictions defined in the configuration. If this parameter
   * is zero or not specified, the paged query includes as many results as
   * possible that fit in the return message. Default value: 0 .
   */
  maxResults?: number;
  /**
   * @member {number} [timeoutParameter] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds. Default value: 60 .
   */
  timeoutParameter?: number;
}

/**
 * @interface
 * An interface representing ServiceFabricClientGetNodeInfoOptionalParams.
 * Optional Parameters.
 *
 * @extends RequestOptionsBase
 */
export interface ServiceFabricClientGetNodeInfoOptionalParams extends msRest.RequestOptionsBase {
  /**
   * @member {number} [timeoutParameter] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds. Default value: 60 .
   */
  timeoutParameter?: number;
}

/**
 * @interface
 * An interface representing ServiceFabricClientGetNodeHealthOptionalParams.
 * Optional Parameters.
 *
 * @extends RequestOptionsBase
 */
export interface ServiceFabricClientGetNodeHealthOptionalParams extends msRest.RequestOptionsBase {
  /**
   * @member {number} [eventsHealthStateFilter] Allows filtering the collection
   * of HealthEvent objects returned based on health state.
   * The possible values for this parameter include integer value of one of the
   * following health states.
   * Only events that match the filter are returned. All events are used to
   * evaluate the aggregated health state.
   * If not specified, all entries are returned. The state values are
   * flag-based enumeration, so the value could be a combination of these
   * values, obtained using the bitwise 'OR' operator. For example, If the
   * provided value is 6 then all of the events with HealthState value of OK
   * (2) and Warning (4) are returned.
   *
   * - Default - Default value. Matches any HealthState. The value is zero.
   * - None - Filter that doesn't match any HealthState value. Used in order to
   * return no results on a given collection of states. The value is 1.
   * - Ok - Filter that matches input with HealthState value Ok. The value is
   * 2.
   * - Warning - Filter that matches input with HealthState value Warning. The
   * value is 4.
   * - Error - Filter that matches input with HealthState value Error. The
   * value is 8.
   * - All - Filter that matches input with any HealthState value. The value is
   * 65535. Default value: 0 .
   */
  eventsHealthStateFilter?: number;
  /**
   * @member {number} [timeoutParameter] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds. Default value: 60 .
   */
  timeoutParameter?: number;
}

/**
 * @interface
 * An interface representing ServiceFabricClientGetNodeHealthUsingPolicyOptionalParams.
 * Optional Parameters.
 *
 * @extends RequestOptionsBase
 */
export interface ServiceFabricClientGetNodeHealthUsingPolicyOptionalParams extends msRest.RequestOptionsBase {
  /**
   * @member {number} [eventsHealthStateFilter] Allows filtering the collection
   * of HealthEvent objects returned based on health state.
   * The possible values for this parameter include integer value of one of the
   * following health states.
   * Only events that match the filter are returned. All events are used to
   * evaluate the aggregated health state.
   * If not specified, all entries are returned. The state values are
   * flag-based enumeration, so the value could be a combination of these
   * values, obtained using the bitwise 'OR' operator. For example, If the
   * provided value is 6 then all of the events with HealthState value of OK
   * (2) and Warning (4) are returned.
   *
   * - Default - Default value. Matches any HealthState. The value is zero.
   * - None - Filter that doesn't match any HealthState value. Used in order to
   * return no results on a given collection of states. The value is 1.
   * - Ok - Filter that matches input with HealthState value Ok. The value is
   * 2.
   * - Warning - Filter that matches input with HealthState value Warning. The
   * value is 4.
   * - Error - Filter that matches input with HealthState value Error. The
   * value is 8.
   * - All - Filter that matches input with any HealthState value. The value is
   * 65535. Default value: 0 .
   */
  eventsHealthStateFilter?: number;
  /**
   * @member {ClusterHealthPolicy} [clusterHealthPolicy] Describes the health
   * policies used to evaluate the health of a cluster or node. If not present,
   * the health evaluation uses the health policy from cluster manifest or the
   * default health policy.
   */
  clusterHealthPolicy?: ClusterHealthPolicy;
  /**
   * @member {number} [timeoutParameter] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds. Default value: 60 .
   */
  timeoutParameter?: number;
}

/**
 * @interface
 * An interface representing ServiceFabricClientReportNodeHealthOptionalParams.
 * Optional Parameters.
 *
 * @extends RequestOptionsBase
 */
export interface ServiceFabricClientReportNodeHealthOptionalParams extends msRest.RequestOptionsBase {
  /**
   * @member {boolean} [immediate] A flag that indicates whether the report
   * should be sent immediately.
   * A health report is sent to a Service Fabric gateway Application, which
   * forwards to the health store.
   * If Immediate is set to true, the report is sent immediately from HTTP
   * Gateway to the health store, regardless of the fabric client settings that
   * the HTTP Gateway Application is using.
   * This is useful for critical reports that should be sent as soon as
   * possible.
   * Depending on timing and other conditions, sending the report may still
   * fail, for example if the HTTP Gateway is closed or the message doesn't
   * reach the Gateway.
   * If Immediate is set to false, the report is sent based on the health
   * client settings from the HTTP Gateway. Therefore, it will be batched
   * according to the HealthReportSendInterval configuration.
   * This is the recommended setting because it allows the health client to
   * optimize health reporting messages to health store as well as health
   * report processing.
   * By default, reports are not sent immediately. Default value: false .
   */
  immediate?: boolean;
  /**
   * @member {number} [timeoutParameter] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds. Default value: 60 .
   */
  timeoutParameter?: number;
}

/**
 * @interface
 * An interface representing ServiceFabricClientGetNodeLoadInfoOptionalParams.
 * Optional Parameters.
 *
 * @extends RequestOptionsBase
 */
export interface ServiceFabricClientGetNodeLoadInfoOptionalParams extends msRest.RequestOptionsBase {
  /**
   * @member {number} [timeoutParameter] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds. Default value: 60 .
   */
  timeoutParameter?: number;
}

/**
 * @interface
 * An interface representing ServiceFabricClientDisableNodeOptionalParams.
 * Optional Parameters.
 *
 * @extends RequestOptionsBase
 */
export interface ServiceFabricClientDisableNodeOptionalParams extends msRest.RequestOptionsBase {
  /**
   * @member {number} [timeoutParameter] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds. Default value: 60 .
   */
  timeoutParameter?: number;
}

/**
 * @interface
 * An interface representing ServiceFabricClientEnableNodeOptionalParams.
 * Optional Parameters.
 *
 * @extends RequestOptionsBase
 */
export interface ServiceFabricClientEnableNodeOptionalParams extends msRest.RequestOptionsBase {
  /**
   * @member {number} [timeoutParameter] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds. Default value: 60 .
   */
  timeoutParameter?: number;
}

/**
 * @interface
 * An interface representing ServiceFabricClientRemoveNodeStateOptionalParams.
 * Optional Parameters.
 *
 * @extends RequestOptionsBase
 */
export interface ServiceFabricClientRemoveNodeStateOptionalParams extends msRest.RequestOptionsBase {
  /**
   * @member {number} [timeoutParameter] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds. Default value: 60 .
   */
  timeoutParameter?: number;
}

/**
 * @interface
 * An interface representing ServiceFabricClientRestartNodeOptionalParams.
 * Optional Parameters.
 *
 * @extends RequestOptionsBase
 */
export interface ServiceFabricClientRestartNodeOptionalParams extends msRest.RequestOptionsBase {
  /**
   * @member {number} [timeoutParameter] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds. Default value: 60 .
   */
  timeoutParameter?: number;
}

/**
 * @interface
 * An interface representing ServiceFabricClientGetApplicationTypeInfoListOptionalParams.
 * Optional Parameters.
 *
 * @extends RequestOptionsBase
 */
export interface ServiceFabricClientGetApplicationTypeInfoListOptionalParams extends msRest.RequestOptionsBase {
  /**
   * @member {number} [applicationTypeDefinitionKindFilter] Used to filter on
   * ApplicationTypeDefinitionKind which is the mechanism used to define a
   * Service Fabric application type.
   * - Default - Default value, which performs the same function as selecting
   * "All". The value is 0.
   * - All - Filter that matches input with any ApplicationTypeDefinitionKind
   * value. The value is 65535.
   * - ServiceFabricApplicationPackage - Filter that matches input with
   * ApplicationTypeDefinitionKind value ServiceFabricApplicationPackage. The
   * value is 1.
   * - Compose - Filter that matches input with ApplicationTypeDefinitionKind
   * value Compose. The value is 2. Default value: 0 .
   */
  applicationTypeDefinitionKindFilter?: number;
  /**
   * @member {boolean} [excludeApplicationParameters] The flag that specifies
   * whether application parameters will be excluded from the result. Default
   * value: false .
   */
  excludeApplicationParameters?: boolean;
  /**
   * @member {string} [continuationToken] The continuation token parameter is
   * used to obtain next set of results. A continuation token with a non-empty
   * value is included in the response of the API when the results from the
   * system do not fit in a single response. When this value is passed to the
   * next API call, the API returns next set of results. If there are no
   * further results, then the continuation token does not contain a value. The
   * value of this parameter should not be URL encoded.
   */
  continuationToken?: string;
  /**
   * @member {number} [maxResults] The maximum number of results to be returned
   * as part of the paged queries. This parameter defines the upper bound on
   * the number of results returned. The results returned can be less than the
   * specified maximum results if they do not fit in the message as per the max
   * message size restrictions defined in the configuration. If this parameter
   * is zero or not specified, the paged query includes as many results as
   * possible that fit in the return message. Default value: 0 .
   */
  maxResults?: number;
  /**
   * @member {number} [timeoutParameter] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds. Default value: 60 .
   */
  timeoutParameter?: number;
}

/**
 * @interface
 * An interface representing ServiceFabricClientGetApplicationTypeInfoListByNameOptionalParams.
 * Optional Parameters.
 *
 * @extends RequestOptionsBase
 */
export interface ServiceFabricClientGetApplicationTypeInfoListByNameOptionalParams extends msRest.RequestOptionsBase {
  /**
   * @member {string} [applicationTypeVersion] The version of the application
   * type.
   */
  applicationTypeVersion?: string;
  /**
   * @member {boolean} [excludeApplicationParameters] The flag that specifies
   * whether application parameters will be excluded from the result. Default
   * value: false .
   */
  excludeApplicationParameters?: boolean;
  /**
   * @member {string} [continuationToken] The continuation token parameter is
   * used to obtain next set of results. A continuation token with a non-empty
   * value is included in the response of the API when the results from the
   * system do not fit in a single response. When this value is passed to the
   * next API call, the API returns next set of results. If there are no
   * further results, then the continuation token does not contain a value. The
   * value of this parameter should not be URL encoded.
   */
  continuationToken?: string;
  /**
   * @member {number} [maxResults] The maximum number of results to be returned
   * as part of the paged queries. This parameter defines the upper bound on
   * the number of results returned. The results returned can be less than the
   * specified maximum results if they do not fit in the message as per the max
   * message size restrictions defined in the configuration. If this parameter
   * is zero or not specified, the paged query includes as many results as
   * possible that fit in the return message. Default value: 0 .
   */
  maxResults?: number;
  /**
   * @member {number} [timeoutParameter] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds. Default value: 60 .
   */
  timeoutParameter?: number;
}

/**
 * @interface
 * An interface representing ServiceFabricClientProvisionApplicationTypeOptionalParams.
 * Optional Parameters.
 *
 * @extends RequestOptionsBase
 */
export interface ServiceFabricClientProvisionApplicationTypeOptionalParams extends msRest.RequestOptionsBase {
  /**
   * @member {number} [timeoutParameter] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds. Default value: 60 .
   */
  timeoutParameter?: number;
}

/**
 * @interface
 * An interface representing ServiceFabricClientUnprovisionApplicationTypeOptionalParams.
 * Optional Parameters.
 *
 * @extends RequestOptionsBase
 */
export interface ServiceFabricClientUnprovisionApplicationTypeOptionalParams extends msRest.RequestOptionsBase {
  /**
   * @member {number} [timeoutParameter] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds. Default value: 60 .
   */
  timeoutParameter?: number;
}

/**
 * @interface
 * An interface representing ServiceFabricClientGetServiceTypeInfoListOptionalParams.
 * Optional Parameters.
 *
 * @extends RequestOptionsBase
 */
export interface ServiceFabricClientGetServiceTypeInfoListOptionalParams extends msRest.RequestOptionsBase {
  /**
   * @member {number} [timeoutParameter] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds. Default value: 60 .
   */
  timeoutParameter?: number;
}

/**
 * @interface
 * An interface representing ServiceFabricClientGetServiceTypeInfoByNameOptionalParams.
 * Optional Parameters.
 *
 * @extends RequestOptionsBase
 */
export interface ServiceFabricClientGetServiceTypeInfoByNameOptionalParams extends msRest.RequestOptionsBase {
  /**
   * @member {number} [timeoutParameter] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds. Default value: 60 .
   */
  timeoutParameter?: number;
}

/**
 * @interface
 * An interface representing ServiceFabricClientGetServiceManifestOptionalParams.
 * Optional Parameters.
 *
 * @extends RequestOptionsBase
 */
export interface ServiceFabricClientGetServiceManifestOptionalParams extends msRest.RequestOptionsBase {
  /**
   * @member {number} [timeoutParameter] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds. Default value: 60 .
   */
  timeoutParameter?: number;
}

/**
 * @interface
 * An interface representing ServiceFabricClientGetDeployedServiceTypeInfoListOptionalParams.
 * Optional Parameters.
 *
 * @extends RequestOptionsBase
 */
export interface ServiceFabricClientGetDeployedServiceTypeInfoListOptionalParams extends msRest.RequestOptionsBase {
  /**
   * @member {string} [serviceManifestName] The name of the service manifest to
   * filter the list of deployed service type information. If specified, the
   * response will only contain the information about service types that are
   * defined in this service manifest.
   */
  serviceManifestName?: string;
  /**
   * @member {number} [timeoutParameter] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds. Default value: 60 .
   */
  timeoutParameter?: number;
}

/**
 * @interface
 * An interface representing ServiceFabricClientGetDeployedServiceTypeInfoByNameOptionalParams.
 * Optional Parameters.
 *
 * @extends RequestOptionsBase
 */
export interface ServiceFabricClientGetDeployedServiceTypeInfoByNameOptionalParams extends msRest.RequestOptionsBase {
  /**
   * @member {string} [serviceManifestName] The name of the service manifest to
   * filter the list of deployed service type information. If specified, the
   * response will only contain the information about service types that are
   * defined in this service manifest.
   */
  serviceManifestName?: string;
  /**
   * @member {number} [timeoutParameter] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds. Default value: 60 .
   */
  timeoutParameter?: number;
}

/**
 * @interface
 * An interface representing ServiceFabricClientCreateApplicationOptionalParams.
 * Optional Parameters.
 *
 * @extends RequestOptionsBase
 */
export interface ServiceFabricClientCreateApplicationOptionalParams extends msRest.RequestOptionsBase {
  /**
   * @member {number} [timeoutParameter] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds. Default value: 60 .
   */
  timeoutParameter?: number;
}

/**
 * @interface
 * An interface representing ServiceFabricClientDeleteApplicationOptionalParams.
 * Optional Parameters.
 *
 * @extends RequestOptionsBase
 */
export interface ServiceFabricClientDeleteApplicationOptionalParams extends msRest.RequestOptionsBase {
  /**
   * @member {boolean} [forceRemove] Remove a Service Fabric application or
   * service forcefully without going through the graceful shutdown sequence.
   * This parameter can be used to forcefully delete an application or service
   * for which delete is timing out due to issues in the service code that
   * prevents graceful close of replicas.
   */
  forceRemove?: boolean;
  /**
   * @member {number} [timeoutParameter] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds. Default value: 60 .
   */
  timeoutParameter?: number;
}

/**
 * @interface
 * An interface representing ServiceFabricClientGetApplicationLoadInfoOptionalParams.
 * Optional Parameters.
 *
 * @extends RequestOptionsBase
 */
export interface ServiceFabricClientGetApplicationLoadInfoOptionalParams extends msRest.RequestOptionsBase {
  /**
   * @member {number} [timeoutParameter] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds. Default value: 60 .
   */
  timeoutParameter?: number;
}

/**
 * @interface
 * An interface representing ServiceFabricClientGetApplicationInfoListOptionalParams.
 * Optional Parameters.
 *
 * @extends RequestOptionsBase
 */
export interface ServiceFabricClientGetApplicationInfoListOptionalParams extends msRest.RequestOptionsBase {
  /**
   * @member {number} [applicationDefinitionKindFilter] Used to filter on
   * ApplicationDefinitionKind, which is the mechanism used to define a Service
   * Fabric application.
   * - Default - Default value, which performs the same function as selecting
   * "All". The value is 0.
   * - All - Filter that matches input with any ApplicationDefinitionKind
   * value. The value is 65535.
   * - ServiceFabricApplicationDescription - Filter that matches input with
   * ApplicationDefinitionKind value ServiceFabricApplicationDescription. The
   * value is 1.
   * - Compose - Filter that matches input with ApplicationDefinitionKind value
   * Compose. The value is 2. Default value: 0 .
   */
  applicationDefinitionKindFilter?: number;
  /**
   * @member {string} [applicationTypeName] The application type name used to
   * filter the applications to query for. This value should not contain the
   * application type version.
   */
  applicationTypeName?: string;
  /**
   * @member {boolean} [excludeApplicationParameters] The flag that specifies
   * whether application parameters will be excluded from the result. Default
   * value: false .
   */
  excludeApplicationParameters?: boolean;
  /**
   * @member {string} [continuationToken] The continuation token parameter is
   * used to obtain next set of results. A continuation token with a non-empty
   * value is included in the response of the API when the results from the
   * system do not fit in a single response. When this value is passed to the
   * next API call, the API returns next set of results. If there are no
   * further results, then the continuation token does not contain a value. The
   * value of this parameter should not be URL encoded.
   */
  continuationToken?: string;
  /**
   * @member {number} [maxResults] The maximum number of results to be returned
   * as part of the paged queries. This parameter defines the upper bound on
   * the number of results returned. The results returned can be less than the
   * specified maximum results if they do not fit in the message as per the max
   * message size restrictions defined in the configuration. If this parameter
   * is zero or not specified, the paged query includes as many results as
   * possible that fit in the return message. Default value: 0 .
   */
  maxResults?: number;
  /**
   * @member {number} [timeoutParameter] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds. Default value: 60 .
   */
  timeoutParameter?: number;
}

/**
 * @interface
 * An interface representing ServiceFabricClientGetApplicationInfoOptionalParams.
 * Optional Parameters.
 *
 * @extends RequestOptionsBase
 */
export interface ServiceFabricClientGetApplicationInfoOptionalParams extends msRest.RequestOptionsBase {
  /**
   * @member {boolean} [excludeApplicationParameters] The flag that specifies
   * whether application parameters will be excluded from the result. Default
   * value: false .
   */
  excludeApplicationParameters?: boolean;
  /**
   * @member {number} [timeoutParameter] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds. Default value: 60 .
   */
  timeoutParameter?: number;
}

/**
 * @interface
 * An interface representing ServiceFabricClientGetApplicationHealthOptionalParams.
 * Optional Parameters.
 *
 * @extends RequestOptionsBase
 */
export interface ServiceFabricClientGetApplicationHealthOptionalParams extends msRest.RequestOptionsBase {
  /**
   * @member {number} [eventsHealthStateFilter] Allows filtering the collection
   * of HealthEvent objects returned based on health state.
   * The possible values for this parameter include integer value of one of the
   * following health states.
   * Only events that match the filter are returned. All events are used to
   * evaluate the aggregated health state.
   * If not specified, all entries are returned. The state values are
   * flag-based enumeration, so the value could be a combination of these
   * values, obtained using the bitwise 'OR' operator. For example, If the
   * provided value is 6 then all of the events with HealthState value of OK
   * (2) and Warning (4) are returned.
   *
   * - Default - Default value. Matches any HealthState. The value is zero.
   * - None - Filter that doesn't match any HealthState value. Used in order to
   * return no results on a given collection of states. The value is 1.
   * - Ok - Filter that matches input with HealthState value Ok. The value is
   * 2.
   * - Warning - Filter that matches input with HealthState value Warning. The
   * value is 4.
   * - Error - Filter that matches input with HealthState value Error. The
   * value is 8.
   * - All - Filter that matches input with any HealthState value. The value is
   * 65535. Default value: 0 .
   */
  eventsHealthStateFilter?: number;
  /**
   * @member {number} [deployedApplicationsHealthStateFilter] Allows filtering
   * of the deployed applications health state objects returned in the result
   * of application health query based on their health state.
   * The possible values for this parameter include integer value of one of the
   * following health states. Only deployed applications that match the filter
   * will be returned.
   * All deployed applications are used to evaluate the aggregated health
   * state. If not specified, all entries are returned.
   * The state values are flag-based enumeration, so the value could be a
   * combination of these values, obtained using bitwise 'OR' operator.
   * For example, if the provided value is 6 then health state of deployed
   * applications with HealthState value of OK (2) and Warning (4) are
   * returned.
   *
   * - Default - Default value. Matches any HealthState. The value is zero.
   * - None - Filter that doesn't match any HealthState value. Used in order to
   * return no results on a given collection of states. The value is 1.
   * - Ok - Filter that matches input with HealthState value Ok. The value is
   * 2.
   * - Warning - Filter that matches input with HealthState value Warning. The
   * value is 4.
   * - Error - Filter that matches input with HealthState value Error. The
   * value is 8.
   * - All - Filter that matches input with any HealthState value. The value is
   * 65535. Default value: 0 .
   */
  deployedApplicationsHealthStateFilter?: number;
  /**
   * @member {number} [servicesHealthStateFilter] Allows filtering of the
   * services health state objects returned in the result of services health
   * query based on their health state.
   * The possible values for this parameter include integer value of one of the
   * following health states.
   * Only services that match the filter are returned. All services are used to
   * evaluate the aggregated health state.
   * If not specified, all entries are returned. The state values are
   * flag-based enumeration, so the value could be a combination of these
   * values,
   * obtained using bitwise 'OR' operator. For example, if the provided value
   * is 6 then health state of services with HealthState value of OK (2) and
   * Warning (4) will be returned.
   *
   * - Default - Default value. Matches any HealthState. The value is zero.
   * - None - Filter that doesn't match any HealthState value. Used in order to
   * return no results on a given collection of states. The value is 1.
   * - Ok - Filter that matches input with HealthState value Ok. The value is
   * 2.
   * - Warning - Filter that matches input with HealthState value Warning. The
   * value is 4.
   * - Error - Filter that matches input with HealthState value Error. The
   * value is 8.
   * - All - Filter that matches input with any HealthState value. The value is
   * 65535. Default value: 0 .
   */
  servicesHealthStateFilter?: number;
  /**
   * @member {boolean} [excludeHealthStatistics] Indicates whether the health
   * statistics should be returned as part of the query result. False by
   * default.
   * The statistics show the number of children entities in health state Ok,
   * Warning, and Error. Default value: false .
   */
  excludeHealthStatistics?: boolean;
  /**
   * @member {number} [timeoutParameter] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds. Default value: 60 .
   */
  timeoutParameter?: number;
}

/**
 * @interface
 * An interface representing ServiceFabricClientGetApplicationHealthUsingPolicyOptionalParams.
 * Optional Parameters.
 *
 * @extends RequestOptionsBase
 */
export interface ServiceFabricClientGetApplicationHealthUsingPolicyOptionalParams extends msRest.RequestOptionsBase {
  /**
   * @member {number} [eventsHealthStateFilter] Allows filtering the collection
   * of HealthEvent objects returned based on health state.
   * The possible values for this parameter include integer value of one of the
   * following health states.
   * Only events that match the filter are returned. All events are used to
   * evaluate the aggregated health state.
   * If not specified, all entries are returned. The state values are
   * flag-based enumeration, so the value could be a combination of these
   * values, obtained using the bitwise 'OR' operator. For example, If the
   * provided value is 6 then all of the events with HealthState value of OK
   * (2) and Warning (4) are returned.
   *
   * - Default - Default value. Matches any HealthState. The value is zero.
   * - None - Filter that doesn't match any HealthState value. Used in order to
   * return no results on a given collection of states. The value is 1.
   * - Ok - Filter that matches input with HealthState value Ok. The value is
   * 2.
   * - Warning - Filter that matches input with HealthState value Warning. The
   * value is 4.
   * - Error - Filter that matches input with HealthState value Error. The
   * value is 8.
   * - All - Filter that matches input with any HealthState value. The value is
   * 65535. Default value: 0 .
   */
  eventsHealthStateFilter?: number;
  /**
   * @member {number} [deployedApplicationsHealthStateFilter] Allows filtering
   * of the deployed applications health state objects returned in the result
   * of application health query based on their health state.
   * The possible values for this parameter include integer value of one of the
   * following health states. Only deployed applications that match the filter
   * will be returned.
   * All deployed applications are used to evaluate the aggregated health
   * state. If not specified, all entries are returned.
   * The state values are flag-based enumeration, so the value could be a
   * combination of these values, obtained using bitwise 'OR' operator.
   * For example, if the provided value is 6 then health state of deployed
   * applications with HealthState value of OK (2) and Warning (4) are
   * returned.
   *
   * - Default - Default value. Matches any HealthState. The value is zero.
   * - None - Filter that doesn't match any HealthState value. Used in order to
   * return no results on a given collection of states. The value is 1.
   * - Ok - Filter that matches input with HealthState value Ok. The value is
   * 2.
   * - Warning - Filter that matches input with HealthState value Warning. The
   * value is 4.
   * - Error - Filter that matches input with HealthState value Error. The
   * value is 8.
   * - All - Filter that matches input with any HealthState value. The value is
   * 65535. Default value: 0 .
   */
  deployedApplicationsHealthStateFilter?: number;
  /**
   * @member {number} [servicesHealthStateFilter] Allows filtering of the
   * services health state objects returned in the result of services health
   * query based on their health state.
   * The possible values for this parameter include integer value of one of the
   * following health states.
   * Only services that match the filter are returned. All services are used to
   * evaluate the aggregated health state.
   * If not specified, all entries are returned. The state values are
   * flag-based enumeration, so the value could be a combination of these
   * values,
   * obtained using bitwise 'OR' operator. For example, if the provided value
   * is 6 then health state of services with HealthState value of OK (2) and
   * Warning (4) will be returned.
   *
   * - Default - Default value. Matches any HealthState. The value is zero.
   * - None - Filter that doesn't match any HealthState value. Used in order to
   * return no results on a given collection of states. The value is 1.
   * - Ok - Filter that matches input with HealthState value Ok. The value is
   * 2.
   * - Warning - Filter that matches input with HealthState value Warning. The
   * value is 4.
   * - Error - Filter that matches input with HealthState value Error. The
   * value is 8.
   * - All - Filter that matches input with any HealthState value. The value is
   * 65535. Default value: 0 .
   */
  servicesHealthStateFilter?: number;
  /**
   * @member {boolean} [excludeHealthStatistics] Indicates whether the health
   * statistics should be returned as part of the query result. False by
   * default.
   * The statistics show the number of children entities in health state Ok,
   * Warning, and Error. Default value: false .
   */
  excludeHealthStatistics?: boolean;
  /**
   * @member {ApplicationHealthPolicy} [applicationHealthPolicy] Describes the
   * health policies used to evaluate the health of an application or one of
   * its children.
   * If not present, the health evaluation uses the health policy from
   * application manifest or the default health policy.
   */
  applicationHealthPolicy?: ApplicationHealthPolicy;
  /**
   * @member {number} [timeoutParameter] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds. Default value: 60 .
   */
  timeoutParameter?: number;
}

/**
 * @interface
 * An interface representing ServiceFabricClientReportApplicationHealthOptionalParams.
 * Optional Parameters.
 *
 * @extends RequestOptionsBase
 */
export interface ServiceFabricClientReportApplicationHealthOptionalParams extends msRest.RequestOptionsBase {
  /**
   * @member {boolean} [immediate] A flag that indicates whether the report
   * should be sent immediately.
   * A health report is sent to a Service Fabric gateway Application, which
   * forwards to the health store.
   * If Immediate is set to true, the report is sent immediately from HTTP
   * Gateway to the health store, regardless of the fabric client settings that
   * the HTTP Gateway Application is using.
   * This is useful for critical reports that should be sent as soon as
   * possible.
   * Depending on timing and other conditions, sending the report may still
   * fail, for example if the HTTP Gateway is closed or the message doesn't
   * reach the Gateway.
   * If Immediate is set to false, the report is sent based on the health
   * client settings from the HTTP Gateway. Therefore, it will be batched
   * according to the HealthReportSendInterval configuration.
   * This is the recommended setting because it allows the health client to
   * optimize health reporting messages to health store as well as health
   * report processing.
   * By default, reports are not sent immediately. Default value: false .
   */
  immediate?: boolean;
  /**
   * @member {number} [timeoutParameter] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds. Default value: 60 .
   */
  timeoutParameter?: number;
}

/**
 * @interface
 * An interface representing ServiceFabricClientStartApplicationUpgradeOptionalParams.
 * Optional Parameters.
 *
 * @extends RequestOptionsBase
 */
export interface ServiceFabricClientStartApplicationUpgradeOptionalParams extends msRest.RequestOptionsBase {
  /**
   * @member {number} [timeoutParameter] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds. Default value: 60 .
   */
  timeoutParameter?: number;
}

/**
 * @interface
 * An interface representing ServiceFabricClientGetApplicationUpgradeOptionalParams.
 * Optional Parameters.
 *
 * @extends RequestOptionsBase
 */
export interface ServiceFabricClientGetApplicationUpgradeOptionalParams extends msRest.RequestOptionsBase {
  /**
   * @member {number} [timeoutParameter] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds. Default value: 60 .
   */
  timeoutParameter?: number;
}

/**
 * @interface
 * An interface representing ServiceFabricClientUpdateApplicationUpgradeOptionalParams.
 * Optional Parameters.
 *
 * @extends RequestOptionsBase
 */
export interface ServiceFabricClientUpdateApplicationUpgradeOptionalParams extends msRest.RequestOptionsBase {
  /**
   * @member {number} [timeoutParameter] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds. Default value: 60 .
   */
  timeoutParameter?: number;
}

/**
 * @interface
 * An interface representing ServiceFabricClientResumeApplicationUpgradeOptionalParams.
 * Optional Parameters.
 *
 * @extends RequestOptionsBase
 */
export interface ServiceFabricClientResumeApplicationUpgradeOptionalParams extends msRest.RequestOptionsBase {
  /**
   * @member {number} [timeoutParameter] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds. Default value: 60 .
   */
  timeoutParameter?: number;
}

/**
 * @interface
 * An interface representing ServiceFabricClientRollbackApplicationUpgradeOptionalParams.
 * Optional Parameters.
 *
 * @extends RequestOptionsBase
 */
export interface ServiceFabricClientRollbackApplicationUpgradeOptionalParams extends msRest.RequestOptionsBase {
  /**
   * @member {number} [timeoutParameter] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds. Default value: 60 .
   */
  timeoutParameter?: number;
}

/**
 * @interface
 * An interface representing ServiceFabricClientGetDeployedApplicationInfoListOptionalParams.
 * Optional Parameters.
 *
 * @extends RequestOptionsBase
 */
export interface ServiceFabricClientGetDeployedApplicationInfoListOptionalParams extends msRest.RequestOptionsBase {
  /**
   * @member {number} [timeoutParameter] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds. Default value: 60 .
   */
  timeoutParameter?: number;
  /**
   * @member {boolean} [includeHealthState] Include the health state of an
   * entity.
   * If this parameter is false or not specified, then the health state
   * returned is "Unknown".
   * When set to true, the query goes in parallel to the node and the health
   * system service before the results are merged.
   * As a result, the query is more expensive and may take a longer time.
   * Default value: false .
   */
  includeHealthState?: boolean;
  /**
   * @member {string} [continuationToken] The continuation token parameter is
   * used to obtain next set of results. A continuation token with a non-empty
   * value is included in the response of the API when the results from the
   * system do not fit in a single response. When this value is passed to the
   * next API call, the API returns next set of results. If there are no
   * further results, then the continuation token does not contain a value. The
   * value of this parameter should not be URL encoded.
   */
  continuationToken?: string;
  /**
   * @member {number} [maxResults] The maximum number of results to be returned
   * as part of the paged queries. This parameter defines the upper bound on
   * the number of results returned. The results returned can be less than the
   * specified maximum results if they do not fit in the message as per the max
   * message size restrictions defined in the configuration. If this parameter
   * is zero or not specified, the paged query includes as many results as
   * possible that fit in the return message. Default value: 0 .
   */
  maxResults?: number;
}

/**
 * @interface
 * An interface representing ServiceFabricClientGetDeployedApplicationInfoOptionalParams.
 * Optional Parameters.
 *
 * @extends RequestOptionsBase
 */
export interface ServiceFabricClientGetDeployedApplicationInfoOptionalParams extends msRest.RequestOptionsBase {
  /**
   * @member {number} [timeoutParameter] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds. Default value: 60 .
   */
  timeoutParameter?: number;
  /**
   * @member {boolean} [includeHealthState] Include the health state of an
   * entity.
   * If this parameter is false or not specified, then the health state
   * returned is "Unknown".
   * When set to true, the query goes in parallel to the node and the health
   * system service before the results are merged.
   * As a result, the query is more expensive and may take a longer time.
   * Default value: false .
   */
  includeHealthState?: boolean;
}

/**
 * @interface
 * An interface representing ServiceFabricClientGetDeployedApplicationHealthOptionalParams.
 * Optional Parameters.
 *
 * @extends RequestOptionsBase
 */
export interface ServiceFabricClientGetDeployedApplicationHealthOptionalParams extends msRest.RequestOptionsBase {
  /**
   * @member {number} [eventsHealthStateFilter] Allows filtering the collection
   * of HealthEvent objects returned based on health state.
   * The possible values for this parameter include integer value of one of the
   * following health states.
   * Only events that match the filter are returned. All events are used to
   * evaluate the aggregated health state.
   * If not specified, all entries are returned. The state values are
   * flag-based enumeration, so the value could be a combination of these
   * values, obtained using the bitwise 'OR' operator. For example, If the
   * provided value is 6 then all of the events with HealthState value of OK
   * (2) and Warning (4) are returned.
   *
   * - Default - Default value. Matches any HealthState. The value is zero.
   * - None - Filter that doesn't match any HealthState value. Used in order to
   * return no results on a given collection of states. The value is 1.
   * - Ok - Filter that matches input with HealthState value Ok. The value is
   * 2.
   * - Warning - Filter that matches input with HealthState value Warning. The
   * value is 4.
   * - Error - Filter that matches input with HealthState value Error. The
   * value is 8.
   * - All - Filter that matches input with any HealthState value. The value is
   * 65535. Default value: 0 .
   */
  eventsHealthStateFilter?: number;
  /**
   * @member {number} [deployedServicePackagesHealthStateFilter] Allows
   * filtering of the deployed service package health state objects returned in
   * the result of deployed application health query based on their health
   * state.
   * The possible values for this parameter include integer value of one of the
   * following health states.
   * Only deployed service packages that match the filter are returned. All
   * deployed service packages are used to evaluate the aggregated health state
   * of the deployed application.
   * If not specified, all entries are returned.
   * The state values are flag-based enumeration, so the value can be a
   * combination of these values, obtained using the bitwise 'OR' operator.
   * For example, if the provided value is 6 then health state of service
   * packages with HealthState value of OK (2) and Warning (4) are returned.
   *
   * - Default - Default value. Matches any HealthState. The value is zero.
   * - None - Filter that doesn't match any HealthState value. Used in order to
   * return no results on a given collection of states. The value is 1.
   * - Ok - Filter that matches input with HealthState value Ok. The value is
   * 2.
   * - Warning - Filter that matches input with HealthState value Warning. The
   * value is 4.
   * - Error - Filter that matches input with HealthState value Error. The
   * value is 8.
   * - All - Filter that matches input with any HealthState value. The value is
   * 65535. Default value: 0 .
   */
  deployedServicePackagesHealthStateFilter?: number;
  /**
   * @member {boolean} [excludeHealthStatistics] Indicates whether the health
   * statistics should be returned as part of the query result. False by
   * default.
   * The statistics show the number of children entities in health state Ok,
   * Warning, and Error. Default value: false .
   */
  excludeHealthStatistics?: boolean;
  /**
   * @member {number} [timeoutParameter] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds. Default value: 60 .
   */
  timeoutParameter?: number;
}

/**
 * @interface
 * An interface representing ServiceFabricClientGetDeployedApplicationHealthUsingPolicyOptionalParams.
 * Optional Parameters.
 *
 * @extends RequestOptionsBase
 */
export interface ServiceFabricClientGetDeployedApplicationHealthUsingPolicyOptionalParams extends msRest.RequestOptionsBase {
  /**
   * @member {number} [eventsHealthStateFilter] Allows filtering the collection
   * of HealthEvent objects returned based on health state.
   * The possible values for this parameter include integer value of one of the
   * following health states.
   * Only events that match the filter are returned. All events are used to
   * evaluate the aggregated health state.
   * If not specified, all entries are returned. The state values are
   * flag-based enumeration, so the value could be a combination of these
   * values, obtained using the bitwise 'OR' operator. For example, If the
   * provided value is 6 then all of the events with HealthState value of OK
   * (2) and Warning (4) are returned.
   *
   * - Default - Default value. Matches any HealthState. The value is zero.
   * - None - Filter that doesn't match any HealthState value. Used in order to
   * return no results on a given collection of states. The value is 1.
   * - Ok - Filter that matches input with HealthState value Ok. The value is
   * 2.
   * - Warning - Filter that matches input with HealthState value Warning. The
   * value is 4.
   * - Error - Filter that matches input with HealthState value Error. The
   * value is 8.
   * - All - Filter that matches input with any HealthState value. The value is
   * 65535. Default value: 0 .
   */
  eventsHealthStateFilter?: number;
  /**
   * @member {number} [deployedServicePackagesHealthStateFilter] Allows
   * filtering of the deployed service package health state objects returned in
   * the result of deployed application health query based on their health
   * state.
   * The possible values for this parameter include integer value of one of the
   * following health states.
   * Only deployed service packages that match the filter are returned. All
   * deployed service packages are used to evaluate the aggregated health state
   * of the deployed application.
   * If not specified, all entries are returned.
   * The state values are flag-based enumeration, so the value can be a
   * combination of these values, obtained using the bitwise 'OR' operator.
   * For example, if the provided value is 6 then health state of service
   * packages with HealthState value of OK (2) and Warning (4) are returned.
   *
   * - Default - Default value. Matches any HealthState. The value is zero.
   * - None - Filter that doesn't match any HealthState value. Used in order to
   * return no results on a given collection of states. The value is 1.
   * - Ok - Filter that matches input with HealthState value Ok. The value is
   * 2.
   * - Warning - Filter that matches input with HealthState value Warning. The
   * value is 4.
   * - Error - Filter that matches input with HealthState value Error. The
   * value is 8.
   * - All - Filter that matches input with any HealthState value. The value is
   * 65535. Default value: 0 .
   */
  deployedServicePackagesHealthStateFilter?: number;
  /**
   * @member {ApplicationHealthPolicy} [applicationHealthPolicy] Describes the
   * health policies used to evaluate the health of an application or one of
   * its children.
   * If not present, the health evaluation uses the health policy from
   * application manifest or the default health policy.
   */
  applicationHealthPolicy?: ApplicationHealthPolicy;
  /**
   * @member {boolean} [excludeHealthStatistics] Indicates whether the health
   * statistics should be returned as part of the query result. False by
   * default.
   * The statistics show the number of children entities in health state Ok,
   * Warning, and Error. Default value: false .
   */
  excludeHealthStatistics?: boolean;
  /**
   * @member {number} [timeoutParameter] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds. Default value: 60 .
   */
  timeoutParameter?: number;
}

/**
 * @interface
 * An interface representing ServiceFabricClientReportDeployedApplicationHealthOptionalParams.
 * Optional Parameters.
 *
 * @extends RequestOptionsBase
 */
export interface ServiceFabricClientReportDeployedApplicationHealthOptionalParams extends msRest.RequestOptionsBase {
  /**
   * @member {boolean} [immediate] A flag that indicates whether the report
   * should be sent immediately.
   * A health report is sent to a Service Fabric gateway Application, which
   * forwards to the health store.
   * If Immediate is set to true, the report is sent immediately from HTTP
   * Gateway to the health store, regardless of the fabric client settings that
   * the HTTP Gateway Application is using.
   * This is useful for critical reports that should be sent as soon as
   * possible.
   * Depending on timing and other conditions, sending the report may still
   * fail, for example if the HTTP Gateway is closed or the message doesn't
   * reach the Gateway.
   * If Immediate is set to false, the report is sent based on the health
   * client settings from the HTTP Gateway. Therefore, it will be batched
   * according to the HealthReportSendInterval configuration.
   * This is the recommended setting because it allows the health client to
   * optimize health reporting messages to health store as well as health
   * report processing.
   * By default, reports are not sent immediately. Default value: false .
   */
  immediate?: boolean;
  /**
   * @member {number} [timeoutParameter] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds. Default value: 60 .
   */
  timeoutParameter?: number;
}

/**
 * @interface
 * An interface representing ServiceFabricClientGetApplicationManifestOptionalParams.
 * Optional Parameters.
 *
 * @extends RequestOptionsBase
 */
export interface ServiceFabricClientGetApplicationManifestOptionalParams extends msRest.RequestOptionsBase {
  /**
   * @member {number} [timeoutParameter] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds. Default value: 60 .
   */
  timeoutParameter?: number;
}

/**
 * @interface
 * An interface representing ServiceFabricClientGetServiceInfoListOptionalParams.
 * Optional Parameters.
 *
 * @extends RequestOptionsBase
 */
export interface ServiceFabricClientGetServiceInfoListOptionalParams extends msRest.RequestOptionsBase {
  /**
   * @member {string} [serviceTypeName] The service type name used to filter
   * the services to query for.
   */
  serviceTypeName?: string;
  /**
   * @member {string} [continuationToken] The continuation token parameter is
   * used to obtain next set of results. A continuation token with a non-empty
   * value is included in the response of the API when the results from the
   * system do not fit in a single response. When this value is passed to the
   * next API call, the API returns next set of results. If there are no
   * further results, then the continuation token does not contain a value. The
   * value of this parameter should not be URL encoded.
   */
  continuationToken?: string;
  /**
   * @member {number} [timeoutParameter] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds. Default value: 60 .
   */
  timeoutParameter?: number;
}

/**
 * @interface
 * An interface representing ServiceFabricClientGetServiceInfoOptionalParams.
 * Optional Parameters.
 *
 * @extends RequestOptionsBase
 */
export interface ServiceFabricClientGetServiceInfoOptionalParams extends msRest.RequestOptionsBase {
  /**
   * @member {number} [timeoutParameter] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds. Default value: 60 .
   */
  timeoutParameter?: number;
}

/**
 * @interface
 * An interface representing ServiceFabricClientGetApplicationNameInfoOptionalParams.
 * Optional Parameters.
 *
 * @extends RequestOptionsBase
 */
export interface ServiceFabricClientGetApplicationNameInfoOptionalParams extends msRest.RequestOptionsBase {
  /**
   * @member {number} [timeoutParameter] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds. Default value: 60 .
   */
  timeoutParameter?: number;
}

/**
 * @interface
 * An interface representing ServiceFabricClientCreateServiceOptionalParams.
 * Optional Parameters.
 *
 * @extends RequestOptionsBase
 */
export interface ServiceFabricClientCreateServiceOptionalParams extends msRest.RequestOptionsBase {
  /**
   * @member {number} [timeoutParameter] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds. Default value: 60 .
   */
  timeoutParameter?: number;
}

/**
 * @interface
 * An interface representing ServiceFabricClientCreateServiceFromTemplateOptionalParams.
 * Optional Parameters.
 *
 * @extends RequestOptionsBase
 */
export interface ServiceFabricClientCreateServiceFromTemplateOptionalParams extends msRest.RequestOptionsBase {
  /**
   * @member {number} [timeoutParameter] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds. Default value: 60 .
   */
  timeoutParameter?: number;
}

/**
 * @interface
 * An interface representing ServiceFabricClientDeleteServiceOptionalParams.
 * Optional Parameters.
 *
 * @extends RequestOptionsBase
 */
export interface ServiceFabricClientDeleteServiceOptionalParams extends msRest.RequestOptionsBase {
  /**
   * @member {boolean} [forceRemove] Remove a Service Fabric application or
   * service forcefully without going through the graceful shutdown sequence.
   * This parameter can be used to forcefully delete an application or service
   * for which delete is timing out due to issues in the service code that
   * prevents graceful close of replicas.
   */
  forceRemove?: boolean;
  /**
   * @member {number} [timeoutParameter] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds. Default value: 60 .
   */
  timeoutParameter?: number;
}

/**
 * @interface
 * An interface representing ServiceFabricClientUpdateServiceOptionalParams.
 * Optional Parameters.
 *
 * @extends RequestOptionsBase
 */
export interface ServiceFabricClientUpdateServiceOptionalParams extends msRest.RequestOptionsBase {
  /**
   * @member {number} [timeoutParameter] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds. Default value: 60 .
   */
  timeoutParameter?: number;
}

/**
 * @interface
 * An interface representing ServiceFabricClientGetServiceDescriptionOptionalParams.
 * Optional Parameters.
 *
 * @extends RequestOptionsBase
 */
export interface ServiceFabricClientGetServiceDescriptionOptionalParams extends msRest.RequestOptionsBase {
  /**
   * @member {number} [timeoutParameter] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds. Default value: 60 .
   */
  timeoutParameter?: number;
}

/**
 * @interface
 * An interface representing ServiceFabricClientGetServiceHealthOptionalParams.
 * Optional Parameters.
 *
 * @extends RequestOptionsBase
 */
export interface ServiceFabricClientGetServiceHealthOptionalParams extends msRest.RequestOptionsBase {
  /**
   * @member {number} [eventsHealthStateFilter] Allows filtering the collection
   * of HealthEvent objects returned based on health state.
   * The possible values for this parameter include integer value of one of the
   * following health states.
   * Only events that match the filter are returned. All events are used to
   * evaluate the aggregated health state.
   * If not specified, all entries are returned. The state values are
   * flag-based enumeration, so the value could be a combination of these
   * values, obtained using the bitwise 'OR' operator. For example, If the
   * provided value is 6 then all of the events with HealthState value of OK
   * (2) and Warning (4) are returned.
   *
   * - Default - Default value. Matches any HealthState. The value is zero.
   * - None - Filter that doesn't match any HealthState value. Used in order to
   * return no results on a given collection of states. The value is 1.
   * - Ok - Filter that matches input with HealthState value Ok. The value is
   * 2.
   * - Warning - Filter that matches input with HealthState value Warning. The
   * value is 4.
   * - Error - Filter that matches input with HealthState value Error. The
   * value is 8.
   * - All - Filter that matches input with any HealthState value. The value is
   * 65535. Default value: 0 .
   */
  eventsHealthStateFilter?: number;
  /**
   * @member {number} [partitionsHealthStateFilter] Allows filtering of the
   * partitions health state objects returned in the result of service health
   * query based on their health state.
   * The possible values for this parameter include integer value of one of the
   * following health states.
   * Only partitions that match the filter are returned. All partitions are
   * used to evaluate the aggregated health state.
   * If not specified, all entries are returned. The state values are
   * flag-based enumeration, so the value could be a combination of these value
   * obtained using bitwise 'OR' operator. For example, if the provided value
   * is 6 then health state of partitions with HealthState value of OK (2) and
   * Warning (4) will be returned.
   *
   * - Default - Default value. Matches any HealthState. The value is zero.
   * - None - Filter that doesn't match any HealthState value. Used in order to
   * return no results on a given collection of states. The value is 1.
   * - Ok - Filter that matches input with HealthState value Ok. The value is
   * 2.
   * - Warning - Filter that matches input with HealthState value Warning. The
   * value is 4.
   * - Error - Filter that matches input with HealthState value Error. The
   * value is 8.
   * - All - Filter that matches input with any HealthState value. The value is
   * 65535. Default value: 0 .
   */
  partitionsHealthStateFilter?: number;
  /**
   * @member {boolean} [excludeHealthStatistics] Indicates whether the health
   * statistics should be returned as part of the query result. False by
   * default.
   * The statistics show the number of children entities in health state Ok,
   * Warning, and Error. Default value: false .
   */
  excludeHealthStatistics?: boolean;
  /**
   * @member {number} [timeoutParameter] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds. Default value: 60 .
   */
  timeoutParameter?: number;
}

/**
 * @interface
 * An interface representing ServiceFabricClientGetServiceHealthUsingPolicyOptionalParams.
 * Optional Parameters.
 *
 * @extends RequestOptionsBase
 */
export interface ServiceFabricClientGetServiceHealthUsingPolicyOptionalParams extends msRest.RequestOptionsBase {
  /**
   * @member {number} [eventsHealthStateFilter] Allows filtering the collection
   * of HealthEvent objects returned based on health state.
   * The possible values for this parameter include integer value of one of the
   * following health states.
   * Only events that match the filter are returned. All events are used to
   * evaluate the aggregated health state.
   * If not specified, all entries are returned. The state values are
   * flag-based enumeration, so the value could be a combination of these
   * values, obtained using the bitwise 'OR' operator. For example, If the
   * provided value is 6 then all of the events with HealthState value of OK
   * (2) and Warning (4) are returned.
   *
   * - Default - Default value. Matches any HealthState. The value is zero.
   * - None - Filter that doesn't match any HealthState value. Used in order to
   * return no results on a given collection of states. The value is 1.
   * - Ok - Filter that matches input with HealthState value Ok. The value is
   * 2.
   * - Warning - Filter that matches input with HealthState value Warning. The
   * value is 4.
   * - Error - Filter that matches input with HealthState value Error. The
   * value is 8.
   * - All - Filter that matches input with any HealthState value. The value is
   * 65535. Default value: 0 .
   */
  eventsHealthStateFilter?: number;
  /**
   * @member {number} [partitionsHealthStateFilter] Allows filtering of the
   * partitions health state objects returned in the result of service health
   * query based on their health state.
   * The possible values for this parameter include integer value of one of the
   * following health states.
   * Only partitions that match the filter are returned. All partitions are
   * used to evaluate the aggregated health state.
   * If not specified, all entries are returned. The state values are
   * flag-based enumeration, so the value could be a combination of these value
   * obtained using bitwise 'OR' operator. For example, if the provided value
   * is 6 then health state of partitions with HealthState value of OK (2) and
   * Warning (4) will be returned.
   *
   * - Default - Default value. Matches any HealthState. The value is zero.
   * - None - Filter that doesn't match any HealthState value. Used in order to
   * return no results on a given collection of states. The value is 1.
   * - Ok - Filter that matches input with HealthState value Ok. The value is
   * 2.
   * - Warning - Filter that matches input with HealthState value Warning. The
   * value is 4.
   * - Error - Filter that matches input with HealthState value Error. The
   * value is 8.
   * - All - Filter that matches input with any HealthState value. The value is
   * 65535. Default value: 0 .
   */
  partitionsHealthStateFilter?: number;
  /**
   * @member {ApplicationHealthPolicy} [applicationHealthPolicy] Describes the
   * health policies used to evaluate the health of an application or one of
   * its children.
   * If not present, the health evaluation uses the health policy from
   * application manifest or the default health policy.
   */
  applicationHealthPolicy?: ApplicationHealthPolicy;
  /**
   * @member {boolean} [excludeHealthStatistics] Indicates whether the health
   * statistics should be returned as part of the query result. False by
   * default.
   * The statistics show the number of children entities in health state Ok,
   * Warning, and Error. Default value: false .
   */
  excludeHealthStatistics?: boolean;
  /**
   * @member {number} [timeoutParameter] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds. Default value: 60 .
   */
  timeoutParameter?: number;
}

/**
 * @interface
 * An interface representing ServiceFabricClientReportServiceHealthOptionalParams.
 * Optional Parameters.
 *
 * @extends RequestOptionsBase
 */
export interface ServiceFabricClientReportServiceHealthOptionalParams extends msRest.RequestOptionsBase {
  /**
   * @member {boolean} [immediate] A flag that indicates whether the report
   * should be sent immediately.
   * A health report is sent to a Service Fabric gateway Application, which
   * forwards to the health store.
   * If Immediate is set to true, the report is sent immediately from HTTP
   * Gateway to the health store, regardless of the fabric client settings that
   * the HTTP Gateway Application is using.
   * This is useful for critical reports that should be sent as soon as
   * possible.
   * Depending on timing and other conditions, sending the report may still
   * fail, for example if the HTTP Gateway is closed or the message doesn't
   * reach the Gateway.
   * If Immediate is set to false, the report is sent based on the health
   * client settings from the HTTP Gateway. Therefore, it will be batched
   * according to the HealthReportSendInterval configuration.
   * This is the recommended setting because it allows the health client to
   * optimize health reporting messages to health store as well as health
   * report processing.
   * By default, reports are not sent immediately. Default value: false .
   */
  immediate?: boolean;
  /**
   * @member {number} [timeoutParameter] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds. Default value: 60 .
   */
  timeoutParameter?: number;
}

/**
 * @interface
 * An interface representing ServiceFabricClientResolveServiceOptionalParams.
 * Optional Parameters.
 *
 * @extends RequestOptionsBase
 */
export interface ServiceFabricClientResolveServiceOptionalParams extends msRest.RequestOptionsBase {
  /**
   * @member {number} [partitionKeyType] Key type for the partition. This
   * parameter is required if the partition scheme for the service is
   * Int64Range or Named. The possible values are following.
   * - None (1) - Indicates that the PartitionKeyValue parameter is not
   * specified. This is valid for the partitions with partitioning scheme as
   * Singleton. This is the default value. The value is 1.
   * - Int64Range (2) - Indicates that the PartitionKeyValue parameter is an
   * int64 partition key. This is valid for the partitions with partitioning
   * scheme as Int64Range. The value is 2.
   * - Named (3) - Indicates that the PartitionKeyValue parameter is a name of
   * the partition. This is valid for the partitions with partitioning scheme
   * as Named. The value is 3.
   */
  partitionKeyType?: number;
  /**
   * @member {string} [partitionKeyValue] Partition key. This is required if
   * the partition scheme for the service is Int64Range or Named.
   */
  partitionKeyValue?: string;
  /**
   * @member {string} [previousRspVersion] The value in the Version field of
   * the response that was received previously. This is required if the user
   * knows that the result that was gotten previously is stale.
   */
  previousRspVersion?: string;
  /**
   * @member {number} [timeoutParameter] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds. Default value: 60 .
   */
  timeoutParameter?: number;
}

/**
 * @interface
 * An interface representing ServiceFabricClientGetPartitionInfoListOptionalParams.
 * Optional Parameters.
 *
 * @extends RequestOptionsBase
 */
export interface ServiceFabricClientGetPartitionInfoListOptionalParams extends msRest.RequestOptionsBase {
  /**
   * @member {string} [continuationToken] The continuation token parameter is
   * used to obtain next set of results. A continuation token with a non-empty
   * value is included in the response of the API when the results from the
   * system do not fit in a single response. When this value is passed to the
   * next API call, the API returns next set of results. If there are no
   * further results, then the continuation token does not contain a value. The
   * value of this parameter should not be URL encoded.
   */
  continuationToken?: string;
  /**
   * @member {number} [timeoutParameter] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds. Default value: 60 .
   */
  timeoutParameter?: number;
}

/**
 * @interface
 * An interface representing ServiceFabricClientGetPartitionInfoOptionalParams.
 * Optional Parameters.
 *
 * @extends RequestOptionsBase
 */
export interface ServiceFabricClientGetPartitionInfoOptionalParams extends msRest.RequestOptionsBase {
  /**
   * @member {number} [timeoutParameter] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds. Default value: 60 .
   */
  timeoutParameter?: number;
}

/**
 * @interface
 * An interface representing ServiceFabricClientGetServiceNameInfoOptionalParams.
 * Optional Parameters.
 *
 * @extends RequestOptionsBase
 */
export interface ServiceFabricClientGetServiceNameInfoOptionalParams extends msRest.RequestOptionsBase {
  /**
   * @member {number} [timeoutParameter] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds. Default value: 60 .
   */
  timeoutParameter?: number;
}

/**
 * @interface
 * An interface representing ServiceFabricClientGetPartitionHealthOptionalParams.
 * Optional Parameters.
 *
 * @extends RequestOptionsBase
 */
export interface ServiceFabricClientGetPartitionHealthOptionalParams extends msRest.RequestOptionsBase {
  /**
   * @member {number} [eventsHealthStateFilter] Allows filtering the collection
   * of HealthEvent objects returned based on health state.
   * The possible values for this parameter include integer value of one of the
   * following health states.
   * Only events that match the filter are returned. All events are used to
   * evaluate the aggregated health state.
   * If not specified, all entries are returned. The state values are
   * flag-based enumeration, so the value could be a combination of these
   * values, obtained using the bitwise 'OR' operator. For example, If the
   * provided value is 6 then all of the events with HealthState value of OK
   * (2) and Warning (4) are returned.
   *
   * - Default - Default value. Matches any HealthState. The value is zero.
   * - None - Filter that doesn't match any HealthState value. Used in order to
   * return no results on a given collection of states. The value is 1.
   * - Ok - Filter that matches input with HealthState value Ok. The value is
   * 2.
   * - Warning - Filter that matches input with HealthState value Warning. The
   * value is 4.
   * - Error - Filter that matches input with HealthState value Error. The
   * value is 8.
   * - All - Filter that matches input with any HealthState value. The value is
   * 65535. Default value: 0 .
   */
  eventsHealthStateFilter?: number;
  /**
   * @member {number} [replicasHealthStateFilter] Allows filtering the
   * collection of ReplicaHealthState objects on the partition. The value can
   * be obtained from members or bitwise operations on members of
   * HealthStateFilter. Only replicas that match the filter will be returned.
   * All replicas will be used to evaluate the aggregated health state. If not
   * specified, all entries will be returned.The state values are flag-based
   * enumeration, so the value could be a combination of these values obtained
   * using bitwise 'OR' operator. For example, If the provided value is 6 then
   * all of the events with HealthState value of OK (2) and Warning (4) will be
   * returned. The possible values for this parameter include integer value of
   * one of the following health states.
   *
   * - Default - Default value. Matches any HealthState. The value is zero.
   * - None - Filter that doesn't match any HealthState value. Used in order to
   * return no results on a given collection of states. The value is 1.
   * - Ok - Filter that matches input with HealthState value Ok. The value is
   * 2.
   * - Warning - Filter that matches input with HealthState value Warning. The
   * value is 4.
   * - Error - Filter that matches input with HealthState value Error. The
   * value is 8.
   * - All - Filter that matches input with any HealthState value. The value is
   * 65535. Default value: 0 .
   */
  replicasHealthStateFilter?: number;
  /**
   * @member {boolean} [excludeHealthStatistics] Indicates whether the health
   * statistics should be returned as part of the query result. False by
   * default.
   * The statistics show the number of children entities in health state Ok,
   * Warning, and Error. Default value: false .
   */
  excludeHealthStatistics?: boolean;
  /**
   * @member {number} [timeoutParameter] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds. Default value: 60 .
   */
  timeoutParameter?: number;
}

/**
 * @interface
 * An interface representing ServiceFabricClientGetPartitionHealthUsingPolicyOptionalParams.
 * Optional Parameters.
 *
 * @extends RequestOptionsBase
 */
export interface ServiceFabricClientGetPartitionHealthUsingPolicyOptionalParams extends msRest.RequestOptionsBase {
  /**
   * @member {number} [eventsHealthStateFilter] Allows filtering the collection
   * of HealthEvent objects returned based on health state.
   * The possible values for this parameter include integer value of one of the
   * following health states.
   * Only events that match the filter are returned. All events are used to
   * evaluate the aggregated health state.
   * If not specified, all entries are returned. The state values are
   * flag-based enumeration, so the value could be a combination of these
   * values, obtained using the bitwise 'OR' operator. For example, If the
   * provided value is 6 then all of the events with HealthState value of OK
   * (2) and Warning (4) are returned.
   *
   * - Default - Default value. Matches any HealthState. The value is zero.
   * - None - Filter that doesn't match any HealthState value. Used in order to
   * return no results on a given collection of states. The value is 1.
   * - Ok - Filter that matches input with HealthState value Ok. The value is
   * 2.
   * - Warning - Filter that matches input with HealthState value Warning. The
   * value is 4.
   * - Error - Filter that matches input with HealthState value Error. The
   * value is 8.
   * - All - Filter that matches input with any HealthState value. The value is
   * 65535. Default value: 0 .
   */
  eventsHealthStateFilter?: number;
  /**
   * @member {number} [replicasHealthStateFilter] Allows filtering the
   * collection of ReplicaHealthState objects on the partition. The value can
   * be obtained from members or bitwise operations on members of
   * HealthStateFilter. Only replicas that match the filter will be returned.
   * All replicas will be used to evaluate the aggregated health state. If not
   * specified, all entries will be returned.The state values are flag-based
   * enumeration, so the value could be a combination of these values obtained
   * using bitwise 'OR' operator. For example, If the provided value is 6 then
   * all of the events with HealthState value of OK (2) and Warning (4) will be
   * returned. The possible values for this parameter include integer value of
   * one of the following health states.
   *
   * - Default - Default value. Matches any HealthState. The value is zero.
   * - None - Filter that doesn't match any HealthState value. Used in order to
   * return no results on a given collection of states. The value is 1.
   * - Ok - Filter that matches input with HealthState value Ok. The value is
   * 2.
   * - Warning - Filter that matches input with HealthState value Warning. The
   * value is 4.
   * - Error - Filter that matches input with HealthState value Error. The
   * value is 8.
   * - All - Filter that matches input with any HealthState value. The value is
   * 65535. Default value: 0 .
   */
  replicasHealthStateFilter?: number;
  /**
   * @member {ApplicationHealthPolicy} [applicationHealthPolicy] Describes the
   * health policies used to evaluate the health of an application or one of
   * its children.
   * If not present, the health evaluation uses the health policy from
   * application manifest or the default health policy.
   */
  applicationHealthPolicy?: ApplicationHealthPolicy;
  /**
   * @member {boolean} [excludeHealthStatistics] Indicates whether the health
   * statistics should be returned as part of the query result. False by
   * default.
   * The statistics show the number of children entities in health state Ok,
   * Warning, and Error. Default value: false .
   */
  excludeHealthStatistics?: boolean;
  /**
   * @member {number} [timeoutParameter] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds. Default value: 60 .
   */
  timeoutParameter?: number;
}

/**
 * @interface
 * An interface representing ServiceFabricClientReportPartitionHealthOptionalParams.
 * Optional Parameters.
 *
 * @extends RequestOptionsBase
 */
export interface ServiceFabricClientReportPartitionHealthOptionalParams extends msRest.RequestOptionsBase {
  /**
   * @member {boolean} [immediate] A flag that indicates whether the report
   * should be sent immediately.
   * A health report is sent to a Service Fabric gateway Application, which
   * forwards to the health store.
   * If Immediate is set to true, the report is sent immediately from HTTP
   * Gateway to the health store, regardless of the fabric client settings that
   * the HTTP Gateway Application is using.
   * This is useful for critical reports that should be sent as soon as
   * possible.
   * Depending on timing and other conditions, sending the report may still
   * fail, for example if the HTTP Gateway is closed or the message doesn't
   * reach the Gateway.
   * If Immediate is set to false, the report is sent based on the health
   * client settings from the HTTP Gateway. Therefore, it will be batched
   * according to the HealthReportSendInterval configuration.
   * This is the recommended setting because it allows the health client to
   * optimize health reporting messages to health store as well as health
   * report processing.
   * By default, reports are not sent immediately. Default value: false .
   */
  immediate?: boolean;
  /**
   * @member {number} [timeoutParameter] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds. Default value: 60 .
   */
  timeoutParameter?: number;
}

/**
 * @interface
 * An interface representing ServiceFabricClientGetPartitionLoadInformationOptionalParams.
 * Optional Parameters.
 *
 * @extends RequestOptionsBase
 */
export interface ServiceFabricClientGetPartitionLoadInformationOptionalParams extends msRest.RequestOptionsBase {
  /**
   * @member {number} [timeoutParameter] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds. Default value: 60 .
   */
  timeoutParameter?: number;
}

/**
 * @interface
 * An interface representing ServiceFabricClientResetPartitionLoadOptionalParams.
 * Optional Parameters.
 *
 * @extends RequestOptionsBase
 */
export interface ServiceFabricClientResetPartitionLoadOptionalParams extends msRest.RequestOptionsBase {
  /**
   * @member {number} [timeoutParameter] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds. Default value: 60 .
   */
  timeoutParameter?: number;
}

/**
 * @interface
 * An interface representing ServiceFabricClientRecoverPartitionOptionalParams.
 * Optional Parameters.
 *
 * @extends RequestOptionsBase
 */
export interface ServiceFabricClientRecoverPartitionOptionalParams extends msRest.RequestOptionsBase {
  /**
   * @member {number} [timeoutParameter] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds. Default value: 60 .
   */
  timeoutParameter?: number;
}

/**
 * @interface
 * An interface representing ServiceFabricClientRecoverServicePartitionsOptionalParams.
 * Optional Parameters.
 *
 * @extends RequestOptionsBase
 */
export interface ServiceFabricClientRecoverServicePartitionsOptionalParams extends msRest.RequestOptionsBase {
  /**
   * @member {number} [timeoutParameter] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds. Default value: 60 .
   */
  timeoutParameter?: number;
}

/**
 * @interface
 * An interface representing ServiceFabricClientRecoverSystemPartitionsOptionalParams.
 * Optional Parameters.
 *
 * @extends RequestOptionsBase
 */
export interface ServiceFabricClientRecoverSystemPartitionsOptionalParams extends msRest.RequestOptionsBase {
  /**
   * @member {number} [timeoutParameter] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds. Default value: 60 .
   */
  timeoutParameter?: number;
}

/**
 * @interface
 * An interface representing ServiceFabricClientRecoverAllPartitionsOptionalParams.
 * Optional Parameters.
 *
 * @extends RequestOptionsBase
 */
export interface ServiceFabricClientRecoverAllPartitionsOptionalParams extends msRest.RequestOptionsBase {
  /**
   * @member {number} [timeoutParameter] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds. Default value: 60 .
   */
  timeoutParameter?: number;
}

/**
 * @interface
 * An interface representing ServiceFabricClientGetRepairTaskListOptionalParams.
 * Optional Parameters.
 *
 * @extends RequestOptionsBase
 */
export interface ServiceFabricClientGetRepairTaskListOptionalParams extends msRest.RequestOptionsBase {
  /**
   * @member {string} [taskIdFilter] The repair task ID prefix to be matched.
   */
  taskIdFilter?: string;
  /**
   * @member {number} [stateFilter] A bitwise-OR of the following values,
   * specifying which task states should be included in the result list.
   *
   * - 1 - Created
   * - 2 - Claimed
   * - 4 - Preparing
   * - 8 - Approved
   * - 16 - Executing
   * - 32 - Restoring
   * - 64 - Completed
   */
  stateFilter?: number;
  /**
   * @member {string} [executorFilter] The name of the repair executor whose
   * claimed tasks should be included in the list.
   */
  executorFilter?: string;
}

/**
 * @interface
 * An interface representing ServiceFabricClientGetReplicaInfoListOptionalParams.
 * Optional Parameters.
 *
 * @extends RequestOptionsBase
 */
export interface ServiceFabricClientGetReplicaInfoListOptionalParams extends msRest.RequestOptionsBase {
  /**
   * @member {string} [continuationToken] The continuation token parameter is
   * used to obtain next set of results. A continuation token with a non-empty
   * value is included in the response of the API when the results from the
   * system do not fit in a single response. When this value is passed to the
   * next API call, the API returns next set of results. If there are no
   * further results, then the continuation token does not contain a value. The
   * value of this parameter should not be URL encoded.
   */
  continuationToken?: string;
  /**
   * @member {number} [timeoutParameter] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds. Default value: 60 .
   */
  timeoutParameter?: number;
}

/**
 * @interface
 * An interface representing ServiceFabricClientGetReplicaInfoOptionalParams.
 * Optional Parameters.
 *
 * @extends RequestOptionsBase
 */
export interface ServiceFabricClientGetReplicaInfoOptionalParams extends msRest.RequestOptionsBase {
  /**
   * @member {number} [timeoutParameter] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds. Default value: 60 .
   */
  timeoutParameter?: number;
}

/**
 * @interface
 * An interface representing ServiceFabricClientGetReplicaHealthOptionalParams.
 * Optional Parameters.
 *
 * @extends RequestOptionsBase
 */
export interface ServiceFabricClientGetReplicaHealthOptionalParams extends msRest.RequestOptionsBase {
  /**
   * @member {number} [eventsHealthStateFilter] Allows filtering the collection
   * of HealthEvent objects returned based on health state.
   * The possible values for this parameter include integer value of one of the
   * following health states.
   * Only events that match the filter are returned. All events are used to
   * evaluate the aggregated health state.
   * If not specified, all entries are returned. The state values are
   * flag-based enumeration, so the value could be a combination of these
   * values, obtained using the bitwise 'OR' operator. For example, If the
   * provided value is 6 then all of the events with HealthState value of OK
   * (2) and Warning (4) are returned.
   *
   * - Default - Default value. Matches any HealthState. The value is zero.
   * - None - Filter that doesn't match any HealthState value. Used in order to
   * return no results on a given collection of states. The value is 1.
   * - Ok - Filter that matches input with HealthState value Ok. The value is
   * 2.
   * - Warning - Filter that matches input with HealthState value Warning. The
   * value is 4.
   * - Error - Filter that matches input with HealthState value Error. The
   * value is 8.
   * - All - Filter that matches input with any HealthState value. The value is
   * 65535. Default value: 0 .
   */
  eventsHealthStateFilter?: number;
  /**
   * @member {number} [timeoutParameter] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds. Default value: 60 .
   */
  timeoutParameter?: number;
}

/**
 * @interface
 * An interface representing ServiceFabricClientGetReplicaHealthUsingPolicyOptionalParams.
 * Optional Parameters.
 *
 * @extends RequestOptionsBase
 */
export interface ServiceFabricClientGetReplicaHealthUsingPolicyOptionalParams extends msRest.RequestOptionsBase {
  /**
   * @member {number} [eventsHealthStateFilter] Allows filtering the collection
   * of HealthEvent objects returned based on health state.
   * The possible values for this parameter include integer value of one of the
   * following health states.
   * Only events that match the filter are returned. All events are used to
   * evaluate the aggregated health state.
   * If not specified, all entries are returned. The state values are
   * flag-based enumeration, so the value could be a combination of these
   * values, obtained using the bitwise 'OR' operator. For example, If the
   * provided value is 6 then all of the events with HealthState value of OK
   * (2) and Warning (4) are returned.
   *
   * - Default - Default value. Matches any HealthState. The value is zero.
   * - None - Filter that doesn't match any HealthState value. Used in order to
   * return no results on a given collection of states. The value is 1.
   * - Ok - Filter that matches input with HealthState value Ok. The value is
   * 2.
   * - Warning - Filter that matches input with HealthState value Warning. The
   * value is 4.
   * - Error - Filter that matches input with HealthState value Error. The
   * value is 8.
   * - All - Filter that matches input with any HealthState value. The value is
   * 65535. Default value: 0 .
   */
  eventsHealthStateFilter?: number;
  /**
   * @member {ApplicationHealthPolicy} [applicationHealthPolicy] Describes the
   * health policies used to evaluate the health of an application or one of
   * its children.
   * If not present, the health evaluation uses the health policy from
   * application manifest or the default health policy.
   */
  applicationHealthPolicy?: ApplicationHealthPolicy;
  /**
   * @member {number} [timeoutParameter] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds. Default value: 60 .
   */
  timeoutParameter?: number;
}

/**
 * @interface
 * An interface representing ServiceFabricClientReportReplicaHealthOptionalParams.
 * Optional Parameters.
 *
 * @extends RequestOptionsBase
 */
export interface ServiceFabricClientReportReplicaHealthOptionalParams extends msRest.RequestOptionsBase {
  /**
   * @member {boolean} [immediate] A flag that indicates whether the report
   * should be sent immediately.
   * A health report is sent to a Service Fabric gateway Application, which
   * forwards to the health store.
   * If Immediate is set to true, the report is sent immediately from HTTP
   * Gateway to the health store, regardless of the fabric client settings that
   * the HTTP Gateway Application is using.
   * This is useful for critical reports that should be sent as soon as
   * possible.
   * Depending on timing and other conditions, sending the report may still
   * fail, for example if the HTTP Gateway is closed or the message doesn't
   * reach the Gateway.
   * If Immediate is set to false, the report is sent based on the health
   * client settings from the HTTP Gateway. Therefore, it will be batched
   * according to the HealthReportSendInterval configuration.
   * This is the recommended setting because it allows the health client to
   * optimize health reporting messages to health store as well as health
   * report processing.
   * By default, reports are not sent immediately. Default value: false .
   */
  immediate?: boolean;
  /**
   * @member {number} [timeoutParameter] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds. Default value: 60 .
   */
  timeoutParameter?: number;
}

/**
 * @interface
 * An interface representing ServiceFabricClientGetDeployedServiceReplicaInfoListOptionalParams.
 * Optional Parameters.
 *
 * @extends RequestOptionsBase
 */
export interface ServiceFabricClientGetDeployedServiceReplicaInfoListOptionalParams extends msRest.RequestOptionsBase {
  /**
   * @member {string} [partitionId] The identity of the partition.
   */
  partitionId?: string;
  /**
   * @member {string} [serviceManifestName] The name of a service manifest
   * registered as part of an application type in a Service Fabric cluster.
   */
  serviceManifestName?: string;
  /**
   * @member {number} [timeoutParameter] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds. Default value: 60 .
   */
  timeoutParameter?: number;
}

/**
 * @interface
 * An interface representing ServiceFabricClientGetDeployedServiceReplicaDetailInfoOptionalParams.
 * Optional Parameters.
 *
 * @extends RequestOptionsBase
 */
export interface ServiceFabricClientGetDeployedServiceReplicaDetailInfoOptionalParams extends msRest.RequestOptionsBase {
  /**
   * @member {number} [timeoutParameter] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds. Default value: 60 .
   */
  timeoutParameter?: number;
}

/**
 * @interface
 * An interface representing ServiceFabricClientGetDeployedServiceReplicaDetailInfoByPartitionIdOptionalParams.
 * Optional Parameters.
 *
 * @extends RequestOptionsBase
 */
export interface ServiceFabricClientGetDeployedServiceReplicaDetailInfoByPartitionIdOptionalParams extends msRest.RequestOptionsBase {
  /**
   * @member {number} [timeoutParameter] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds. Default value: 60 .
   */
  timeoutParameter?: number;
}

/**
 * @interface
 * An interface representing ServiceFabricClientRestartReplicaOptionalParams.
 * Optional Parameters.
 *
 * @extends RequestOptionsBase
 */
export interface ServiceFabricClientRestartReplicaOptionalParams extends msRest.RequestOptionsBase {
  /**
   * @member {number} [timeoutParameter] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds. Default value: 60 .
   */
  timeoutParameter?: number;
}

/**
 * @interface
 * An interface representing ServiceFabricClientRemoveReplicaOptionalParams.
 * Optional Parameters.
 *
 * @extends RequestOptionsBase
 */
export interface ServiceFabricClientRemoveReplicaOptionalParams extends msRest.RequestOptionsBase {
  /**
   * @member {boolean} [forceRemove] Remove a Service Fabric application or
   * service forcefully without going through the graceful shutdown sequence.
   * This parameter can be used to forcefully delete an application or service
   * for which delete is timing out due to issues in the service code that
   * prevents graceful close of replicas.
   */
  forceRemove?: boolean;
  /**
   * @member {number} [timeoutParameter] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds. Default value: 60 .
   */
  timeoutParameter?: number;
}

/**
 * @interface
 * An interface representing ServiceFabricClientGetDeployedServicePackageInfoListOptionalParams.
 * Optional Parameters.
 *
 * @extends RequestOptionsBase
 */
export interface ServiceFabricClientGetDeployedServicePackageInfoListOptionalParams extends msRest.RequestOptionsBase {
  /**
   * @member {number} [timeoutParameter] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds. Default value: 60 .
   */
  timeoutParameter?: number;
}

/**
 * @interface
 * An interface representing ServiceFabricClientGetDeployedServicePackageInfoListByNameOptionalParams.
 * Optional Parameters.
 *
 * @extends RequestOptionsBase
 */
export interface ServiceFabricClientGetDeployedServicePackageInfoListByNameOptionalParams extends msRest.RequestOptionsBase {
  /**
   * @member {number} [timeoutParameter] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds. Default value: 60 .
   */
  timeoutParameter?: number;
}

/**
 * @interface
 * An interface representing ServiceFabricClientGetDeployedServicePackageHealthOptionalParams.
 * Optional Parameters.
 *
 * @extends RequestOptionsBase
 */
export interface ServiceFabricClientGetDeployedServicePackageHealthOptionalParams extends msRest.RequestOptionsBase {
  /**
   * @member {number} [eventsHealthStateFilter] Allows filtering the collection
   * of HealthEvent objects returned based on health state.
   * The possible values for this parameter include integer value of one of the
   * following health states.
   * Only events that match the filter are returned. All events are used to
   * evaluate the aggregated health state.
   * If not specified, all entries are returned. The state values are
   * flag-based enumeration, so the value could be a combination of these
   * values, obtained using the bitwise 'OR' operator. For example, If the
   * provided value is 6 then all of the events with HealthState value of OK
   * (2) and Warning (4) are returned.
   *
   * - Default - Default value. Matches any HealthState. The value is zero.
   * - None - Filter that doesn't match any HealthState value. Used in order to
   * return no results on a given collection of states. The value is 1.
   * - Ok - Filter that matches input with HealthState value Ok. The value is
   * 2.
   * - Warning - Filter that matches input with HealthState value Warning. The
   * value is 4.
   * - Error - Filter that matches input with HealthState value Error. The
   * value is 8.
   * - All - Filter that matches input with any HealthState value. The value is
   * 65535. Default value: 0 .
   */
  eventsHealthStateFilter?: number;
  /**
   * @member {number} [timeoutParameter] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds. Default value: 60 .
   */
  timeoutParameter?: number;
}

/**
 * @interface
 * An interface representing ServiceFabricClientGetDeployedServicePackageHealthUsingPolicyOptionalParams.
 * Optional Parameters.
 *
 * @extends RequestOptionsBase
 */
export interface ServiceFabricClientGetDeployedServicePackageHealthUsingPolicyOptionalParams extends msRest.RequestOptionsBase {
  /**
   * @member {number} [eventsHealthStateFilter] Allows filtering the collection
   * of HealthEvent objects returned based on health state.
   * The possible values for this parameter include integer value of one of the
   * following health states.
   * Only events that match the filter are returned. All events are used to
   * evaluate the aggregated health state.
   * If not specified, all entries are returned. The state values are
   * flag-based enumeration, so the value could be a combination of these
   * values, obtained using the bitwise 'OR' operator. For example, If the
   * provided value is 6 then all of the events with HealthState value of OK
   * (2) and Warning (4) are returned.
   *
   * - Default - Default value. Matches any HealthState. The value is zero.
   * - None - Filter that doesn't match any HealthState value. Used in order to
   * return no results on a given collection of states. The value is 1.
   * - Ok - Filter that matches input with HealthState value Ok. The value is
   * 2.
   * - Warning - Filter that matches input with HealthState value Warning. The
   * value is 4.
   * - Error - Filter that matches input with HealthState value Error. The
   * value is 8.
   * - All - Filter that matches input with any HealthState value. The value is
   * 65535. Default value: 0 .
   */
  eventsHealthStateFilter?: number;
  /**
   * @member {ApplicationHealthPolicy} [applicationHealthPolicy] Describes the
   * health policies used to evaluate the health of an application or one of
   * its children.
   * If not present, the health evaluation uses the health policy from
   * application manifest or the default health policy.
   */
  applicationHealthPolicy?: ApplicationHealthPolicy;
  /**
   * @member {number} [timeoutParameter] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds. Default value: 60 .
   */
  timeoutParameter?: number;
}

/**
 * @interface
 * An interface representing ServiceFabricClientReportDeployedServicePackageHealthOptionalParams.
 * Optional Parameters.
 *
 * @extends RequestOptionsBase
 */
export interface ServiceFabricClientReportDeployedServicePackageHealthOptionalParams extends msRest.RequestOptionsBase {
  /**
   * @member {boolean} [immediate] A flag that indicates whether the report
   * should be sent immediately.
   * A health report is sent to a Service Fabric gateway Application, which
   * forwards to the health store.
   * If Immediate is set to true, the report is sent immediately from HTTP
   * Gateway to the health store, regardless of the fabric client settings that
   * the HTTP Gateway Application is using.
   * This is useful for critical reports that should be sent as soon as
   * possible.
   * Depending on timing and other conditions, sending the report may still
   * fail, for example if the HTTP Gateway is closed or the message doesn't
   * reach the Gateway.
   * If Immediate is set to false, the report is sent based on the health
   * client settings from the HTTP Gateway. Therefore, it will be batched
   * according to the HealthReportSendInterval configuration.
   * This is the recommended setting because it allows the health client to
   * optimize health reporting messages to health store as well as health
   * report processing.
   * By default, reports are not sent immediately. Default value: false .
   */
  immediate?: boolean;
  /**
   * @member {number} [timeoutParameter] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds. Default value: 60 .
   */
  timeoutParameter?: number;
}

/**
 * @interface
 * An interface representing ServiceFabricClientDeployServicePackageToNodeOptionalParams.
 * Optional Parameters.
 *
 * @extends RequestOptionsBase
 */
export interface ServiceFabricClientDeployServicePackageToNodeOptionalParams extends msRest.RequestOptionsBase {
  /**
   * @member {number} [timeoutParameter] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds. Default value: 60 .
   */
  timeoutParameter?: number;
}

/**
 * @interface
 * An interface representing ServiceFabricClientGetDeployedCodePackageInfoListOptionalParams.
 * Optional Parameters.
 *
 * @extends RequestOptionsBase
 */
export interface ServiceFabricClientGetDeployedCodePackageInfoListOptionalParams extends msRest.RequestOptionsBase {
  /**
   * @member {string} [serviceManifestName] The name of a service manifest
   * registered as part of an application type in a Service Fabric cluster.
   */
  serviceManifestName?: string;
  /**
   * @member {string} [codePackageName] The name of code package specified in
   * service manifest registered as part of an application type in a Service
   * Fabric cluster.
   */
  codePackageName?: string;
  /**
   * @member {number} [timeoutParameter] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds. Default value: 60 .
   */
  timeoutParameter?: number;
}

/**
 * @interface
 * An interface representing ServiceFabricClientRestartDeployedCodePackageOptionalParams.
 * Optional Parameters.
 *
 * @extends RequestOptionsBase
 */
export interface ServiceFabricClientRestartDeployedCodePackageOptionalParams extends msRest.RequestOptionsBase {
  /**
   * @member {number} [timeoutParameter] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds. Default value: 60 .
   */
  timeoutParameter?: number;
}

/**
 * @interface
 * An interface representing ServiceFabricClientGetContainerLogsDeployedOnNodeOptionalParams.
 * Optional Parameters.
 *
 * @extends RequestOptionsBase
 */
export interface ServiceFabricClientGetContainerLogsDeployedOnNodeOptionalParams extends msRest.RequestOptionsBase {
  /**
   * @member {string} [tail] Number of lines to show from the end of the logs.
   * Default is 100. 'all' to show the complete logs.
   */
  tail?: string;
  /**
   * @member {boolean} [previous] Specifies whether to get container logs from
   * exited/dead containers of the code package instance. Default value: false
   * .
   */
  previous?: boolean;
  /**
   * @member {number} [timeoutParameter] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds. Default value: 60 .
   */
  timeoutParameter?: number;
}

/**
 * @interface
 * An interface representing ServiceFabricClientInvokeContainerApiOptionalParams.
 * Optional Parameters.
 *
 * @extends RequestOptionsBase
 */
export interface ServiceFabricClientInvokeContainerApiOptionalParams extends msRest.RequestOptionsBase {
  /**
   * @member {number} [timeoutParameter] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds. Default value: 60 .
   */
  timeoutParameter?: number;
}

/**
 * @interface
 * An interface representing ServiceFabricClientCreateComposeDeploymentOptionalParams.
 * Optional Parameters.
 *
 * @extends RequestOptionsBase
 */
export interface ServiceFabricClientCreateComposeDeploymentOptionalParams extends msRest.RequestOptionsBase {
  /**
   * @member {number} [timeoutParameter] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds. Default value: 60 .
   */
  timeoutParameter?: number;
}

/**
 * @interface
 * An interface representing ServiceFabricClientGetComposeDeploymentStatusOptionalParams.
 * Optional Parameters.
 *
 * @extends RequestOptionsBase
 */
export interface ServiceFabricClientGetComposeDeploymentStatusOptionalParams extends msRest.RequestOptionsBase {
  /**
   * @member {number} [timeoutParameter] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds. Default value: 60 .
   */
  timeoutParameter?: number;
}

/**
 * @interface
 * An interface representing ServiceFabricClientGetComposeDeploymentStatusListOptionalParams.
 * Optional Parameters.
 *
 * @extends RequestOptionsBase
 */
export interface ServiceFabricClientGetComposeDeploymentStatusListOptionalParams extends msRest.RequestOptionsBase {
  /**
   * @member {string} [continuationToken] The continuation token parameter is
   * used to obtain next set of results. A continuation token with a non-empty
   * value is included in the response of the API when the results from the
   * system do not fit in a single response. When this value is passed to the
   * next API call, the API returns next set of results. If there are no
   * further results, then the continuation token does not contain a value. The
   * value of this parameter should not be URL encoded.
   */
  continuationToken?: string;
  /**
   * @member {number} [maxResults] The maximum number of results to be returned
   * as part of the paged queries. This parameter defines the upper bound on
   * the number of results returned. The results returned can be less than the
   * specified maximum results if they do not fit in the message as per the max
   * message size restrictions defined in the configuration. If this parameter
   * is zero or not specified, the paged query includes as many results as
   * possible that fit in the return message. Default value: 0 .
   */
  maxResults?: number;
  /**
   * @member {number} [timeoutParameter] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds. Default value: 60 .
   */
  timeoutParameter?: number;
}

/**
 * @interface
 * An interface representing ServiceFabricClientGetComposeDeploymentUpgradeProgressOptionalParams.
 * Optional Parameters.
 *
 * @extends RequestOptionsBase
 */
export interface ServiceFabricClientGetComposeDeploymentUpgradeProgressOptionalParams extends msRest.RequestOptionsBase {
  /**
   * @member {number} [timeoutParameter] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds. Default value: 60 .
   */
  timeoutParameter?: number;
}

/**
 * @interface
 * An interface representing ServiceFabricClientRemoveComposeDeploymentOptionalParams.
 * Optional Parameters.
 *
 * @extends RequestOptionsBase
 */
export interface ServiceFabricClientRemoveComposeDeploymentOptionalParams extends msRest.RequestOptionsBase {
  /**
   * @member {number} [timeoutParameter] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds. Default value: 60 .
   */
  timeoutParameter?: number;
}

/**
 * @interface
 * An interface representing ServiceFabricClientStartComposeDeploymentUpgradeOptionalParams.
 * Optional Parameters.
 *
 * @extends RequestOptionsBase
 */
export interface ServiceFabricClientStartComposeDeploymentUpgradeOptionalParams extends msRest.RequestOptionsBase {
  /**
   * @member {number} [timeoutParameter] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds. Default value: 60 .
   */
  timeoutParameter?: number;
}

/**
 * @interface
 * An interface representing ServiceFabricClientGetChaosOptionalParams.
 * Optional Parameters.
 *
 * @extends RequestOptionsBase
 */
export interface ServiceFabricClientGetChaosOptionalParams extends msRest.RequestOptionsBase {
  /**
   * @member {number} [timeoutParameter] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds. Default value: 60 .
   */
  timeoutParameter?: number;
}

/**
 * @interface
 * An interface representing ServiceFabricClientStartChaosOptionalParams.
 * Optional Parameters.
 *
 * @extends RequestOptionsBase
 */
export interface ServiceFabricClientStartChaosOptionalParams extends msRest.RequestOptionsBase {
  /**
   * @member {number} [timeoutParameter] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds. Default value: 60 .
   */
  timeoutParameter?: number;
}

/**
 * @interface
 * An interface representing ServiceFabricClientStopChaosOptionalParams.
 * Optional Parameters.
 *
 * @extends RequestOptionsBase
 */
export interface ServiceFabricClientStopChaosOptionalParams extends msRest.RequestOptionsBase {
  /**
   * @member {number} [timeoutParameter] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds. Default value: 60 .
   */
  timeoutParameter?: number;
}

/**
 * @interface
 * An interface representing ServiceFabricClientGetChaosEventsOptionalParams.
 * Optional Parameters.
 *
 * @extends RequestOptionsBase
 */
export interface ServiceFabricClientGetChaosEventsOptionalParams extends msRest.RequestOptionsBase {
  /**
   * @member {string} [continuationToken] The continuation token parameter is
   * used to obtain next set of results. A continuation token with a non-empty
   * value is included in the response of the API when the results from the
   * system do not fit in a single response. When this value is passed to the
   * next API call, the API returns next set of results. If there are no
   * further results, then the continuation token does not contain a value. The
   * value of this parameter should not be URL encoded.
   */
  continuationToken?: string;
  /**
   * @member {string} [startTimeUtc] The Windows file time representing the
   * start time of the time range for which a Chaos report is to be generated.
   * Consult [DateTime.ToFileTimeUtc
   * Method](https://msdn.microsoft.com/library/system.datetime.tofiletimeutc(v=vs.110).aspx)
   * for details.
   */
  startTimeUtc?: string;
  /**
   * @member {string} [endTimeUtc] The Windows file time representing the end
   * time of the time range for which a Chaos report is to be generated.
   * Consult [DateTime.ToFileTimeUtc
   * Method](https://msdn.microsoft.com/library/system.datetime.tofiletimeutc(v=vs.110).aspx)
   * for details.
   */
  endTimeUtc?: string;
  /**
   * @member {number} [maxResults] The maximum number of results to be returned
   * as part of the paged queries. This parameter defines the upper bound on
   * the number of results returned. The results returned can be less than the
   * specified maximum results if they do not fit in the message as per the max
   * message size restrictions defined in the configuration. If this parameter
   * is zero or not specified, the paged query includes as many results as
   * possible that fit in the return message. Default value: 0 .
   */
  maxResults?: number;
  /**
   * @member {number} [timeoutParameter] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds. Default value: 60 .
   */
  timeoutParameter?: number;
}

/**
 * @interface
 * An interface representing ServiceFabricClientGetChaosScheduleOptionalParams.
 * Optional Parameters.
 *
 * @extends RequestOptionsBase
 */
export interface ServiceFabricClientGetChaosScheduleOptionalParams extends msRest.RequestOptionsBase {
  /**
   * @member {number} [timeoutParameter] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds. Default value: 60 .
   */
  timeoutParameter?: number;
}

/**
 * @interface
 * An interface representing ServiceFabricClientPostChaosScheduleOptionalParams.
 * Optional Parameters.
 *
 * @extends RequestOptionsBase
 */
export interface ServiceFabricClientPostChaosScheduleOptionalParams extends msRest.RequestOptionsBase {
  /**
   * @member {number} [timeoutParameter] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds. Default value: 60 .
   */
  timeoutParameter?: number;
}

/**
 * @interface
 * An interface representing ServiceFabricClientUploadFileOptionalParams.
 * Optional Parameters.
 *
 * @extends RequestOptionsBase
 */
export interface ServiceFabricClientUploadFileOptionalParams extends msRest.RequestOptionsBase {
  /**
   * @member {number} [timeoutParameter] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds. Default value: 60 .
   */
  timeoutParameter?: number;
}

/**
 * @interface
 * An interface representing ServiceFabricClientGetImageStoreContentOptionalParams.
 * Optional Parameters.
 *
 * @extends RequestOptionsBase
 */
export interface ServiceFabricClientGetImageStoreContentOptionalParams extends msRest.RequestOptionsBase {
  /**
   * @member {number} [timeoutParameter] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds. Default value: 60 .
   */
  timeoutParameter?: number;
}

/**
 * @interface
 * An interface representing ServiceFabricClientDeleteImageStoreContentOptionalParams.
 * Optional Parameters.
 *
 * @extends RequestOptionsBase
 */
export interface ServiceFabricClientDeleteImageStoreContentOptionalParams extends msRest.RequestOptionsBase {
  /**
   * @member {number} [timeoutParameter] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds. Default value: 60 .
   */
  timeoutParameter?: number;
}

/**
 * @interface
 * An interface representing ServiceFabricClientGetImageStoreRootContentOptionalParams.
 * Optional Parameters.
 *
 * @extends RequestOptionsBase
 */
export interface ServiceFabricClientGetImageStoreRootContentOptionalParams extends msRest.RequestOptionsBase {
  /**
   * @member {number} [timeoutParameter] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds. Default value: 60 .
   */
  timeoutParameter?: number;
}

/**
 * @interface
 * An interface representing ServiceFabricClientCopyImageStoreContentOptionalParams.
 * Optional Parameters.
 *
 * @extends RequestOptionsBase
 */
export interface ServiceFabricClientCopyImageStoreContentOptionalParams extends msRest.RequestOptionsBase {
  /**
   * @member {number} [timeoutParameter] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds. Default value: 60 .
   */
  timeoutParameter?: number;
}

/**
 * @interface
 * An interface representing ServiceFabricClientDeleteImageStoreUploadSessionOptionalParams.
 * Optional Parameters.
 *
 * @extends RequestOptionsBase
 */
export interface ServiceFabricClientDeleteImageStoreUploadSessionOptionalParams extends msRest.RequestOptionsBase {
  /**
   * @member {number} [timeoutParameter] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds. Default value: 60 .
   */
  timeoutParameter?: number;
}

/**
 * @interface
 * An interface representing ServiceFabricClientCommitImageStoreUploadSessionOptionalParams.
 * Optional Parameters.
 *
 * @extends RequestOptionsBase
 */
export interface ServiceFabricClientCommitImageStoreUploadSessionOptionalParams extends msRest.RequestOptionsBase {
  /**
   * @member {number} [timeoutParameter] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds. Default value: 60 .
   */
  timeoutParameter?: number;
}

/**
 * @interface
 * An interface representing ServiceFabricClientGetImageStoreUploadSessionByIdOptionalParams.
 * Optional Parameters.
 *
 * @extends RequestOptionsBase
 */
export interface ServiceFabricClientGetImageStoreUploadSessionByIdOptionalParams extends msRest.RequestOptionsBase {
  /**
   * @member {number} [timeoutParameter] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds. Default value: 60 .
   */
  timeoutParameter?: number;
}

/**
 * @interface
 * An interface representing ServiceFabricClientGetImageStoreUploadSessionByPathOptionalParams.
 * Optional Parameters.
 *
 * @extends RequestOptionsBase
 */
export interface ServiceFabricClientGetImageStoreUploadSessionByPathOptionalParams extends msRest.RequestOptionsBase {
  /**
   * @member {number} [timeoutParameter] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds. Default value: 60 .
   */
  timeoutParameter?: number;
}

/**
 * @interface
 * An interface representing ServiceFabricClientUploadFileChunkOptionalParams.
 * Optional Parameters.
 *
 * @extends RequestOptionsBase
 */
export interface ServiceFabricClientUploadFileChunkOptionalParams extends msRest.RequestOptionsBase {
  /**
   * @member {number} [timeoutParameter] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds. Default value: 60 .
   */
  timeoutParameter?: number;
}

/**
 * @interface
 * An interface representing ServiceFabricClientInvokeInfrastructureCommandOptionalParams.
 * Optional Parameters.
 *
 * @extends RequestOptionsBase
 */
export interface ServiceFabricClientInvokeInfrastructureCommandOptionalParams extends msRest.RequestOptionsBase {
  /**
   * @member {string} [serviceId] The identity of the infrastructure service.
   * This is the full name of the infrastructure service without the 'fabric:'
   * URI scheme. This parameter required only for the cluster that has more
   * than one instance of infrastructure service running.
   */
  serviceId?: string;
  /**
   * @member {number} [timeoutParameter] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds. Default value: 60 .
   */
  timeoutParameter?: number;
}

/**
 * @interface
 * An interface representing ServiceFabricClientInvokeInfrastructureQueryOptionalParams.
 * Optional Parameters.
 *
 * @extends RequestOptionsBase
 */
export interface ServiceFabricClientInvokeInfrastructureQueryOptionalParams extends msRest.RequestOptionsBase {
  /**
   * @member {string} [serviceId] The identity of the infrastructure service.
   * This is the full name of the infrastructure service without the 'fabric:'
   * URI scheme. This parameter required only for the cluster that has more
   * than one instance of infrastructure service running.
   */
  serviceId?: string;
  /**
   * @member {number} [timeoutParameter] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds. Default value: 60 .
   */
  timeoutParameter?: number;
}

/**
 * @interface
 * An interface representing ServiceFabricClientStartDataLossOptionalParams.
 * Optional Parameters.
 *
 * @extends RequestOptionsBase
 */
export interface ServiceFabricClientStartDataLossOptionalParams extends msRest.RequestOptionsBase {
  /**
   * @member {number} [timeoutParameter] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds. Default value: 60 .
   */
  timeoutParameter?: number;
}

/**
 * @interface
 * An interface representing ServiceFabricClientGetDataLossProgressOptionalParams.
 * Optional Parameters.
 *
 * @extends RequestOptionsBase
 */
export interface ServiceFabricClientGetDataLossProgressOptionalParams extends msRest.RequestOptionsBase {
  /**
   * @member {number} [timeoutParameter] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds. Default value: 60 .
   */
  timeoutParameter?: number;
}

/**
 * @interface
 * An interface representing ServiceFabricClientStartQuorumLossOptionalParams.
 * Optional Parameters.
 *
 * @extends RequestOptionsBase
 */
export interface ServiceFabricClientStartQuorumLossOptionalParams extends msRest.RequestOptionsBase {
  /**
   * @member {number} [timeoutParameter] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds. Default value: 60 .
   */
  timeoutParameter?: number;
}

/**
 * @interface
 * An interface representing ServiceFabricClientGetQuorumLossProgressOptionalParams.
 * Optional Parameters.
 *
 * @extends RequestOptionsBase
 */
export interface ServiceFabricClientGetQuorumLossProgressOptionalParams extends msRest.RequestOptionsBase {
  /**
   * @member {number} [timeoutParameter] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds. Default value: 60 .
   */
  timeoutParameter?: number;
}

/**
 * @interface
 * An interface representing ServiceFabricClientStartPartitionRestartOptionalParams.
 * Optional Parameters.
 *
 * @extends RequestOptionsBase
 */
export interface ServiceFabricClientStartPartitionRestartOptionalParams extends msRest.RequestOptionsBase {
  /**
   * @member {number} [timeoutParameter] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds. Default value: 60 .
   */
  timeoutParameter?: number;
}

/**
 * @interface
 * An interface representing ServiceFabricClientGetPartitionRestartProgressOptionalParams.
 * Optional Parameters.
 *
 * @extends RequestOptionsBase
 */
export interface ServiceFabricClientGetPartitionRestartProgressOptionalParams extends msRest.RequestOptionsBase {
  /**
   * @member {number} [timeoutParameter] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds. Default value: 60 .
   */
  timeoutParameter?: number;
}

/**
 * @interface
 * An interface representing ServiceFabricClientStartNodeTransitionOptionalParams.
 * Optional Parameters.
 *
 * @extends RequestOptionsBase
 */
export interface ServiceFabricClientStartNodeTransitionOptionalParams extends msRest.RequestOptionsBase {
  /**
   * @member {number} [timeoutParameter] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds. Default value: 60 .
   */
  timeoutParameter?: number;
}

/**
 * @interface
 * An interface representing ServiceFabricClientGetNodeTransitionProgressOptionalParams.
 * Optional Parameters.
 *
 * @extends RequestOptionsBase
 */
export interface ServiceFabricClientGetNodeTransitionProgressOptionalParams extends msRest.RequestOptionsBase {
  /**
   * @member {number} [timeoutParameter] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds. Default value: 60 .
   */
  timeoutParameter?: number;
}

/**
 * @interface
 * An interface representing ServiceFabricClientGetFaultOperationListOptionalParams.
 * Optional Parameters.
 *
 * @extends RequestOptionsBase
 */
export interface ServiceFabricClientGetFaultOperationListOptionalParams extends msRest.RequestOptionsBase {
  /**
   * @member {number} [timeoutParameter] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds. Default value: 60 .
   */
  timeoutParameter?: number;
}

/**
 * @interface
 * An interface representing ServiceFabricClientCancelOperationOptionalParams.
 * Optional Parameters.
 *
 * @extends RequestOptionsBase
 */
export interface ServiceFabricClientCancelOperationOptionalParams extends msRest.RequestOptionsBase {
  /**
   * @member {number} [timeoutParameter] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds. Default value: 60 .
   */
  timeoutParameter?: number;
}

/**
 * @interface
 * An interface representing ServiceFabricClientCreateBackupPolicyOptionalParams.
 * Optional Parameters.
 *
 * @extends RequestOptionsBase
 */
export interface ServiceFabricClientCreateBackupPolicyOptionalParams extends msRest.RequestOptionsBase {
  /**
   * @member {number} [timeoutParameter] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds. Default value: 60 .
   */
  timeoutParameter?: number;
}

/**
 * @interface
 * An interface representing ServiceFabricClientDeleteBackupPolicyOptionalParams.
 * Optional Parameters.
 *
 * @extends RequestOptionsBase
 */
export interface ServiceFabricClientDeleteBackupPolicyOptionalParams extends msRest.RequestOptionsBase {
  /**
   * @member {number} [timeoutParameter] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds. Default value: 60 .
   */
  timeoutParameter?: number;
}

/**
 * @interface
 * An interface representing ServiceFabricClientGetBackupPolicyListOptionalParams.
 * Optional Parameters.
 *
 * @extends RequestOptionsBase
 */
export interface ServiceFabricClientGetBackupPolicyListOptionalParams extends msRest.RequestOptionsBase {
  /**
   * @member {string} [continuationToken] The continuation token parameter is
   * used to obtain next set of results. A continuation token with a non-empty
   * value is included in the response of the API when the results from the
   * system do not fit in a single response. When this value is passed to the
   * next API call, the API returns next set of results. If there are no
   * further results, then the continuation token does not contain a value. The
   * value of this parameter should not be URL encoded.
   */
  continuationToken?: string;
  /**
   * @member {number} [maxResults] The maximum number of results to be returned
   * as part of the paged queries. This parameter defines the upper bound on
   * the number of results returned. The results returned can be less than the
   * specified maximum results if they do not fit in the message as per the max
   * message size restrictions defined in the configuration. If this parameter
   * is zero or not specified, the paged query includes as many results as
   * possible that fit in the return message. Default value: 0 .
   */
  maxResults?: number;
  /**
   * @member {number} [timeoutParameter] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds. Default value: 60 .
   */
  timeoutParameter?: number;
}

/**
 * @interface
 * An interface representing ServiceFabricClientGetBackupPolicyByNameOptionalParams.
 * Optional Parameters.
 *
 * @extends RequestOptionsBase
 */
export interface ServiceFabricClientGetBackupPolicyByNameOptionalParams extends msRest.RequestOptionsBase {
  /**
   * @member {number} [timeoutParameter] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds. Default value: 60 .
   */
  timeoutParameter?: number;
}

/**
 * @interface
 * An interface representing ServiceFabricClientGetAllEntitiesBackedUpByPolicyOptionalParams.
 * Optional Parameters.
 *
 * @extends RequestOptionsBase
 */
export interface ServiceFabricClientGetAllEntitiesBackedUpByPolicyOptionalParams extends msRest.RequestOptionsBase {
  /**
   * @member {string} [continuationToken] The continuation token parameter is
   * used to obtain next set of results. A continuation token with a non-empty
   * value is included in the response of the API when the results from the
   * system do not fit in a single response. When this value is passed to the
   * next API call, the API returns next set of results. If there are no
   * further results, then the continuation token does not contain a value. The
   * value of this parameter should not be URL encoded.
   */
  continuationToken?: string;
  /**
   * @member {number} [maxResults] The maximum number of results to be returned
   * as part of the paged queries. This parameter defines the upper bound on
   * the number of results returned. The results returned can be less than the
   * specified maximum results if they do not fit in the message as per the max
   * message size restrictions defined in the configuration. If this parameter
   * is zero or not specified, the paged query includes as many results as
   * possible that fit in the return message. Default value: 0 .
   */
  maxResults?: number;
  /**
   * @member {number} [timeoutParameter] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds. Default value: 60 .
   */
  timeoutParameter?: number;
}

/**
 * @interface
 * An interface representing ServiceFabricClientUpdateBackupPolicyOptionalParams.
 * Optional Parameters.
 *
 * @extends RequestOptionsBase
 */
export interface ServiceFabricClientUpdateBackupPolicyOptionalParams extends msRest.RequestOptionsBase {
  /**
   * @member {number} [timeoutParameter] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds. Default value: 60 .
   */
  timeoutParameter?: number;
}

/**
 * @interface
 * An interface representing ServiceFabricClientEnableApplicationBackupOptionalParams.
 * Optional Parameters.
 *
 * @extends RequestOptionsBase
 */
export interface ServiceFabricClientEnableApplicationBackupOptionalParams extends msRest.RequestOptionsBase {
  /**
   * @member {number} [timeoutParameter] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds. Default value: 60 .
   */
  timeoutParameter?: number;
}

/**
 * @interface
 * An interface representing ServiceFabricClientDisableApplicationBackupOptionalParams.
 * Optional Parameters.
 *
 * @extends RequestOptionsBase
 */
export interface ServiceFabricClientDisableApplicationBackupOptionalParams extends msRest.RequestOptionsBase {
  /**
   * @member {number} [timeoutParameter] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds. Default value: 60 .
   */
  timeoutParameter?: number;
}

/**
 * @interface
 * An interface representing ServiceFabricClientGetApplicationBackupConfigurationInfoOptionalParams.
 * Optional Parameters.
 *
 * @extends RequestOptionsBase
 */
export interface ServiceFabricClientGetApplicationBackupConfigurationInfoOptionalParams extends msRest.RequestOptionsBase {
  /**
   * @member {string} [continuationToken] The continuation token parameter is
   * used to obtain next set of results. A continuation token with a non-empty
   * value is included in the response of the API when the results from the
   * system do not fit in a single response. When this value is passed to the
   * next API call, the API returns next set of results. If there are no
   * further results, then the continuation token does not contain a value. The
   * value of this parameter should not be URL encoded.
   */
  continuationToken?: string;
  /**
   * @member {number} [maxResults] The maximum number of results to be returned
   * as part of the paged queries. This parameter defines the upper bound on
   * the number of results returned. The results returned can be less than the
   * specified maximum results if they do not fit in the message as per the max
   * message size restrictions defined in the configuration. If this parameter
   * is zero or not specified, the paged query includes as many results as
   * possible that fit in the return message. Default value: 0 .
   */
  maxResults?: number;
  /**
   * @member {number} [timeoutParameter] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds. Default value: 60 .
   */
  timeoutParameter?: number;
}

/**
 * @interface
 * An interface representing ServiceFabricClientGetApplicationBackupListOptionalParams.
 * Optional Parameters.
 *
 * @extends RequestOptionsBase
 */
export interface ServiceFabricClientGetApplicationBackupListOptionalParams extends msRest.RequestOptionsBase {
  /**
   * @member {number} [timeoutParameter] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds. Default value: 60 .
   */
  timeoutParameter?: number;
  /**
   * @member {boolean} [latest] Specifies whether to get only the most recent
   * backup available for a partition for the specified time range. Default
   * value: false .
   */
  latest?: boolean;
  /**
   * @member {Date} [startDateTimeFilter] Specify the start date time from
   * which to enumerate backups, in datetime format. The date time must be
   * specified in ISO8601 format. This is an optional parameter. If not
   * specified, all backups from the beginning are enumerated.
   */
  startDateTimeFilter?: Date;
  /**
   * @member {Date} [endDateTimeFilter] Specify the end date time till which to
   * enumerate backups, in datetime format. The date time must be specified in
   * ISO8601 format. This is an optional parameter. If not specified,
   * enumeration is done till the most recent backup.
   */
  endDateTimeFilter?: Date;
  /**
   * @member {string} [continuationToken] The continuation token parameter is
   * used to obtain next set of results. A continuation token with a non-empty
   * value is included in the response of the API when the results from the
   * system do not fit in a single response. When this value is passed to the
   * next API call, the API returns next set of results. If there are no
   * further results, then the continuation token does not contain a value. The
   * value of this parameter should not be URL encoded.
   */
  continuationToken?: string;
  /**
   * @member {number} [maxResults] The maximum number of results to be returned
   * as part of the paged queries. This parameter defines the upper bound on
   * the number of results returned. The results returned can be less than the
   * specified maximum results if they do not fit in the message as per the max
   * message size restrictions defined in the configuration. If this parameter
   * is zero or not specified, the paged query includes as many results as
   * possible that fit in the return message. Default value: 0 .
   */
  maxResults?: number;
}

/**
 * @interface
 * An interface representing ServiceFabricClientSuspendApplicationBackupOptionalParams.
 * Optional Parameters.
 *
 * @extends RequestOptionsBase
 */
export interface ServiceFabricClientSuspendApplicationBackupOptionalParams extends msRest.RequestOptionsBase {
  /**
   * @member {number} [timeoutParameter] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds. Default value: 60 .
   */
  timeoutParameter?: number;
}

/**
 * @interface
 * An interface representing ServiceFabricClientResumeApplicationBackupOptionalParams.
 * Optional Parameters.
 *
 * @extends RequestOptionsBase
 */
export interface ServiceFabricClientResumeApplicationBackupOptionalParams extends msRest.RequestOptionsBase {
  /**
   * @member {number} [timeoutParameter] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds. Default value: 60 .
   */
  timeoutParameter?: number;
}

/**
 * @interface
 * An interface representing ServiceFabricClientEnableServiceBackupOptionalParams.
 * Optional Parameters.
 *
 * @extends RequestOptionsBase
 */
export interface ServiceFabricClientEnableServiceBackupOptionalParams extends msRest.RequestOptionsBase {
  /**
   * @member {number} [timeoutParameter] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds. Default value: 60 .
   */
  timeoutParameter?: number;
}

/**
 * @interface
 * An interface representing ServiceFabricClientDisableServiceBackupOptionalParams.
 * Optional Parameters.
 *
 * @extends RequestOptionsBase
 */
export interface ServiceFabricClientDisableServiceBackupOptionalParams extends msRest.RequestOptionsBase {
  /**
   * @member {number} [timeoutParameter] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds. Default value: 60 .
   */
  timeoutParameter?: number;
}

/**
 * @interface
 * An interface representing ServiceFabricClientGetServiceBackupConfigurationInfoOptionalParams.
 * Optional Parameters.
 *
 * @extends RequestOptionsBase
 */
export interface ServiceFabricClientGetServiceBackupConfigurationInfoOptionalParams extends msRest.RequestOptionsBase {
  /**
   * @member {string} [continuationToken] The continuation token parameter is
   * used to obtain next set of results. A continuation token with a non-empty
   * value is included in the response of the API when the results from the
   * system do not fit in a single response. When this value is passed to the
   * next API call, the API returns next set of results. If there are no
   * further results, then the continuation token does not contain a value. The
   * value of this parameter should not be URL encoded.
   */
  continuationToken?: string;
  /**
   * @member {number} [maxResults] The maximum number of results to be returned
   * as part of the paged queries. This parameter defines the upper bound on
   * the number of results returned. The results returned can be less than the
   * specified maximum results if they do not fit in the message as per the max
   * message size restrictions defined in the configuration. If this parameter
   * is zero or not specified, the paged query includes as many results as
   * possible that fit in the return message. Default value: 0 .
   */
  maxResults?: number;
  /**
   * @member {number} [timeoutParameter] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds. Default value: 60 .
   */
  timeoutParameter?: number;
}

/**
 * @interface
 * An interface representing ServiceFabricClientGetServiceBackupListOptionalParams.
 * Optional Parameters.
 *
 * @extends RequestOptionsBase
 */
export interface ServiceFabricClientGetServiceBackupListOptionalParams extends msRest.RequestOptionsBase {
  /**
   * @member {number} [timeoutParameter] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds. Default value: 60 .
   */
  timeoutParameter?: number;
  /**
   * @member {boolean} [latest] Specifies whether to get only the most recent
   * backup available for a partition for the specified time range. Default
   * value: false .
   */
  latest?: boolean;
  /**
   * @member {Date} [startDateTimeFilter] Specify the start date time from
   * which to enumerate backups, in datetime format. The date time must be
   * specified in ISO8601 format. This is an optional parameter. If not
   * specified, all backups from the beginning are enumerated.
   */
  startDateTimeFilter?: Date;
  /**
   * @member {Date} [endDateTimeFilter] Specify the end date time till which to
   * enumerate backups, in datetime format. The date time must be specified in
   * ISO8601 format. This is an optional parameter. If not specified,
   * enumeration is done till the most recent backup.
   */
  endDateTimeFilter?: Date;
  /**
   * @member {string} [continuationToken] The continuation token parameter is
   * used to obtain next set of results. A continuation token with a non-empty
   * value is included in the response of the API when the results from the
   * system do not fit in a single response. When this value is passed to the
   * next API call, the API returns next set of results. If there are no
   * further results, then the continuation token does not contain a value. The
   * value of this parameter should not be URL encoded.
   */
  continuationToken?: string;
  /**
   * @member {number} [maxResults] The maximum number of results to be returned
   * as part of the paged queries. This parameter defines the upper bound on
   * the number of results returned. The results returned can be less than the
   * specified maximum results if they do not fit in the message as per the max
   * message size restrictions defined in the configuration. If this parameter
   * is zero or not specified, the paged query includes as many results as
   * possible that fit in the return message. Default value: 0 .
   */
  maxResults?: number;
}

/**
 * @interface
 * An interface representing ServiceFabricClientSuspendServiceBackupOptionalParams.
 * Optional Parameters.
 *
 * @extends RequestOptionsBase
 */
export interface ServiceFabricClientSuspendServiceBackupOptionalParams extends msRest.RequestOptionsBase {
  /**
   * @member {number} [timeoutParameter] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds. Default value: 60 .
   */
  timeoutParameter?: number;
}

/**
 * @interface
 * An interface representing ServiceFabricClientResumeServiceBackupOptionalParams.
 * Optional Parameters.
 *
 * @extends RequestOptionsBase
 */
export interface ServiceFabricClientResumeServiceBackupOptionalParams extends msRest.RequestOptionsBase {
  /**
   * @member {number} [timeoutParameter] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds. Default value: 60 .
   */
  timeoutParameter?: number;
}

/**
 * @interface
 * An interface representing ServiceFabricClientEnablePartitionBackupOptionalParams.
 * Optional Parameters.
 *
 * @extends RequestOptionsBase
 */
export interface ServiceFabricClientEnablePartitionBackupOptionalParams extends msRest.RequestOptionsBase {
  /**
   * @member {number} [timeoutParameter] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds. Default value: 60 .
   */
  timeoutParameter?: number;
}

/**
 * @interface
 * An interface representing ServiceFabricClientDisablePartitionBackupOptionalParams.
 * Optional Parameters.
 *
 * @extends RequestOptionsBase
 */
export interface ServiceFabricClientDisablePartitionBackupOptionalParams extends msRest.RequestOptionsBase {
  /**
   * @member {number} [timeoutParameter] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds. Default value: 60 .
   */
  timeoutParameter?: number;
}

/**
 * @interface
 * An interface representing ServiceFabricClientGetPartitionBackupConfigurationInfoOptionalParams.
 * Optional Parameters.
 *
 * @extends RequestOptionsBase
 */
export interface ServiceFabricClientGetPartitionBackupConfigurationInfoOptionalParams extends msRest.RequestOptionsBase {
  /**
   * @member {number} [timeoutParameter] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds. Default value: 60 .
   */
  timeoutParameter?: number;
}

/**
 * @interface
 * An interface representing ServiceFabricClientGetPartitionBackupListOptionalParams.
 * Optional Parameters.
 *
 * @extends RequestOptionsBase
 */
export interface ServiceFabricClientGetPartitionBackupListOptionalParams extends msRest.RequestOptionsBase {
  /**
   * @member {number} [timeoutParameter] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds. Default value: 60 .
   */
  timeoutParameter?: number;
  /**
   * @member {boolean} [latest] Specifies whether to get only the most recent
   * backup available for a partition for the specified time range. Default
   * value: false .
   */
  latest?: boolean;
  /**
   * @member {Date} [startDateTimeFilter] Specify the start date time from
   * which to enumerate backups, in datetime format. The date time must be
   * specified in ISO8601 format. This is an optional parameter. If not
   * specified, all backups from the beginning are enumerated.
   */
  startDateTimeFilter?: Date;
  /**
   * @member {Date} [endDateTimeFilter] Specify the end date time till which to
   * enumerate backups, in datetime format. The date time must be specified in
   * ISO8601 format. This is an optional parameter. If not specified,
   * enumeration is done till the most recent backup.
   */
  endDateTimeFilter?: Date;
}

/**
 * @interface
 * An interface representing ServiceFabricClientSuspendPartitionBackupOptionalParams.
 * Optional Parameters.
 *
 * @extends RequestOptionsBase
 */
export interface ServiceFabricClientSuspendPartitionBackupOptionalParams extends msRest.RequestOptionsBase {
  /**
   * @member {number} [timeoutParameter] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds. Default value: 60 .
   */
  timeoutParameter?: number;
}

/**
 * @interface
 * An interface representing ServiceFabricClientResumePartitionBackupOptionalParams.
 * Optional Parameters.
 *
 * @extends RequestOptionsBase
 */
export interface ServiceFabricClientResumePartitionBackupOptionalParams extends msRest.RequestOptionsBase {
  /**
   * @member {number} [timeoutParameter] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds. Default value: 60 .
   */
  timeoutParameter?: number;
}

/**
 * @interface
 * An interface representing ServiceFabricClientBackupPartitionOptionalParams.
 * Optional Parameters.
 *
 * @extends RequestOptionsBase
 */
export interface ServiceFabricClientBackupPartitionOptionalParams extends msRest.RequestOptionsBase {
  /**
   * @member {BackupPartitionDescription} [backupPartitionDescription]
   * Describes the parameters to backup the partition now. If not present,
   * backup operation uses default parameters from the backup policy current
   * associated with this partition.
   */
  backupPartitionDescription?: BackupPartitionDescription;
  /**
   * @member {number} [backupTimeout] Specifies the maximum amount of time, in
   * minutes, to wait for the backup operation to complete. Post that, the
   * operation completes with timeout error. However, in certain corner cases
   * it could be that though the operation returns back timeout, the backup
   * actually goes through. In case of timeout error, its recommended to invoke
   * this operation again with a greater timeout value. The default value for
   * the same is 10 minutes. Default value: 10 .
   */
  backupTimeout?: number;
  /**
   * @member {number} [timeoutParameter] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds. Default value: 60 .
   */
  timeoutParameter?: number;
}

/**
 * @interface
 * An interface representing ServiceFabricClientGetPartitionBackupProgressOptionalParams.
 * Optional Parameters.
 *
 * @extends RequestOptionsBase
 */
export interface ServiceFabricClientGetPartitionBackupProgressOptionalParams extends msRest.RequestOptionsBase {
  /**
   * @member {number} [timeoutParameter] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds. Default value: 60 .
   */
  timeoutParameter?: number;
}

/**
 * @interface
 * An interface representing ServiceFabricClientRestorePartitionOptionalParams.
 * Optional Parameters.
 *
 * @extends RequestOptionsBase
 */
export interface ServiceFabricClientRestorePartitionOptionalParams extends msRest.RequestOptionsBase {
  /**
   * @member {number} [restoreTimeout] Specifies the maximum amount of time to
   * wait, in minutes, for the restore operation to complete. Post that, the
   * operation returns back with timeout error. However, in certain corner
   * cases it could be that the restore operation goes through even though it
   * completes with timeout. In case of timeout error, its recommended to
   * invoke this operation again with a greater timeout value. the default
   * value for the same is 10 minutes. Default value: 10 .
   */
  restoreTimeout?: number;
  /**
   * @member {number} [timeoutParameter] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds. Default value: 60 .
   */
  timeoutParameter?: number;
}

/**
 * @interface
 * An interface representing ServiceFabricClientGetPartitionRestoreProgressOptionalParams.
 * Optional Parameters.
 *
 * @extends RequestOptionsBase
 */
export interface ServiceFabricClientGetPartitionRestoreProgressOptionalParams extends msRest.RequestOptionsBase {
  /**
   * @member {number} [timeoutParameter] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds. Default value: 60 .
   */
  timeoutParameter?: number;
}

/**
 * @interface
 * An interface representing ServiceFabricClientGetBackupsFromBackupLocationOptionalParams.
 * Optional Parameters.
 *
 * @extends RequestOptionsBase
 */
export interface ServiceFabricClientGetBackupsFromBackupLocationOptionalParams extends msRest.RequestOptionsBase {
  /**
   * @member {number} [timeoutParameter] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds. Default value: 60 .
   */
  timeoutParameter?: number;
  /**
   * @member {string} [continuationToken] The continuation token parameter is
   * used to obtain next set of results. A continuation token with a non-empty
   * value is included in the response of the API when the results from the
   * system do not fit in a single response. When this value is passed to the
   * next API call, the API returns next set of results. If there are no
   * further results, then the continuation token does not contain a value. The
   * value of this parameter should not be URL encoded.
   */
  continuationToken?: string;
  /**
   * @member {number} [maxResults] The maximum number of results to be returned
   * as part of the paged queries. This parameter defines the upper bound on
   * the number of results returned. The results returned can be less than the
   * specified maximum results if they do not fit in the message as per the max
   * message size restrictions defined in the configuration. If this parameter
   * is zero or not specified, the paged query includes as many results as
   * possible that fit in the return message. Default value: 0 .
   */
  maxResults?: number;
}

/**
 * @interface
 * An interface representing ServiceFabricClientCreateNameOptionalParams.
 * Optional Parameters.
 *
 * @extends RequestOptionsBase
 */
export interface ServiceFabricClientCreateNameOptionalParams extends msRest.RequestOptionsBase {
  /**
   * @member {number} [timeoutParameter] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds. Default value: 60 .
   */
  timeoutParameter?: number;
}

/**
 * @interface
 * An interface representing ServiceFabricClientGetNameExistsInfoOptionalParams.
 * Optional Parameters.
 *
 * @extends RequestOptionsBase
 */
export interface ServiceFabricClientGetNameExistsInfoOptionalParams extends msRest.RequestOptionsBase {
  /**
   * @member {number} [timeoutParameter] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds. Default value: 60 .
   */
  timeoutParameter?: number;
}

/**
 * @interface
 * An interface representing ServiceFabricClientDeleteNameOptionalParams.
 * Optional Parameters.
 *
 * @extends RequestOptionsBase
 */
export interface ServiceFabricClientDeleteNameOptionalParams extends msRest.RequestOptionsBase {
  /**
   * @member {number} [timeoutParameter] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds. Default value: 60 .
   */
  timeoutParameter?: number;
}

/**
 * @interface
 * An interface representing ServiceFabricClientGetSubNameInfoListOptionalParams.
 * Optional Parameters.
 *
 * @extends RequestOptionsBase
 */
export interface ServiceFabricClientGetSubNameInfoListOptionalParams extends msRest.RequestOptionsBase {
  /**
   * @member {boolean} [recursive] Allows specifying that the search performed
   * should be recursive. Default value: false .
   */
  recursive?: boolean;
  /**
   * @member {string} [continuationToken] The continuation token parameter is
   * used to obtain next set of results. A continuation token with a non-empty
   * value is included in the response of the API when the results from the
   * system do not fit in a single response. When this value is passed to the
   * next API call, the API returns next set of results. If there are no
   * further results, then the continuation token does not contain a value. The
   * value of this parameter should not be URL encoded.
   */
  continuationToken?: string;
  /**
   * @member {number} [timeoutParameter] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds. Default value: 60 .
   */
  timeoutParameter?: number;
}

/**
 * @interface
 * An interface representing ServiceFabricClientGetPropertyInfoListOptionalParams.
 * Optional Parameters.
 *
 * @extends RequestOptionsBase
 */
export interface ServiceFabricClientGetPropertyInfoListOptionalParams extends msRest.RequestOptionsBase {
  /**
   * @member {boolean} [includeValues] Allows specifying whether to include the
   * values of the properties returned. True if values should be returned with
   * the metadata; False to return only property metadata. Default value: false
   * .
   */
  includeValues?: boolean;
  /**
   * @member {string} [continuationToken] The continuation token parameter is
   * used to obtain next set of results. A continuation token with a non-empty
   * value is included in the response of the API when the results from the
   * system do not fit in a single response. When this value is passed to the
   * next API call, the API returns next set of results. If there are no
   * further results, then the continuation token does not contain a value. The
   * value of this parameter should not be URL encoded.
   */
  continuationToken?: string;
  /**
   * @member {number} [timeoutParameter] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds. Default value: 60 .
   */
  timeoutParameter?: number;
}

/**
 * @interface
 * An interface representing ServiceFabricClientPutPropertyOptionalParams.
 * Optional Parameters.
 *
 * @extends RequestOptionsBase
 */
export interface ServiceFabricClientPutPropertyOptionalParams extends msRest.RequestOptionsBase {
  /**
   * @member {number} [timeoutParameter] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds. Default value: 60 .
   */
  timeoutParameter?: number;
}

/**
 * @interface
 * An interface representing ServiceFabricClientGetPropertyInfoOptionalParams.
 * Optional Parameters.
 *
 * @extends RequestOptionsBase
 */
export interface ServiceFabricClientGetPropertyInfoOptionalParams extends msRest.RequestOptionsBase {
  /**
   * @member {number} [timeoutParameter] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds. Default value: 60 .
   */
  timeoutParameter?: number;
}

/**
 * @interface
 * An interface representing ServiceFabricClientDeletePropertyOptionalParams.
 * Optional Parameters.
 *
 * @extends RequestOptionsBase
 */
export interface ServiceFabricClientDeletePropertyOptionalParams extends msRest.RequestOptionsBase {
  /**
   * @member {number} [timeoutParameter] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds. Default value: 60 .
   */
  timeoutParameter?: number;
}

/**
 * @interface
 * An interface representing ServiceFabricClientSubmitPropertyBatchOptionalParams.
 * Optional Parameters.
 *
 * @extends RequestOptionsBase
 */
export interface ServiceFabricClientSubmitPropertyBatchOptionalParams extends msRest.RequestOptionsBase {
  /**
   * @member {number} [timeoutParameter] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds. Default value: 60 .
   */
  timeoutParameter?: number;
}

/**
 * @interface
 * An interface representing ServiceFabricClientGetClusterEventListOptionalParams.
 * Optional Parameters.
 *
 * @extends RequestOptionsBase
 */
export interface ServiceFabricClientGetClusterEventListOptionalParams extends msRest.RequestOptionsBase {
  /**
   * @member {number} [timeoutParameter] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds. Default value: 60 .
   */
  timeoutParameter?: number;
  /**
   * @member {string} [eventsTypesFilter] This is a comma separated string
   * specifying the types of FabricEvents that should only be included in the
   * response.
   */
  eventsTypesFilter?: string;
  /**
   * @member {boolean} [excludeAnalysisEvents] This param disables the
   * retrieval of AnalysisEvents if true is passed.
   */
  excludeAnalysisEvents?: boolean;
  /**
   * @member {boolean} [skipCorrelationLookup] This param disables the search
   * of CorrelatedEvents information if true is passed. otherwise the
   * CorrelationEvents get processed and HasCorrelatedEvents field in every
   * FabricEvent gets populated.
   */
  skipCorrelationLookup?: boolean;
}

/**
 * @interface
 * An interface representing ServiceFabricClientGetContainersEventListOptionalParams.
 * Optional Parameters.
 *
 * @extends RequestOptionsBase
 */
export interface ServiceFabricClientGetContainersEventListOptionalParams extends msRest.RequestOptionsBase {
  /**
   * @member {number} [timeoutParameter] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds. Default value: 60 .
   */
  timeoutParameter?: number;
  /**
   * @member {string} [eventsTypesFilter] This is a comma separated string
   * specifying the types of FabricEvents that should only be included in the
   * response.
   */
  eventsTypesFilter?: string;
  /**
   * @member {boolean} [excludeAnalysisEvents] This param disables the
   * retrieval of AnalysisEvents if true is passed.
   */
  excludeAnalysisEvents?: boolean;
  /**
   * @member {boolean} [skipCorrelationLookup] This param disables the search
   * of CorrelatedEvents information if true is passed. otherwise the
   * CorrelationEvents get processed and HasCorrelatedEvents field in every
   * FabricEvent gets populated.
   */
  skipCorrelationLookup?: boolean;
}

/**
 * @interface
 * An interface representing ServiceFabricClientGetNodeEventListOptionalParams.
 * Optional Parameters.
 *
 * @extends RequestOptionsBase
 */
export interface ServiceFabricClientGetNodeEventListOptionalParams extends msRest.RequestOptionsBase {
  /**
   * @member {number} [timeoutParameter] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds. Default value: 60 .
   */
  timeoutParameter?: number;
  /**
   * @member {string} [eventsTypesFilter] This is a comma separated string
   * specifying the types of FabricEvents that should only be included in the
   * response.
   */
  eventsTypesFilter?: string;
  /**
   * @member {boolean} [excludeAnalysisEvents] This param disables the
   * retrieval of AnalysisEvents if true is passed.
   */
  excludeAnalysisEvents?: boolean;
  /**
   * @member {boolean} [skipCorrelationLookup] This param disables the search
   * of CorrelatedEvents information if true is passed. otherwise the
   * CorrelationEvents get processed and HasCorrelatedEvents field in every
   * FabricEvent gets populated.
   */
  skipCorrelationLookup?: boolean;
}

/**
 * @interface
 * An interface representing ServiceFabricClientGetNodesEventListOptionalParams.
 * Optional Parameters.
 *
 * @extends RequestOptionsBase
 */
export interface ServiceFabricClientGetNodesEventListOptionalParams extends msRest.RequestOptionsBase {
  /**
   * @member {number} [timeoutParameter] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds. Default value: 60 .
   */
  timeoutParameter?: number;
  /**
   * @member {string} [eventsTypesFilter] This is a comma separated string
   * specifying the types of FabricEvents that should only be included in the
   * response.
   */
  eventsTypesFilter?: string;
  /**
   * @member {boolean} [excludeAnalysisEvents] This param disables the
   * retrieval of AnalysisEvents if true is passed.
   */
  excludeAnalysisEvents?: boolean;
  /**
   * @member {boolean} [skipCorrelationLookup] This param disables the search
   * of CorrelatedEvents information if true is passed. otherwise the
   * CorrelationEvents get processed and HasCorrelatedEvents field in every
   * FabricEvent gets populated.
   */
  skipCorrelationLookup?: boolean;
}

/**
 * @interface
 * An interface representing ServiceFabricClientGetApplicationEventListOptionalParams.
 * Optional Parameters.
 *
 * @extends RequestOptionsBase
 */
export interface ServiceFabricClientGetApplicationEventListOptionalParams extends msRest.RequestOptionsBase {
  /**
   * @member {number} [timeoutParameter] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds. Default value: 60 .
   */
  timeoutParameter?: number;
  /**
   * @member {string} [eventsTypesFilter] This is a comma separated string
   * specifying the types of FabricEvents that should only be included in the
   * response.
   */
  eventsTypesFilter?: string;
  /**
   * @member {boolean} [excludeAnalysisEvents] This param disables the
   * retrieval of AnalysisEvents if true is passed.
   */
  excludeAnalysisEvents?: boolean;
  /**
   * @member {boolean} [skipCorrelationLookup] This param disables the search
   * of CorrelatedEvents information if true is passed. otherwise the
   * CorrelationEvents get processed and HasCorrelatedEvents field in every
   * FabricEvent gets populated.
   */
  skipCorrelationLookup?: boolean;
}

/**
 * @interface
 * An interface representing ServiceFabricClientGetApplicationsEventListOptionalParams.
 * Optional Parameters.
 *
 * @extends RequestOptionsBase
 */
export interface ServiceFabricClientGetApplicationsEventListOptionalParams extends msRest.RequestOptionsBase {
  /**
   * @member {number} [timeoutParameter] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds. Default value: 60 .
   */
  timeoutParameter?: number;
  /**
   * @member {string} [eventsTypesFilter] This is a comma separated string
   * specifying the types of FabricEvents that should only be included in the
   * response.
   */
  eventsTypesFilter?: string;
  /**
   * @member {boolean} [excludeAnalysisEvents] This param disables the
   * retrieval of AnalysisEvents if true is passed.
   */
  excludeAnalysisEvents?: boolean;
  /**
   * @member {boolean} [skipCorrelationLookup] This param disables the search
   * of CorrelatedEvents information if true is passed. otherwise the
   * CorrelationEvents get processed and HasCorrelatedEvents field in every
   * FabricEvent gets populated.
   */
  skipCorrelationLookup?: boolean;
}

/**
 * @interface
 * An interface representing ServiceFabricClientGetServiceEventListOptionalParams.
 * Optional Parameters.
 *
 * @extends RequestOptionsBase
 */
export interface ServiceFabricClientGetServiceEventListOptionalParams extends msRest.RequestOptionsBase {
  /**
   * @member {number} [timeoutParameter] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds. Default value: 60 .
   */
  timeoutParameter?: number;
  /**
   * @member {string} [eventsTypesFilter] This is a comma separated string
   * specifying the types of FabricEvents that should only be included in the
   * response.
   */
  eventsTypesFilter?: string;
  /**
   * @member {boolean} [excludeAnalysisEvents] This param disables the
   * retrieval of AnalysisEvents if true is passed.
   */
  excludeAnalysisEvents?: boolean;
  /**
   * @member {boolean} [skipCorrelationLookup] This param disables the search
   * of CorrelatedEvents information if true is passed. otherwise the
   * CorrelationEvents get processed and HasCorrelatedEvents field in every
   * FabricEvent gets populated.
   */
  skipCorrelationLookup?: boolean;
}

/**
 * @interface
 * An interface representing ServiceFabricClientGetServicesEventListOptionalParams.
 * Optional Parameters.
 *
 * @extends RequestOptionsBase
 */
export interface ServiceFabricClientGetServicesEventListOptionalParams extends msRest.RequestOptionsBase {
  /**
   * @member {number} [timeoutParameter] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds. Default value: 60 .
   */
  timeoutParameter?: number;
  /**
   * @member {string} [eventsTypesFilter] This is a comma separated string
   * specifying the types of FabricEvents that should only be included in the
   * response.
   */
  eventsTypesFilter?: string;
  /**
   * @member {boolean} [excludeAnalysisEvents] This param disables the
   * retrieval of AnalysisEvents if true is passed.
   */
  excludeAnalysisEvents?: boolean;
  /**
   * @member {boolean} [skipCorrelationLookup] This param disables the search
   * of CorrelatedEvents information if true is passed. otherwise the
   * CorrelationEvents get processed and HasCorrelatedEvents field in every
   * FabricEvent gets populated.
   */
  skipCorrelationLookup?: boolean;
}

/**
 * @interface
 * An interface representing ServiceFabricClientGetPartitionEventListOptionalParams.
 * Optional Parameters.
 *
 * @extends RequestOptionsBase
 */
export interface ServiceFabricClientGetPartitionEventListOptionalParams extends msRest.RequestOptionsBase {
  /**
   * @member {number} [timeoutParameter] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds. Default value: 60 .
   */
  timeoutParameter?: number;
  /**
   * @member {string} [eventsTypesFilter] This is a comma separated string
   * specifying the types of FabricEvents that should only be included in the
   * response.
   */
  eventsTypesFilter?: string;
  /**
   * @member {boolean} [excludeAnalysisEvents] This param disables the
   * retrieval of AnalysisEvents if true is passed.
   */
  excludeAnalysisEvents?: boolean;
  /**
   * @member {boolean} [skipCorrelationLookup] This param disables the search
   * of CorrelatedEvents information if true is passed. otherwise the
   * CorrelationEvents get processed and HasCorrelatedEvents field in every
   * FabricEvent gets populated.
   */
  skipCorrelationLookup?: boolean;
}

/**
 * @interface
 * An interface representing ServiceFabricClientGetPartitionsEventListOptionalParams.
 * Optional Parameters.
 *
 * @extends RequestOptionsBase
 */
export interface ServiceFabricClientGetPartitionsEventListOptionalParams extends msRest.RequestOptionsBase {
  /**
   * @member {number} [timeoutParameter] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds. Default value: 60 .
   */
  timeoutParameter?: number;
  /**
   * @member {string} [eventsTypesFilter] This is a comma separated string
   * specifying the types of FabricEvents that should only be included in the
   * response.
   */
  eventsTypesFilter?: string;
  /**
   * @member {boolean} [excludeAnalysisEvents] This param disables the
   * retrieval of AnalysisEvents if true is passed.
   */
  excludeAnalysisEvents?: boolean;
  /**
   * @member {boolean} [skipCorrelationLookup] This param disables the search
   * of CorrelatedEvents information if true is passed. otherwise the
   * CorrelationEvents get processed and HasCorrelatedEvents field in every
   * FabricEvent gets populated.
   */
  skipCorrelationLookup?: boolean;
}

/**
 * @interface
 * An interface representing ServiceFabricClientGetPartitionReplicaEventListOptionalParams.
 * Optional Parameters.
 *
 * @extends RequestOptionsBase
 */
export interface ServiceFabricClientGetPartitionReplicaEventListOptionalParams extends msRest.RequestOptionsBase {
  /**
   * @member {number} [timeoutParameter] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds. Default value: 60 .
   */
  timeoutParameter?: number;
  /**
   * @member {string} [eventsTypesFilter] This is a comma separated string
   * specifying the types of FabricEvents that should only be included in the
   * response.
   */
  eventsTypesFilter?: string;
  /**
   * @member {boolean} [excludeAnalysisEvents] This param disables the
   * retrieval of AnalysisEvents if true is passed.
   */
  excludeAnalysisEvents?: boolean;
  /**
   * @member {boolean} [skipCorrelationLookup] This param disables the search
   * of CorrelatedEvents information if true is passed. otherwise the
   * CorrelationEvents get processed and HasCorrelatedEvents field in every
   * FabricEvent gets populated.
   */
  skipCorrelationLookup?: boolean;
}

/**
 * @interface
 * An interface representing ServiceFabricClientGetPartitionReplicasEventListOptionalParams.
 * Optional Parameters.
 *
 * @extends RequestOptionsBase
 */
export interface ServiceFabricClientGetPartitionReplicasEventListOptionalParams extends msRest.RequestOptionsBase {
  /**
   * @member {number} [timeoutParameter] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds. Default value: 60 .
   */
  timeoutParameter?: number;
  /**
   * @member {string} [eventsTypesFilter] This is a comma separated string
   * specifying the types of FabricEvents that should only be included in the
   * response.
   */
  eventsTypesFilter?: string;
  /**
   * @member {boolean} [excludeAnalysisEvents] This param disables the
   * retrieval of AnalysisEvents if true is passed.
   */
  excludeAnalysisEvents?: boolean;
  /**
   * @member {boolean} [skipCorrelationLookup] This param disables the search
   * of CorrelatedEvents information if true is passed. otherwise the
   * CorrelationEvents get processed and HasCorrelatedEvents field in every
   * FabricEvent gets populated.
   */
  skipCorrelationLookup?: boolean;
}

/**
 * @interface
 * An interface representing ServiceFabricClientGetCorrelatedEventListOptionalParams.
 * Optional Parameters.
 *
 * @extends RequestOptionsBase
 */
export interface ServiceFabricClientGetCorrelatedEventListOptionalParams extends msRest.RequestOptionsBase {
  /**
   * @member {number} [timeoutParameter] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds. Default value: 60 .
   */
  timeoutParameter?: number;
}

/**
 * Defines values for ApplicationDefinitionKind.
 * Possible values include: 'Invalid', 'ServiceFabricApplicationDescription',
 * 'Compose'
 * There could be more values for this enum apart from the ones defined here.If
 * you want to set a value that is not from the known values then you can do
 * the following:
 * let param: ApplicationDefinitionKind =
 * <ApplicationDefinitionKind>"someUnknownValueThatWillStillBeValid";
 * @readonly
 * @enum {string}
 */
export enum ApplicationDefinitionKind {
  /**
   * Indicates the application definition kind is invalid. All Service Fabric
   * enumerations have the invalid type. The value is 65535.
   */
  Invalid = 'Invalid',
  /**
   * Indicates the application is defined by a Service Fabric application
   * description. The value is 0.
   */
  ServiceFabricApplicationDescription = 'ServiceFabricApplicationDescription',
  /**
   * Indicates the application is defined by compose file(s). The value is 1.
   */
  Compose = 'Compose',
}

/**
 * Defines values for HealthState.
 * Possible values include: 'Invalid', 'Ok', 'Warning', 'Error', 'Unknown'
 * There could be more values for this enum apart from the ones defined here.If
 * you want to set a value that is not from the known values then you can do
 * the following:
 * let param: HealthState =
 * <HealthState>"someUnknownValueThatWillStillBeValid";
 * @readonly
 * @enum {string}
 */
export enum HealthState {
  /**
   * Indicates an invalid health state. All Service Fabric enumerations have
   * the invalid type. The value is zero.
   */
  Invalid = 'Invalid',
  /**
   * Indicates the health state is okay. The value is 1.
   */
  Ok = 'Ok',
  /**
   * Indicates the health state is at a warning level. The value is 2.
   */
  Warning = 'Warning',
  /**
   * Indicates the health state is at an error level. Error health state should
   * be investigated, as they can impact the correct functionality of the
   * cluster. The value is 3.
   */
  Error = 'Error',
  /**
   * Indicates an unknown health status. The value is 65535.
   */
  Unknown = 'Unknown',
}

/**
 * Defines values for ApplicationStatus.
 * Possible values include: 'Invalid', 'Ready', 'Upgrading', 'Creating',
 * 'Deleting', 'Failed'
 * There could be more values for this enum apart from the ones defined here.If
 * you want to set a value that is not from the known values then you can do
 * the following:
 * let param: ApplicationStatus =
 * <ApplicationStatus>"someUnknownValueThatWillStillBeValid";
 * @readonly
 * @enum {string}
 */
export enum ApplicationStatus {
  /**
   * Indicates the application status is invalid. All Service Fabric
   * enumerations have the invalid type. The value is zero.
   */
  Invalid = 'Invalid',
  /**
   * Indicates the application status is ready. The value is 1.
   */
  Ready = 'Ready',
  /**
   * Indicates the application status is upgrading. The value is 2.
   */
  Upgrading = 'Upgrading',
  /**
   * Indicates the application status is creating. The value is 3.
   */
  Creating = 'Creating',
  /**
   * Indicates the application status is deleting. The value is 4.
   */
  Deleting = 'Deleting',
  /**
   * Indicates the creation or deletion of application was terminated due to
   * persistent failures. Another create/delete request can be accepted to
   * resume a failed application. The value is 5.
   */
  Failed = 'Failed',
}

/**
 * Defines values for ApplicationPackageCleanupPolicy.
 * Possible values include: 'Invalid', 'Default', 'Automatic', 'Manual'
 * There could be more values for this enum apart from the ones defined here.If
 * you want to set a value that is not from the known values then you can do
 * the following:
 * let param: ApplicationPackageCleanupPolicy =
 * <ApplicationPackageCleanupPolicy>"someUnknownValueThatWillStillBeValid";
 * @readonly
 * @enum {string}
 */
export enum ApplicationPackageCleanupPolicy {
  /**
   * Indicates that the application package cleanup policy is invalid. This
   * value is default. The value is zero.
   */
  Invalid = 'Invalid',
  /**
   * Indicates that the cleanup policy of application packages is based on the
   * cluster setting "CleanupApplicationPackageOnProvisionSuccess." The value
   * is 1.
   */
  Default = 'Default',
  /**
   * Indicates that the service fabric runtime determines when to do the
   * application package cleanup. By default, cleanup is done on successful
   * provision. The value is 2.
   */
  Automatic = 'Automatic',
  /**
   * Indicates that the user has to explicitly clean up the application
   * package. The value is 3.
   */
  Manual = 'Manual',
}

/**
 * Defines values for ApplicationTypeDefinitionKind.
 * Possible values include: 'Invalid', 'ServiceFabricApplicationPackage',
 * 'Compose'
 * There could be more values for this enum apart from the ones defined here.If
 * you want to set a value that is not from the known values then you can do
 * the following:
 * let param: ApplicationTypeDefinitionKind =
 * <ApplicationTypeDefinitionKind>"someUnknownValueThatWillStillBeValid";
 * @readonly
 * @enum {string}
 */
export enum ApplicationTypeDefinitionKind {
  /**
   * Indicates the application type definition kind is invalid. All Service
   * Fabric enumerations have the invalid type. The value is 0.
   */
  Invalid = 'Invalid',
  /**
   * Indicates the application type is defined and created by a Service Fabric
   * application package provided by the user. The value is 1.
   */
  ServiceFabricApplicationPackage = 'ServiceFabricApplicationPackage',
  /**
   * Indicates the application type is defined and created implicitly as part
   * of a compose deployment. The value is 2.
   */
  Compose = 'Compose',
}

/**
 * Defines values for ApplicationTypeStatus.
 * Possible values include: 'Invalid', 'Provisioning', 'Available',
 * 'Unprovisioning', 'Failed'
 * There could be more values for this enum apart from the ones defined here.If
 * you want to set a value that is not from the known values then you can do
 * the following:
 * let param: ApplicationTypeStatus =
 * <ApplicationTypeStatus>"someUnknownValueThatWillStillBeValid";
 * @readonly
 * @enum {string}
 */
export enum ApplicationTypeStatus {
  /**
   * Indicates the application type status is invalid. All Service Fabric
   * enumerations have the invalid type. The value is zero.
   */
  Invalid = 'Invalid',
  /**
   * Indicates that the application type is being provisioned in the cluster.
   * The value is 1.
   */
  Provisioning = 'Provisioning',
  /**
   * Indicates that the application type is fully provisioned and is available
   * for use. An application of this type and version can be created. The value
   * is 2.
   */
  Available = 'Available',
  /**
   * Indicates that the application type is in process of being unprovisioned
   * from the cluster. The value is 3.
   */
  Unprovisioning = 'Unprovisioning',
  /**
   * Indicates that the application type provisioning failed and it is
   * unavailable for use. The failure details can be obtained from the
   * application type information query. The failed application type
   * information remains in the cluster until it is unprovisioned or
   * reprovisioned successfully. The value is 4.
   */
  Failed = 'Failed',
}

/**
 * Defines values for UpgradeKind.
 * Possible values include: 'Invalid', 'Rolling'
 * There could be more values for this enum apart from the ones defined here.If
 * you want to set a value that is not from the known values then you can do
 * the following:
 * let param: UpgradeKind =
 * <UpgradeKind>"someUnknownValueThatWillStillBeValid";
 * @readonly
 * @enum {string}
 */
export enum UpgradeKind {
  /**
   * Indicates the upgrade kind is invalid. All Service Fabric enumerations
   * have the invalid type. The value is zero.
   */
  Invalid = 'Invalid',
  /**
   * The upgrade progresses one upgrade domain at a time. The value is 1
   */
  Rolling = 'Rolling',
}

/**
 * Defines values for UpgradeMode.
 * Possible values include: 'Invalid', 'UnmonitoredAuto', 'UnmonitoredManual',
 * 'Monitored'
 * There could be more values for this enum apart from the ones defined here.If
 * you want to set a value that is not from the known values then you can do
 * the following:
 * let param: UpgradeMode =
 * <UpgradeMode>"someUnknownValueThatWillStillBeValid";
 * @readonly
 * @enum {string}
 */
export enum UpgradeMode {
  /**
   * Indicates the upgrade mode is invalid. All Service Fabric enumerations
   * have the invalid type. The value is zero.
   */
  Invalid = 'Invalid',
  /**
   * The upgrade will proceed automatically without performing any health
   * monitoring. The value is 1
   */
  UnmonitoredAuto = 'UnmonitoredAuto',
  /**
   * The upgrade will stop after completing each upgrade domain, giving the
   * opportunity to manually monitor health before proceeding. The value is 2
   */
  UnmonitoredManual = 'UnmonitoredManual',
  /**
   * The upgrade will stop after completing each upgrade domain and
   * automatically monitor health before proceeding. The value is 3
   */
  Monitored = 'Monitored',
}

/**
 * Defines values for FailureAction.
 * Possible values include: 'Invalid', 'Rollback', 'Manual'
 * There could be more values for this enum apart from the ones defined here.If
 * you want to set a value that is not from the known values then you can do
 * the following:
 * let param: FailureAction =
 * <FailureAction>"someUnknownValueThatWillStillBeValid";
 * @readonly
 * @enum {string}
 */
export enum FailureAction {
  /**
   * Indicates the failure action is invalid. All Service Fabric enumerations
   * have the invalid type. The value is zero.
   */
  Invalid = 'Invalid',
  /**
   * The upgrade will start rolling back automatically. The value is 1
   */
  Rollback = 'Rollback',
  /**
   * The upgrade will switch to UnmonitoredManual upgrade mode. The value is 2
   */
  Manual = 'Manual',
}

/**
 * Defines values for UpgradeDomainState.
 * Possible values include: 'Invalid', 'Pending', 'InProgress', 'Completed'
 * There could be more values for this enum apart from the ones defined here.If
 * you want to set a value that is not from the known values then you can do
 * the following:
 * let param: UpgradeDomainState =
 * <UpgradeDomainState>"someUnknownValueThatWillStillBeValid";
 * @readonly
 * @enum {string}
 */
export enum UpgradeDomainState {
  /**
   * Indicates the upgrade domain state is invalid. All Service Fabric
   * enumerations have the invalid type. The value is zero.
   */
  Invalid = 'Invalid',
  /**
   * The upgrade domain has not started upgrading yet. The value is 1
   */
  Pending = 'Pending',
  /**
   * The upgrade domain is being upgraded but not complete yet. The value is 2
   */
  InProgress = 'InProgress',
  /**
   * The upgrade domain has completed upgrade. The value is 3
   */
  Completed = 'Completed',
}

/**
 * Defines values for UpgradeState.
 * Possible values include: 'Invalid', 'RollingBackInProgress',
 * 'RollingBackCompleted', 'RollingForwardPending', 'RollingForwardInProgress',
 * 'RollingForwardCompleted', 'Failed'
 * There could be more values for this enum apart from the ones defined here.If
 * you want to set a value that is not from the known values then you can do
 * the following:
 * let param: UpgradeState =
 * <UpgradeState>"someUnknownValueThatWillStillBeValid";
 * @readonly
 * @enum {string}
 */
export enum UpgradeState {
  /**
   * Indicates the upgrade state is invalid. All Service Fabric enumerations
   * have the invalid type. The value is zero.
   */
  Invalid = 'Invalid',
  /**
   * The upgrade is rolling back to the previous version but is not complete
   * yet. The value is 1
   */
  RollingBackInProgress = 'RollingBackInProgress',
  /**
   * The upgrade has finished rolling back. The value is 2
   */
  RollingBackCompleted = 'RollingBackCompleted',
  /**
   * The current upgrade domain has finished upgrading. The overall upgrade is
   * waiting for an explicit move next request in UnmonitoredManual mode or
   * performing health checks in Monitored mode. The value is 3
   */
  RollingForwardPending = 'RollingForwardPending',
  /**
   * The upgrade is rolling forward to the target version but is not complete
   * yet. The value is 4
   */
  RollingForwardInProgress = 'RollingForwardInProgress',
  /**
   * The upgrade has finished rolling forward. The value is 5
   */
  RollingForwardCompleted = 'RollingForwardCompleted',
  /**
   * The upgrade has failed and is unable to execute FailureAction. The value
   * is 6
   */
  Failed = 'Failed',
}

/**
 * Defines values for NodeUpgradePhase.
 * Possible values include: 'Invalid', 'PreUpgradeSafetyCheck', 'Upgrading',
 * 'PostUpgradeSafetyCheck'
 * There could be more values for this enum apart from the ones defined here.If
 * you want to set a value that is not from the known values then you can do
 * the following:
 * let param: NodeUpgradePhase =
 * <NodeUpgradePhase>"someUnknownValueThatWillStillBeValid";
 * @readonly
 * @enum {string}
 */
export enum NodeUpgradePhase {
  /**
   * Indicates the upgrade state is invalid. All Service Fabric enumerations
   * have the invalid type. The value is zero.
   */
  Invalid = 'Invalid',
  /**
   * The upgrade has not started yet due to pending safety checks. The value is
   * 1
   */
  PreUpgradeSafetyCheck = 'PreUpgradeSafetyCheck',
  /**
   * The upgrade is in progress. The value is 2
   */
  Upgrading = 'Upgrading',
  /**
   * The upgrade has completed and post upgrade safety checks are being
   * performed. The value is 3
   */
  PostUpgradeSafetyCheck = 'PostUpgradeSafetyCheck',
}

/**
 * Defines values for FailureReason.
 * Possible values include: 'None', 'Interrupted', 'HealthCheck',
 * 'UpgradeDomainTimeout', 'OverallUpgradeTimeout'
 * There could be more values for this enum apart from the ones defined here.If
 * you want to set a value that is not from the known values then you can do
 * the following:
 * let param: FailureReason =
 * <FailureReason>"someUnknownValueThatWillStillBeValid";
 * @readonly
 * @enum {string}
 */
export enum FailureReason {
  /**
   * Indicates the reason is invalid or unknown. All Service Fabric
   * enumerations have the invalid type. The value is zero.
   */
  None = 'None',
  /**
   * There was an external request to roll back the upgrade. The value is 1
   */
  Interrupted = 'Interrupted',
  /**
   * The upgrade failed due to health policy violations. The value is 2
   */
  HealthCheck = 'HealthCheck',
  /**
   * An upgrade domain took longer than the allowed upgrade domain timeout to
   * process. The value is 3
   */
  UpgradeDomainTimeout = 'UpgradeDomainTimeout',
  /**
   * The overall upgrade took longer than the allowed upgrade timeout to
   * process. The value is 4
   */
  OverallUpgradeTimeout = 'OverallUpgradeTimeout',
}

/**
 * Defines values for DeactivationIntent.
 * Possible values include: 'Pause', 'Restart', 'RemoveData'
 * There could be more values for this enum apart from the ones defined here.If
 * you want to set a value that is not from the known values then you can do
 * the following:
 * let param: DeactivationIntent =
 * <DeactivationIntent>"someUnknownValueThatWillStillBeValid";
 * @readonly
 * @enum {string}
 */
export enum DeactivationIntent {
  /**
   * Indicates that the node should be paused. The value is 1.
   */
  Pause = 'Pause',
  /**
   * Indicates that the intent is for the node to be restarted after a short
   * period of time. The value is 2.
   */
  Restart = 'Restart',
  /**
   * Indicates the intent is for the node to remove data. The value is 3.
   */
  RemoveData = 'RemoveData',
}

/**
 * Defines values for DeployedApplicationStatus.
 * Possible values include: 'Invalid', 'Downloading', 'Activating', 'Active',
 * 'Upgrading', 'Deactivating'
 * There could be more values for this enum apart from the ones defined here.If
 * you want to set a value that is not from the known values then you can do
 * the following:
 * let param: DeployedApplicationStatus =
 * <DeployedApplicationStatus>"someUnknownValueThatWillStillBeValid";
 * @readonly
 * @enum {string}
 */
export enum DeployedApplicationStatus {
  /**
   * Indicates that deployment status is not valid. All Service Fabric
   * enumerations have the invalid type. The value is zero.
   */
  Invalid = 'Invalid',
  /**
   * Indicates that the package is downloading from the ImageStore. The value
   * is 1.
   */
  Downloading = 'Downloading',
  /**
   * Indicates that the package is activating. The value is 2.
   */
  Activating = 'Activating',
  /**
   * Indicates that the package is active. The value is 3.
   */
  Active = 'Active',
  /**
   * Indicates that the package is upgrading. The value is 4.
   */
  Upgrading = 'Upgrading',
  /**
   * Indicates that the package is deactivating. The value is 5.
   */
  Deactivating = 'Deactivating',
}

/**
 * Defines values for ReplicaStatus.
 * Possible values include: 'Invalid', 'InBuild', 'Standby', 'Ready', 'Down',
 * 'Dropped'
 * There could be more values for this enum apart from the ones defined here.If
 * you want to set a value that is not from the known values then you can do
 * the following:
 * let param: ReplicaStatus =
 * <ReplicaStatus>"someUnknownValueThatWillStillBeValid";
 * @readonly
 * @enum {string}
 */
export enum ReplicaStatus {
  /**
   * Indicates the replica status is invalid. All Service Fabric enumerations
   * have the invalid type. The value is zero.
   */
  Invalid = 'Invalid',
  /**
   * The replica is being built. This means that a primary replica is seeding
   * this replica. The value is 1.
   */
  InBuild = 'InBuild',
  /**
   * The replica is in standby. The value is 2.
   */
  Standby = 'Standby',
  /**
   * The replica is ready. The value is 3.
   */
  Ready = 'Ready',
  /**
   * The replica is down. The value is 4.
   */
  Down = 'Down',
  /**
   * Replica is dropped. This means that the replica has been removed from the
   * replica set. If it is persisted, its state has been deleted. The value is
   * 5.
   */
  Dropped = 'Dropped',
}

/**
 * Defines values for ReplicaRole.
 * Possible values include: 'Unknown', 'None', 'Primary', 'IdleSecondary',
 * 'ActiveSecondary'
 * There could be more values for this enum apart from the ones defined here.If
 * you want to set a value that is not from the known values then you can do
 * the following:
 * let param: ReplicaRole =
 * <ReplicaRole>"someUnknownValueThatWillStillBeValid";
 * @readonly
 * @enum {string}
 */
export enum ReplicaRole {
  /**
   * Indicates the initial role that a replica is created in. The value is
   * zero.
   */
  Unknown = 'Unknown',
  /**
   * Specifies that the replica has no responsibility in regard to the replica
   * set. The value is 1
   */
  None = 'None',
  /**
   * Refers to the replica in the set on which all read and write operations
   * are complete in order to enforce strong consistency semantics. Read
   * operations are handled directly by the Primary replica, while write
   * operations must be acknowledged by a quorum of the replicas in the replica
   * set. There can only be one Primary replica in a replica set at a time. The
   * value is 2.
   */
  Primary = 'Primary',
  /**
   * Refers to a replica in the set that receives a state transfer from the
   * Primary replica to prepare for becoming an active Secondary replica. There
   * can be multiple Idle Secondary replicas in a replica set at a time. Idle
   * Secondary replicas do not count as a part of a write quorum. The value is
   * 3.
   */
  IdleSecondary = 'IdleSecondary',
  /**
   * Refers to a replica in the set that receives state updates from the
   * Primary replica, applies them, and sends acknowledgements back. Secondary
   * replicas must participate in the write quorum for a replica set. There can
   * be multiple active Secondary replicas in a replica set at a time. The
   * number of active Secondary replicas is configurable that the reliability
   * subsystem should maintain. The value is 4.
   */
  ActiveSecondary = 'ActiveSecondary',
}

/**
 * Defines values for ReconfigurationPhase.
 * Possible values include: 'Unknown', 'None', 'Phase0', 'Phase1', 'Phase2',
 * 'Phase3', 'Phase4', 'AbortPhaseZero'
 * There could be more values for this enum apart from the ones defined here.If
 * you want to set a value that is not from the known values then you can do
 * the following:
 * let param: ReconfigurationPhase =
 * <ReconfigurationPhase>"someUnknownValueThatWillStillBeValid";
 * @readonly
 * @enum {string}
 */
export enum ReconfigurationPhase {
  /**
   * Indicates the invalid reconfiguration phase.
   */
  Unknown = 'Unknown',
  /**
   * Specifies that there is no reconfiguration in progress.
   */
  None = 'None',
  /**
   * Refers to the phase where the reconfiguration is transferring data from
   * the previous primary to the new primary.
   */
  Phase0 = 'Phase0',
  /**
   * Refers to the phase where the reconfiguration is querying the replica set
   * for the progress.
   */
  Phase1 = 'Phase1',
  /**
   * Refers to the phase where the reconfiguration is ensuring that data from
   * the current primary is present in a majority of the replica set.
   */
  Phase2 = 'Phase2',
  /**
   * This phase is for internal use only.
   */
  Phase3 = 'Phase3',
  /**
   * This phase is for internal use only.
   */
  Phase4 = 'Phase4',
  /**
   * This phase is for internal use only.
   */
  AbortPhaseZero = 'AbortPhaseZero',
}

/**
 * Defines values for ReconfigurationType.
 * Possible values include: 'Unknown', 'SwapPrimary', 'Failover', 'Other'
 * There could be more values for this enum apart from the ones defined here.If
 * you want to set a value that is not from the known values then you can do
 * the following:
 * let param: ReconfigurationType =
 * <ReconfigurationType>"someUnknownValueThatWillStillBeValid";
 * @readonly
 * @enum {string}
 */
export enum ReconfigurationType {
  /**
   * Indicates the invalid reconfiguration type.
   */
  Unknown = 'Unknown',
  /**
   * Specifies that the primary replica is being swapped with a different
   * replica.
   */
  SwapPrimary = 'SwapPrimary',
  /**
   * Reconfiguration triggered in response to a primary going down. This could
   * be due to many reasons such as primary replica crashing etc.
   */
  Failover = 'Failover',
  /**
   * Reconfigurations where the primary replica is not changing.
   */
  Other = 'Other',
}

/**
 * Defines values for EntityKind.
 * Possible values include: 'Invalid', 'Node', 'Partition', 'Service',
 * 'Application', 'Replica', 'DeployedApplication', 'DeployedServicePackage',
 * 'Cluster'
 * There could be more values for this enum apart from the ones defined here.If
 * you want to set a value that is not from the known values then you can do
 * the following:
 * let param: EntityKind = <EntityKind>"someUnknownValueThatWillStillBeValid";
 * @readonly
 * @enum {string}
 */
export enum EntityKind {
  /**
   * Indicates an invalid entity kind. All Service Fabric enumerations have the
   * invalid type. The value is zero.
   */
  Invalid = 'Invalid',
  /**
   * Indicates the entity is a Service Fabric node. The value is 1.
   */
  Node = 'Node',
  /**
   * Indicates the entity is a Service Fabric partition. The value is 2.
   */
  Partition = 'Partition',
  /**
   * Indicates the entity is a Service Fabric service. The value is 3.
   */
  Service = 'Service',
  /**
   * Indicates the entity is a Service Fabric application. The value is 4.
   */
  Application = 'Application',
  /**
   * Indicates the entity is a Service Fabric replica. The value is 5.
   */
  Replica = 'Replica',
  /**
   * Indicates the entity is a Service Fabric deployed application. The value
   * is 6.
   */
  DeployedApplication = 'DeployedApplication',
  /**
   * Indicates the entity is a Service Fabric deployed service package. The
   * value is 7.
   */
  DeployedServicePackage = 'DeployedServicePackage',
  /**
   * Indicates the entity is a Service Fabric cluster. The value is 8.
   */
  Cluster = 'Cluster',
}

/**
 * Defines values for FabricErrorCodes.
 * Possible values include: 'FABRIC_E_INVALID_PARTITION_KEY',
 * 'FABRIC_E_IMAGEBUILDER_VALIDATION_ERROR', 'FABRIC_E_INVALID_ADDRESS',
 * 'FABRIC_E_APPLICATION_NOT_UPGRADING',
 * 'FABRIC_E_APPLICATION_UPGRADE_VALIDATION_ERROR',
 * 'FABRIC_E_FABRIC_NOT_UPGRADING', 'FABRIC_E_FABRIC_UPGRADE_VALIDATION_ERROR',
 * 'FABRIC_E_INVALID_CONFIGURATION', 'FABRIC_E_INVALID_NAME_URI',
 * 'FABRIC_E_PATH_TOO_LONG', 'FABRIC_E_KEY_TOO_LARGE',
 * 'FABRIC_E_SERVICE_AFFINITY_CHAIN_NOT_SUPPORTED',
 * 'FABRIC_E_INVALID_ATOMIC_GROUP', 'FABRIC_E_VALUE_EMPTY',
 * 'FABRIC_E_NODE_NOT_FOUND', 'FABRIC_E_APPLICATION_TYPE_NOT_FOUND',
 * 'FABRIC_E_APPLICATION_NOT_FOUND', 'FABRIC_E_SERVICE_TYPE_NOT_FOUND',
 * 'FABRIC_E_SERVICE_DOES_NOT_EXIST',
 * 'FABRIC_E_SERVICE_TYPE_TEMPLATE_NOT_FOUND',
 * 'FABRIC_E_CONFIGURATION_SECTION_NOT_FOUND', 'FABRIC_E_PARTITION_NOT_FOUND',
 * 'FABRIC_E_REPLICA_DOES_NOT_EXIST', 'FABRIC_E_SERVICE_GROUP_DOES_NOT_EXIST',
 * 'FABRIC_E_CONFIGURATION_PARAMETER_NOT_FOUND',
 * 'FABRIC_E_DIRECTORY_NOT_FOUND', 'FABRIC_E_FABRIC_VERSION_NOT_FOUND',
 * 'FABRIC_E_FILE_NOT_FOUND', 'FABRIC_E_NAME_DOES_NOT_EXIST',
 * 'FABRIC_E_PROPERTY_DOES_NOT_EXIST', 'FABRIC_E_ENUMERATION_COMPLETED',
 * 'FABRIC_E_SERVICE_MANIFEST_NOT_FOUND', 'FABRIC_E_KEY_NOT_FOUND',
 * 'FABRIC_E_HEALTH_ENTITY_NOT_FOUND',
 * 'FABRIC_E_APPLICATION_TYPE_ALREADY_EXISTS',
 * 'FABRIC_E_APPLICATION_ALREADY_EXISTS',
 * 'FABRIC_E_APPLICATION_ALREADY_IN_TARGET_VERSION',
 * 'FABRIC_E_APPLICATION_TYPE_PROVISION_IN_PROGRESS',
 * 'FABRIC_E_APPLICATION_UPGRADE_IN_PROGRESS',
 * 'FABRIC_E_SERVICE_ALREADY_EXISTS', 'FABRIC_E_SERVICE_GROUP_ALREADY_EXISTS',
 * 'FABRIC_E_APPLICATION_TYPE_IN_USE',
 * 'FABRIC_E_FABRIC_ALREADY_IN_TARGET_VERSION',
 * 'FABRIC_E_FABRIC_VERSION_ALREADY_EXISTS', 'FABRIC_E_FABRIC_VERSION_IN_USE',
 * 'FABRIC_E_FABRIC_UPGRADE_IN_PROGRESS', 'FABRIC_E_NAME_ALREADY_EXISTS',
 * 'FABRIC_E_NAME_NOT_EMPTY', 'FABRIC_E_PROPERTY_CHECK_FAILED',
 * 'FABRIC_E_SERVICE_METADATA_MISMATCH', 'FABRIC_E_SERVICE_TYPE_MISMATCH',
 * 'FABRIC_E_HEALTH_STALE_REPORT', 'FABRIC_E_SEQUENCE_NUMBER_CHECK_FAILED',
 * 'FABRIC_E_NODE_HAS_NOT_STOPPED_YET', 'FABRIC_E_INSTANCE_ID_MISMATCH',
 * 'FABRIC_E_VALUE_TOO_LARGE', 'FABRIC_E_NO_WRITE_QUORUM',
 * 'FABRIC_E_NOT_PRIMARY', 'FABRIC_E_NOT_READY',
 * 'FABRIC_E_RECONFIGURATION_PENDING', 'FABRIC_E_SERVICE_OFFLINE', 'E_ABORT',
 * 'FABRIC_E_COMMUNICATION_ERROR', 'FABRIC_E_OPERATION_NOT_COMPLETE',
 * 'FABRIC_E_TIMEOUT', 'FABRIC_E_NODE_IS_UP', 'E_FAIL',
 * 'FABRIC_E_BACKUP_IS_ENABLED',
 * 'FABRIC_E_RESTORE_SOURCE_TARGET_PARTITION_MISMATCH',
 * 'FABRIC_E_INVALID_FOR_STATELESS_SERVICES', 'FABRIC_E_BACKUP_NOT_ENABLED',
 * 'FABRIC_E_BACKUP_POLICY_NOT_EXISTING',
 * 'FABRIC_E_FAULT_ANALYSIS_SERVICE_NOT_EXISTING',
 * 'FABRIC_E_BACKUP_IN_PROGRESS', 'FABRIC_E_RESTORE_IN_PROGRESS',
 * 'FABRIC_E_BACKUP_POLICY_ALREADY_EXISTING',
 * 'FABRIC_E_INVALID_SERVICE_SCALING_POLICY', 'E_INVALIDARG',
 * 'FABRIC_E_SINGLE_INSTANCE_APPLICATION_ALREADY_EXISTS',
 * 'FABRIC_E_SINGLE_INSTANCE_APPLICATION_NOT_FOUND',
 * 'FABRIC_E_VOLUME_ALREADY_EXISTS', 'FABRIC_E_VOLUME_NOT_FOUND',
 * 'SerializationError'
 * There could be more values for this enum apart from the ones defined here.If
 * you want to set a value that is not from the known values then you can do
 * the following:
 * let param: FabricErrorCodes =
 * <FabricErrorCodes>"someUnknownValueThatWillStillBeValid";
 * @readonly
 * @enum {string}
 */
export enum FabricErrorCodes {
  FABRICEINVALIDPARTITIONKEY = 'FABRIC_E_INVALID_PARTITION_KEY',
  FABRICEIMAGEBUILDERVALIDATIONERROR = 'FABRIC_E_IMAGEBUILDER_VALIDATION_ERROR',
  FABRICEINVALIDADDRESS = 'FABRIC_E_INVALID_ADDRESS',
  FABRICEAPPLICATIONNOTUPGRADING = 'FABRIC_E_APPLICATION_NOT_UPGRADING',
  FABRICEAPPLICATIONUPGRADEVALIDATIONERROR = 'FABRIC_E_APPLICATION_UPGRADE_VALIDATION_ERROR',
  FABRICEFABRICNOTUPGRADING = 'FABRIC_E_FABRIC_NOT_UPGRADING',
  FABRICEFABRICUPGRADEVALIDATIONERROR = 'FABRIC_E_FABRIC_UPGRADE_VALIDATION_ERROR',
  FABRICEINVALIDCONFIGURATION = 'FABRIC_E_INVALID_CONFIGURATION',
  FABRICEINVALIDNAMEURI = 'FABRIC_E_INVALID_NAME_URI',
  FABRICEPATHTOOLONG = 'FABRIC_E_PATH_TOO_LONG',
  FABRICEKEYTOOLARGE = 'FABRIC_E_KEY_TOO_LARGE',
  FABRICESERVICEAFFINITYCHAINNOTSUPPORTED = 'FABRIC_E_SERVICE_AFFINITY_CHAIN_NOT_SUPPORTED',
  FABRICEINVALIDATOMICGROUP = 'FABRIC_E_INVALID_ATOMIC_GROUP',
  FABRICEVALUEEMPTY = 'FABRIC_E_VALUE_EMPTY',
  FABRICENODENOTFOUND = 'FABRIC_E_NODE_NOT_FOUND',
  FABRICEAPPLICATIONTYPENOTFOUND = 'FABRIC_E_APPLICATION_TYPE_NOT_FOUND',
  FABRICEAPPLICATIONNOTFOUND = 'FABRIC_E_APPLICATION_NOT_FOUND',
  FABRICESERVICETYPENOTFOUND = 'FABRIC_E_SERVICE_TYPE_NOT_FOUND',
  FABRICESERVICEDOESNOTEXIST = 'FABRIC_E_SERVICE_DOES_NOT_EXIST',
  FABRICESERVICETYPETEMPLATENOTFOUND = 'FABRIC_E_SERVICE_TYPE_TEMPLATE_NOT_FOUND',
  FABRICECONFIGURATIONSECTIONNOTFOUND = 'FABRIC_E_CONFIGURATION_SECTION_NOT_FOUND',
  FABRICEPARTITIONNOTFOUND = 'FABRIC_E_PARTITION_NOT_FOUND',
  FABRICEREPLICADOESNOTEXIST = 'FABRIC_E_REPLICA_DOES_NOT_EXIST',
  FABRICESERVICEGROUPDOESNOTEXIST = 'FABRIC_E_SERVICE_GROUP_DOES_NOT_EXIST',
  FABRICECONFIGURATIONPARAMETERNOTFOUND = 'FABRIC_E_CONFIGURATION_PARAMETER_NOT_FOUND',
  FABRICEDIRECTORYNOTFOUND = 'FABRIC_E_DIRECTORY_NOT_FOUND',
  FABRICEFABRICVERSIONNOTFOUND = 'FABRIC_E_FABRIC_VERSION_NOT_FOUND',
  FABRICEFILENOTFOUND = 'FABRIC_E_FILE_NOT_FOUND',
  FABRICENAMEDOESNOTEXIST = 'FABRIC_E_NAME_DOES_NOT_EXIST',
  FABRICEPROPERTYDOESNOTEXIST = 'FABRIC_E_PROPERTY_DOES_NOT_EXIST',
  FABRICEENUMERATIONCOMPLETED = 'FABRIC_E_ENUMERATION_COMPLETED',
  FABRICESERVICEMANIFESTNOTFOUND = 'FABRIC_E_SERVICE_MANIFEST_NOT_FOUND',
  FABRICEKEYNOTFOUND = 'FABRIC_E_KEY_NOT_FOUND',
  FABRICEHEALTHENTITYNOTFOUND = 'FABRIC_E_HEALTH_ENTITY_NOT_FOUND',
  FABRICEAPPLICATIONTYPEALREADYEXISTS = 'FABRIC_E_APPLICATION_TYPE_ALREADY_EXISTS',
  FABRICEAPPLICATIONALREADYEXISTS = 'FABRIC_E_APPLICATION_ALREADY_EXISTS',
  FABRICEAPPLICATIONALREADYINTARGETVERSION = 'FABRIC_E_APPLICATION_ALREADY_IN_TARGET_VERSION',
  FABRICEAPPLICATIONTYPEPROVISIONINPROGRESS = 'FABRIC_E_APPLICATION_TYPE_PROVISION_IN_PROGRESS',
  FABRICEAPPLICATIONUPGRADEINPROGRESS = 'FABRIC_E_APPLICATION_UPGRADE_IN_PROGRESS',
  FABRICESERVICEALREADYEXISTS = 'FABRIC_E_SERVICE_ALREADY_EXISTS',
  FABRICESERVICEGROUPALREADYEXISTS = 'FABRIC_E_SERVICE_GROUP_ALREADY_EXISTS',
  FABRICEAPPLICATIONTYPEINUSE = 'FABRIC_E_APPLICATION_TYPE_IN_USE',
  FABRICEFABRICALREADYINTARGETVERSION = 'FABRIC_E_FABRIC_ALREADY_IN_TARGET_VERSION',
  FABRICEFABRICVERSIONALREADYEXISTS = 'FABRIC_E_FABRIC_VERSION_ALREADY_EXISTS',
  FABRICEFABRICVERSIONINUSE = 'FABRIC_E_FABRIC_VERSION_IN_USE',
  FABRICEFABRICUPGRADEINPROGRESS = 'FABRIC_E_FABRIC_UPGRADE_IN_PROGRESS',
  FABRICENAMEALREADYEXISTS = 'FABRIC_E_NAME_ALREADY_EXISTS',
  FABRICENAMENOTEMPTY = 'FABRIC_E_NAME_NOT_EMPTY',
  FABRICEPROPERTYCHECKFAILED = 'FABRIC_E_PROPERTY_CHECK_FAILED',
  FABRICESERVICEMETADATAMISMATCH = 'FABRIC_E_SERVICE_METADATA_MISMATCH',
  FABRICESERVICETYPEMISMATCH = 'FABRIC_E_SERVICE_TYPE_MISMATCH',
  FABRICEHEALTHSTALEREPORT = 'FABRIC_E_HEALTH_STALE_REPORT',
  FABRICESEQUENCENUMBERCHECKFAILED = 'FABRIC_E_SEQUENCE_NUMBER_CHECK_FAILED',
  FABRICENODEHASNOTSTOPPEDYET = 'FABRIC_E_NODE_HAS_NOT_STOPPED_YET',
  FABRICEINSTANCEIDMISMATCH = 'FABRIC_E_INSTANCE_ID_MISMATCH',
  FABRICEVALUETOOLARGE = 'FABRIC_E_VALUE_TOO_LARGE',
  FABRICENOWRITEQUORUM = 'FABRIC_E_NO_WRITE_QUORUM',
  FABRICENOTPRIMARY = 'FABRIC_E_NOT_PRIMARY',
  FABRICENOTREADY = 'FABRIC_E_NOT_READY',
  FABRICERECONFIGURATIONPENDING = 'FABRIC_E_RECONFIGURATION_PENDING',
  FABRICESERVICEOFFLINE = 'FABRIC_E_SERVICE_OFFLINE',
  EABORT = 'E_ABORT',
  FABRICECOMMUNICATIONERROR = 'FABRIC_E_COMMUNICATION_ERROR',
  FABRICEOPERATIONNOTCOMPLETE = 'FABRIC_E_OPERATION_NOT_COMPLETE',
  FABRICETIMEOUT = 'FABRIC_E_TIMEOUT',
  FABRICENODEISUP = 'FABRIC_E_NODE_IS_UP',
  EFAIL = 'E_FAIL',
  FABRICEBACKUPISENABLED = 'FABRIC_E_BACKUP_IS_ENABLED',
  FABRICERESTORESOURCETARGETPARTITIONMISMATCH = 'FABRIC_E_RESTORE_SOURCE_TARGET_PARTITION_MISMATCH',
  FABRICEINVALIDFORSTATELESSSERVICES = 'FABRIC_E_INVALID_FOR_STATELESS_SERVICES',
  FABRICEBACKUPNOTENABLED = 'FABRIC_E_BACKUP_NOT_ENABLED',
  FABRICEBACKUPPOLICYNOTEXISTING = 'FABRIC_E_BACKUP_POLICY_NOT_EXISTING',
  FABRICEFAULTANALYSISSERVICENOTEXISTING = 'FABRIC_E_FAULT_ANALYSIS_SERVICE_NOT_EXISTING',
  FABRICEBACKUPINPROGRESS = 'FABRIC_E_BACKUP_IN_PROGRESS',
  FABRICERESTOREINPROGRESS = 'FABRIC_E_RESTORE_IN_PROGRESS',
  FABRICEBACKUPPOLICYALREADYEXISTING = 'FABRIC_E_BACKUP_POLICY_ALREADY_EXISTING',
  FABRICEINVALIDSERVICESCALINGPOLICY = 'FABRIC_E_INVALID_SERVICE_SCALING_POLICY',
  EINVALIDARG = 'E_INVALIDARG',
  FABRICESINGLEINSTANCEAPPLICATIONALREADYEXISTS = 'FABRIC_E_SINGLE_INSTANCE_APPLICATION_ALREADY_EXISTS',
  FABRICESINGLEINSTANCEAPPLICATIONNOTFOUND = 'FABRIC_E_SINGLE_INSTANCE_APPLICATION_NOT_FOUND',
  FABRICEVOLUMEALREADYEXISTS = 'FABRIC_E_VOLUME_ALREADY_EXISTS',
  FABRICEVOLUMENOTFOUND = 'FABRIC_E_VOLUME_NOT_FOUND',
  SerializationError = 'SerializationError',
}

/**
 * Defines values for FabricEventKind.
 * Possible values include: 'ClusterEvent', 'ContainerInstanceEvent',
 * 'NodeEvent', 'ApplicationEvent', 'ServiceEvent', 'PartitionEvent',
 * 'ReplicaEvent', 'PartitionAnalysisEvent', 'ApplicationCreated',
 * 'ApplicationDeleted', 'ApplicationHealthReportCreated',
 * 'ApplicationHealthReportExpired', 'ApplicationUpgradeComplete',
 * 'ApplicationUpgradeDomainComplete', 'ApplicationUpgradeRollbackComplete',
 * 'ApplicationUpgradeRollbackStart', 'ApplicationUpgradeStart',
 * 'DeployedApplicationHealthReportCreated',
 * 'DeployedApplicationHealthReportExpired', 'ProcessDeactivated',
 * 'ContainerDeactivated', 'NodeAborted', 'NodeAborting', 'NodeAdded',
 * 'NodeClose', 'NodeClosing', 'NodeDeactivateComplete', 'NodeDeactivateStart',
 * 'NodeDown', 'NodeHealthReportCreated', 'NodeHealthReportExpired',
 * 'NodeOpenedSuccess', 'NodeOpenFailed', 'NodeOpening', 'NodeRemoved',
 * 'NodeUp', 'PartitionHealthReportCreated', 'PartitionHealthReportExpired',
 * 'PartitionReconfigurationCompleted', 'PartitionPrimaryMoveAnalysis',
 * 'ServiceCreated', 'ServiceDeleted', 'ServiceHealthReportCreated',
 * 'ServiceHealthReportExpired', 'DeployedServiceHealthReportCreated',
 * 'DeployedServiceHealthReportExpired', 'StatefulReplicaHealthReportCreated',
 * 'StatefulReplicaHealthReportExpired', 'StatelessReplicaHealthReportCreated',
 * 'StatelessReplicaHealthReportExpired', 'ClusterHealthReportCreated',
 * 'ClusterHealthReportExpired', 'ClusterUpgradeComplete',
 * 'ClusterUpgradeDomainComplete', 'ClusterUpgradeRollbackComplete',
 * 'ClusterUpgradeRollbackStart', 'ClusterUpgradeStart', 'ChaosStopped',
 * 'ChaosStarted', 'ChaosRestartNodeFaultCompleted',
 * 'ChaosRestartCodePackageFaultScheduled',
 * 'ChaosRestartCodePackageFaultCompleted', 'ChaosRemoveReplicaFaultScheduled',
 * 'ChaosRemoveReplicaFaultCompleted', 'ChaosMoveSecondaryFaultScheduled',
 * 'ChaosMovePrimaryFaultScheduled', 'ChaosRestartReplicaFaultScheduled',
 * 'ChaosRestartNodeFaultScheduled'
 * There could be more values for this enum apart from the ones defined here.If
 * you want to set a value that is not from the known values then you can do
 * the following:
 * let param: FabricEventKind =
 * <FabricEventKind>"someUnknownValueThatWillStillBeValid";
 * @readonly
 * @enum {string}
 */
export enum FabricEventKind {
  ClusterEvent = 'ClusterEvent',
  ContainerInstanceEvent = 'ContainerInstanceEvent',
  NodeEvent = 'NodeEvent',
  ApplicationEvent = 'ApplicationEvent',
  ServiceEvent = 'ServiceEvent',
  PartitionEvent = 'PartitionEvent',
  ReplicaEvent = 'ReplicaEvent',
  PartitionAnalysisEvent = 'PartitionAnalysisEvent',
  ApplicationCreated = 'ApplicationCreated',
  ApplicationDeleted = 'ApplicationDeleted',
  ApplicationHealthReportCreated = 'ApplicationHealthReportCreated',
  ApplicationHealthReportExpired = 'ApplicationHealthReportExpired',
  ApplicationUpgradeComplete = 'ApplicationUpgradeComplete',
  ApplicationUpgradeDomainComplete = 'ApplicationUpgradeDomainComplete',
  ApplicationUpgradeRollbackComplete = 'ApplicationUpgradeRollbackComplete',
  ApplicationUpgradeRollbackStart = 'ApplicationUpgradeRollbackStart',
  ApplicationUpgradeStart = 'ApplicationUpgradeStart',
  DeployedApplicationHealthReportCreated = 'DeployedApplicationHealthReportCreated',
  DeployedApplicationHealthReportExpired = 'DeployedApplicationHealthReportExpired',
  ProcessDeactivated = 'ProcessDeactivated',
  ContainerDeactivated = 'ContainerDeactivated',
  NodeAborted = 'NodeAborted',
  NodeAborting = 'NodeAborting',
  NodeAdded = 'NodeAdded',
  NodeClose = 'NodeClose',
  NodeClosing = 'NodeClosing',
  NodeDeactivateComplete = 'NodeDeactivateComplete',
  NodeDeactivateStart = 'NodeDeactivateStart',
  NodeDown = 'NodeDown',
  NodeHealthReportCreated = 'NodeHealthReportCreated',
  NodeHealthReportExpired = 'NodeHealthReportExpired',
  NodeOpenedSuccess = 'NodeOpenedSuccess',
  NodeOpenFailed = 'NodeOpenFailed',
  NodeOpening = 'NodeOpening',
  NodeRemoved = 'NodeRemoved',
  NodeUp = 'NodeUp',
  PartitionHealthReportCreated = 'PartitionHealthReportCreated',
  PartitionHealthReportExpired = 'PartitionHealthReportExpired',
  PartitionReconfigurationCompleted = 'PartitionReconfigurationCompleted',
  PartitionPrimaryMoveAnalysis = 'PartitionPrimaryMoveAnalysis',
  ServiceCreated = 'ServiceCreated',
  ServiceDeleted = 'ServiceDeleted',
  ServiceHealthReportCreated = 'ServiceHealthReportCreated',
  ServiceHealthReportExpired = 'ServiceHealthReportExpired',
  DeployedServiceHealthReportCreated = 'DeployedServiceHealthReportCreated',
  DeployedServiceHealthReportExpired = 'DeployedServiceHealthReportExpired',
  StatefulReplicaHealthReportCreated = 'StatefulReplicaHealthReportCreated',
  StatefulReplicaHealthReportExpired = 'StatefulReplicaHealthReportExpired',
  StatelessReplicaHealthReportCreated = 'StatelessReplicaHealthReportCreated',
  StatelessReplicaHealthReportExpired = 'StatelessReplicaHealthReportExpired',
  ClusterHealthReportCreated = 'ClusterHealthReportCreated',
  ClusterHealthReportExpired = 'ClusterHealthReportExpired',
  ClusterUpgradeComplete = 'ClusterUpgradeComplete',
  ClusterUpgradeDomainComplete = 'ClusterUpgradeDomainComplete',
  ClusterUpgradeRollbackComplete = 'ClusterUpgradeRollbackComplete',
  ClusterUpgradeRollbackStart = 'ClusterUpgradeRollbackStart',
  ClusterUpgradeStart = 'ClusterUpgradeStart',
  ChaosStopped = 'ChaosStopped',
  ChaosStarted = 'ChaosStarted',
  ChaosRestartNodeFaultCompleted = 'ChaosRestartNodeFaultCompleted',
  ChaosRestartCodePackageFaultScheduled = 'ChaosRestartCodePackageFaultScheduled',
  ChaosRestartCodePackageFaultCompleted = 'ChaosRestartCodePackageFaultCompleted',
  ChaosRemoveReplicaFaultScheduled = 'ChaosRemoveReplicaFaultScheduled',
  ChaosRemoveReplicaFaultCompleted = 'ChaosRemoveReplicaFaultCompleted',
  ChaosMoveSecondaryFaultScheduled = 'ChaosMoveSecondaryFaultScheduled',
  ChaosMovePrimaryFaultScheduled = 'ChaosMovePrimaryFaultScheduled',
  ChaosRestartReplicaFaultScheduled = 'ChaosRestartReplicaFaultScheduled',
  ChaosRestartNodeFaultScheduled = 'ChaosRestartNodeFaultScheduled',
}

/**
 * Defines values for HealthEvaluationKind.
 * Possible values include: 'Invalid', 'Event', 'Replicas', 'Partitions',
 * 'DeployedServicePackages', 'DeployedApplications', 'Services', 'Nodes',
 * 'Applications', 'SystemApplication', 'UpgradeDomainDeployedApplications',
 * 'UpgradeDomainNodes', 'Replica', 'Partition', 'DeployedServicePackage',
 * 'DeployedApplication', 'Service', 'Node', 'Application', 'DeltaNodesCheck',
 * 'UpgradeDomainDeltaNodesCheck', 'ApplicationTypeApplications'
 * There could be more values for this enum apart from the ones defined here.If
 * you want to set a value that is not from the known values then you can do
 * the following:
 * let param: HealthEvaluationKind =
 * <HealthEvaluationKind>"someUnknownValueThatWillStillBeValid";
 * @readonly
 * @enum {string}
 */
export enum HealthEvaluationKind {
  /**
   * Indicates that the health evaluation is invalid. The value is zero.
   */
  Invalid = 'Invalid',
  /**
   * Indicates that the health evaluation is for a health event. The value is
   * 1.
   */
  Event = 'Event',
  /**
   * Indicates that the health evaluation is for the replicas of a partition.
   * The value is 2.
   */
  Replicas = 'Replicas',
  /**
   * Indicates that the health evaluation is for the partitions of a service.
   * The value is 3.
   */
  Partitions = 'Partitions',
  /**
   * Indicates that the health evaluation is for the deployed service packages
   * of a deployed application. The value is 4.
   */
  DeployedServicePackages = 'DeployedServicePackages',
  /**
   * Indicates that the health evaluation is for the deployed applications of
   * an application. The value is 5.
   */
  DeployedApplications = 'DeployedApplications',
  /**
   * Indicates that the health evaluation is for services of an application.
   * The value is 6.
   */
  Services = 'Services',
  /**
   * Indicates that the health evaluation is for the cluster nodes. The value
   * is 7.
   */
  Nodes = 'Nodes',
  /**
   * Indicates that the health evaluation is for the cluster applications. The
   * value is 8.
   */
  Applications = 'Applications',
  /**
   * Indicates that the health evaluation is for the system application. The
   * value is 9.
   */
  SystemApplication = 'SystemApplication',
  /**
   * Indicates that the health evaluation is for the deployed applications of
   * an application in an upgrade domain. The value is 10.
   */
  UpgradeDomainDeployedApplications = 'UpgradeDomainDeployedApplications',
  /**
   * Indicates that the health evaluation is for the cluster nodes in an
   * upgrade domain. The value is 11.
   */
  UpgradeDomainNodes = 'UpgradeDomainNodes',
  /**
   * Indicates that the health evaluation is for a replica. The value is 13.
   */
  Replica = 'Replica',
  /**
   * Indicates that the health evaluation is for a partition. The value is 14.
   */
  Partition = 'Partition',
  /**
   * Indicates that the health evaluation is for a deployed service package.
   * The value is 16.
   */
  DeployedServicePackage = 'DeployedServicePackage',
  /**
   * Indicates that the health evaluation is for a deployed application. The
   * value is 17.
   */
  DeployedApplication = 'DeployedApplication',
  /**
   * Indicates that the health evaluation is for a service. The value is 15.
   */
  Service = 'Service',
  /**
   * Indicates that the health evaluation is for a node. The value is 12.
   */
  Node = 'Node',
  /**
   * Indicates that the health evaluation is for an application. The value is
   * 18.
   */
  Application = 'Application',
  /**
   * Indicates that the health evaluation is for the delta of unhealthy cluster
   * nodes. The value is 19.
   */
  DeltaNodesCheck = 'DeltaNodesCheck',
  /**
   * Indicates that the health evaluation is for the delta of unhealthy upgrade
   * domain cluster nodes. The value is 20.
   */
  UpgradeDomainDeltaNodesCheck = 'UpgradeDomainDeltaNodesCheck',
  /**
   * – Indicates that the health evaluation is for applications of an
   * application type. The value is 21.
   */
  ApplicationTypeApplications = 'ApplicationTypeApplications',
}

/**
 * Defines values for NodeDeactivationIntent.
 * Possible values include: 'Invalid', 'Pause', 'Restart', 'RemoveData',
 * 'RemoveNode'
 * There could be more values for this enum apart from the ones defined here.If
 * you want to set a value that is not from the known values then you can do
 * the following:
 * let param: NodeDeactivationIntent =
 * <NodeDeactivationIntent>"someUnknownValueThatWillStillBeValid";
 * @readonly
 * @enum {string}
 */
export enum NodeDeactivationIntent {
  /**
   * Indicates the node deactivation intent is invalid. All Service Fabric
   * enumerations have the invalid type. The value is zero. This value is not
   * used.
   */
  Invalid = 'Invalid',
  /**
   * Indicates that the node should be paused. The value is 1.
   */
  Pause = 'Pause',
  /**
   * Indicates that the intent is for the node to be restarted after a short
   * period of time. Service Fabric does not restart the node, this action is
   * done outside of Service Fabric. The value is 2.
   */
  Restart = 'Restart',
  /**
   * Indicates that the intent is to reimage the node. Service Fabric does not
   * reimage the node, this action is done outside of Service Fabric. The value
   * is 3.
   */
  RemoveData = 'RemoveData',
  /**
   * Indicates that the node is being decommissioned and is not expected to
   * return. Service Fabric does not decommission the node, this action is done
   * outside of Service Fabric. The value is 4.
   */
  RemoveNode = 'RemoveNode',
}

/**
 * Defines values for NodeDeactivationStatus.
 * Possible values include: 'None', 'SafetyCheckInProgress',
 * 'SafetyCheckComplete', 'Completed'
 * There could be more values for this enum apart from the ones defined here.If
 * you want to set a value that is not from the known values then you can do
 * the following:
 * let param: NodeDeactivationStatus =
 * <NodeDeactivationStatus>"someUnknownValueThatWillStillBeValid";
 * @readonly
 * @enum {string}
 */
export enum NodeDeactivationStatus {
  /**
   * No status is associated with the task. The value is zero.
   */
  None = 'None',
  /**
   * When a node is deactivated Service Fabric performs checks to ensure that
   * the operation is safe to proceed to ensure availability of the service and
   * reliability of the state. This value indicates that one or more safety
   * checks are in progress. The value is 1.
   */
  SafetyCheckInProgress = 'SafetyCheckInProgress',
  /**
   * When a node is deactivated Service Fabric performs checks to ensure that
   * the operation is safe to proceed to ensure availability of the service and
   * reliability of the state. This value indicates that all safety checks have
   * been completed. The value is 2.
   */
  SafetyCheckComplete = 'SafetyCheckComplete',
  /**
   * The task is completed. The value is 3.
   */
  Completed = 'Completed',
}

/**
 * Defines values for NodeDeactivationTaskType.
 * Possible values include: 'Invalid', 'Infrastructure', 'Repair', 'Client'
 * There could be more values for this enum apart from the ones defined here.If
 * you want to set a value that is not from the known values then you can do
 * the following:
 * let param: NodeDeactivationTaskType =
 * <NodeDeactivationTaskType>"someUnknownValueThatWillStillBeValid";
 * @readonly
 * @enum {string}
 */
export enum NodeDeactivationTaskType {
  /**
   * Indicates the node deactivation task type is invalid. All Service Fabric
   * enumerations have the invalid type. The value is zero. This value is not
   * used.
   */
  Invalid = 'Invalid',
  /**
   * Specifies the task created by Infrastructure hosting the nodes. The value
   * is 1.
   */
  Infrastructure = 'Infrastructure',
  /**
   * Specifies the task that was created by the Repair Manager service. The
   * value is 2.
   */
  Repair = 'Repair',
  /**
   * Specifies that the task was created by using the public API. The value is
   * 3.
   */
  Client = 'Client',
}

/**
 * Defines values for NodeStatus.
 * Possible values include: 'Invalid', 'Up', 'Down', 'Enabling', 'Disabling',
 * 'Disabled', 'Unknown', 'Removed'
 * There could be more values for this enum apart from the ones defined here.If
 * you want to set a value that is not from the known values then you can do
 * the following:
 * let param: NodeStatus = <NodeStatus>"someUnknownValueThatWillStillBeValid";
 * @readonly
 * @enum {string}
 */
export enum NodeStatus {
  /**
   * Indicates the node status is invalid. All Service Fabric enumerations have
   * the invalid type. The value is zero.
   */
  Invalid = 'Invalid',
  /**
   * Indicates the node is up. The value is 1.
   */
  Up = 'Up',
  /**
   * Indicates the node is down. The value is 2.
   */
  Down = 'Down',
  /**
   * Indicates the node is in process of being enabled. The value is 3.
   */
  Enabling = 'Enabling',
  /**
   * Indicates the node is in the process of being disabled. The value is 4.
   */
  Disabling = 'Disabling',
  /**
   * Indicates the node is disabled. The value is 5.
   */
  Disabled = 'Disabled',
  /**
   * Indicates the node is unknown. A node would be in Unknown state if Service
   * Fabric does not have authoritative information about that node. This can
   * happen if the system learns about a node at runtime.The value is 6.
   */
  Unknown = 'Unknown',
  /**
   * Indicates the node is removed. A node would be in Removed state if
   * NodeStateRemoved API has been called for this node. In other words,
   * Service Fabric has been informed that the persisted state on the node has
   * been permanently lost. The value is 7.
   */
  Removed = 'Removed',
}

/**
 * Defines values for ServicePartitionStatus.
 * Possible values include: 'Invalid', 'Ready', 'NotReady', 'InQuorumLoss',
 * 'Reconfiguring', 'Deleting'
 * There could be more values for this enum apart from the ones defined here.If
 * you want to set a value that is not from the known values then you can do
 * the following:
 * let param: ServicePartitionStatus =
 * <ServicePartitionStatus>"someUnknownValueThatWillStillBeValid";
 * @readonly
 * @enum {string}
 */
export enum ServicePartitionStatus {
  /**
   * Indicates the partition status is invalid. All Service Fabric enumerations
   * have the invalid type. The value is zero.
   */
  Invalid = 'Invalid',
  /**
   * Indicates that the partition is ready. This means that for a stateless
   * service partition there is at least one instance that is up and for a
   * stateful service partition the number of ready replicas is greater than or
   * equal to the MinReplicaSetSize. The value is 1.
   */
  Ready = 'Ready',
  /**
   * Indicates that the partition is not ready. This status is returned when
   * none of the other states apply. The value is 2.
   */
  NotReady = 'NotReady',
  /**
   * Indicates that the partition is in quorum loss. This means that number of
   * replicas that are up and participating in a replica set is less than
   * MinReplicaSetSize for this partition. The value is 3.
   */
  InQuorumLoss = 'InQuorumLoss',
  /**
   * Indicates that the partition is undergoing reconfiguration of its replica
   * sets. This can happen due to failover, upgrade, load balancing or addition
   * or removal of replicas from the replica set. The value is 4.
   */
  Reconfiguring = 'Reconfiguring',
  /**
   * Indicates that the partition is being deleted. The value is 5.
   */
  Deleting = 'Deleting',
}

/**
 * Defines values for ServiceStatus.
 * Possible values include: 'Unknown', 'Active', 'Upgrading', 'Deleting',
 * 'Creating', 'Failed'
 * There could be more values for this enum apart from the ones defined here.If
 * you want to set a value that is not from the known values then you can do
 * the following:
 * let param: ServiceStatus =
 * <ServiceStatus>"someUnknownValueThatWillStillBeValid";
 * @readonly
 * @enum {string}
 */
export enum ServiceStatus {
  /**
   * Indicates the service status is unknown. The value is zero.
   */
  Unknown = 'Unknown',
  /**
   * Indicates the service status is active. The value is 1.
   */
  Active = 'Active',
  /**
   * Indicates the service is upgrading. The value is 2.
   */
  Upgrading = 'Upgrading',
  /**
   * Indicates the service is being deleted. The value is 3.
   */
  Deleting = 'Deleting',
  /**
   * Indicates the service is being created. The value is 4.
   */
  Creating = 'Creating',
  /**
   * Indicates creation or deletion was terminated due to persistent failures.
   * Another create/delete request can be accepted. The value is 5.
   */
  Failed = 'Failed',
}

/**
 * Defines values for ProvisionApplicationTypeKind.
 * Possible values include: 'Invalid', 'ImageStorePath', 'ExternalStore'
 * There could be more values for this enum apart from the ones defined here.If
 * you want to set a value that is not from the known values then you can do
 * the following:
 * let param: ProvisionApplicationTypeKind =
 * <ProvisionApplicationTypeKind>"someUnknownValueThatWillStillBeValid";
 * @readonly
 * @enum {string}
 */
export enum ProvisionApplicationTypeKind {
  /**
   * Indicates that the provision kind is invalid. This value is default and
   * should not be used. The value is zero.
   */
  Invalid = 'Invalid',
  /**
   * Indicates that the provision is for a package that was previously uploaded
   * to the image store. The value is 1.
   */
  ImageStorePath = 'ImageStorePath',
  /**
   * Indicates that the provision is for an application package that was
   * previously uploaded to an external store. The application package ends
   * with the extension *.sfpkg. The value is 2.
   */
  ExternalStore = 'ExternalStore',
}

/**
 * Defines values for UpgradeType.
 * Possible values include: 'Invalid', 'Rolling', 'Rolling_ForceRestart'
 * There could be more values for this enum apart from the ones defined here.If
 * you want to set a value that is not from the known values then you can do
 * the following:
 * let param: UpgradeType =
 * <UpgradeType>"someUnknownValueThatWillStillBeValid";
 * @readonly
 * @enum {string}
 */
export enum UpgradeType {
  /**
   * Indicates the upgrade kind is invalid. All Service Fabric enumerations
   * have the invalid type. The value is zero.
   */
  Invalid = 'Invalid',
  /**
   * The upgrade progresses one upgrade domain at a time. The value is 1.
   */
  Rolling = 'Rolling',
  /**
   * The upgrade gets restarted by force. The value is 2.
   */
  RollingForceRestart = 'Rolling_ForceRestart',
}

/**
 * Defines values for SafetyCheckKind.
 * Possible values include: 'Invalid', 'EnsureSeedNodeQuorum',
 * 'EnsurePartitionQuorum', 'WaitForPrimaryPlacement', 'WaitForPrimarySwap',
 * 'WaitForReconfiguration', 'WaitForInbuildReplica', 'EnsureAvailability'
 * There could be more values for this enum apart from the ones defined here.If
 * you want to set a value that is not from the known values then you can do
 * the following:
 * let param: SafetyCheckKind =
 * <SafetyCheckKind>"someUnknownValueThatWillStillBeValid";
 * @readonly
 * @enum {string}
 */
export enum SafetyCheckKind {
  /**
   * Indicates that the upgrade safety check kind is invalid. All Service
   * Fabric enumerations have the invalid type. The value is zero.
   */
  Invalid = 'Invalid',
  /**
   * Indicates that if we bring down the node then this will result in global
   * seed node quorum loss. The value is 1.
   */
  EnsureSeedNodeQuorum = 'EnsureSeedNodeQuorum',
  /**
   * Indicates that there is some partition for which if we bring down the
   * replica on the node, it will result in quorum loss for that partition. The
   * value is 2.
   */
  EnsurePartitionQuorum = 'EnsurePartitionQuorum',
  /**
   * Indicates that there is some replica on the node that was moved out of
   * this node due to upgrade. Service Fabric is now waiting for the primary to
   * be moved back to this node. The value is 3.
   */
  WaitForPrimaryPlacement = 'WaitForPrimaryPlacement',
  /**
   * Indicates that Service Fabric is waiting for a primary replica to be moved
   * out of the node before starting upgrade on that node. The value is 4.
   */
  WaitForPrimarySwap = 'WaitForPrimarySwap',
  /**
   * Indicates that there is some replica on the node that is involved in a
   * reconfiguration. Service Fabric is waiting for the reconfiguration to be
   * complete before staring upgrade on that node. The value is 5.
   */
  WaitForReconfiguration = 'WaitForReconfiguration',
  /**
   * Indicates that there is either a replica on the node that is going through
   * copy, or there is a primary replica on the node that is copying data to
   * some other replica. In both cases, bringing down the replica on the node
   * due to upgrade will abort the copy. The value is 6.
   */
  WaitForInbuildReplica = 'WaitForInbuildReplica',
  /**
   * Indicates that there is either a stateless service partition on the node
   * having exactly one instance, or there is a primary replica on the node for
   * which the partition is quorum loss. In both cases, bringing down the
   * replicas due to upgrade will result in loss of availability. The value is
   * 7.
   */
  EnsureAvailability = 'EnsureAvailability',
}

/**
 * Defines values for CreateFabricDump.
 * Possible values include: 'False', 'True'
 * There could be more values for this enum apart from the ones defined here.If
 * you want to set a value that is not from the known values then you can do
 * the following:
 * let param: CreateFabricDump =
 * <CreateFabricDump>"someUnknownValueThatWillStillBeValid";
 * @readonly
 * @enum {string}
 */
export enum CreateFabricDump {
  False = 'False',
  True = 'True',
}

/**
 * Defines values for ServicePackageActivationMode.
 * Possible values include: 'SharedProcess', 'ExclusiveProcess'
 * There could be more values for this enum apart from the ones defined here.If
 * you want to set a value that is not from the known values then you can do
 * the following:
 * let param: ServicePackageActivationMode =
 * <ServicePackageActivationMode>"someUnknownValueThatWillStillBeValid";
 * @readonly
 * @enum {string}
 */
export enum ServicePackageActivationMode {
  /**
   * This is the default activation mode. With this activation mode, replicas
   * or instances from different partition(s) of service, on a given node, will
   * share same activation of service package on a node. The value is zero.
   */
  SharedProcess = 'SharedProcess',
  /**
   * With this activation mode, each replica or instance of service, on a given
   * node, will have its own dedicated activation of service package on a node.
   * The value is 1.
   */
  ExclusiveProcess = 'ExclusiveProcess',
}

/**
 * Defines values for ServiceKind.
 * Possible values include: 'Invalid', 'Stateless', 'Stateful'
 * There could be more values for this enum apart from the ones defined here.If
 * you want to set a value that is not from the known values then you can do
 * the following:
 * let param: ServiceKind =
 * <ServiceKind>"someUnknownValueThatWillStillBeValid";
 * @readonly
 * @enum {string}
 */
export enum ServiceKind {
  /**
   * Indicates the service kind is invalid. All Service Fabric enumerations
   * have the invalid type. The value is zero.
   */
  Invalid = 'Invalid',
  /**
   * Does not use Service Fabric to make its state highly available or
   * reliable. The value is 1.
   */
  Stateless = 'Stateless',
  /**
   * Uses Service Fabric to make its state or part of its state highly
   * available and reliable. The value is 2.
   */
  Stateful = 'Stateful',
}

/**
 * Defines values for ServicePartitionKind.
 * Possible values include: 'Invalid', 'Singleton', 'Int64Range', 'Named'
 * There could be more values for this enum apart from the ones defined here.If
 * you want to set a value that is not from the known values then you can do
 * the following:
 * let param: ServicePartitionKind =
 * <ServicePartitionKind>"someUnknownValueThatWillStillBeValid";
 * @readonly
 * @enum {string}
 */
export enum ServicePartitionKind {
  /**
   * Indicates the partition kind is invalid. All Service Fabric enumerations
   * have the invalid type. The value is zero.
   */
  Invalid = 'Invalid',
  /**
   * Indicates that there is only one partition, and
   * SingletonPartitionSchemeDescription was specified while creating the
   * service. The value is 1.
   */
  Singleton = 'Singleton',
  /**
   * Indicates that the partition is based on Int64 key ranges, and
   * UniformInt64RangePartitionSchemeDescription was specified while creating
   * the service. The value is 2.
   */
  Int64Range = 'Int64Range',
  /**
   * Indicates that the partition is based on string names, and
   * NamedPartitionInformation  was specified while creating the service. The
   * value is 3.
   */
  Named = 'Named',
}

/**
 * Defines values for ServicePlacementPolicyType.
 * Possible values include: 'Invalid', 'InvalidDomain', 'RequiredDomain',
 * 'PreferredPrimaryDomain', 'RequiredDomainDistribution',
 * 'NonPartiallyPlaceService'
 * There could be more values for this enum apart from the ones defined here.If
 * you want to set a value that is not from the known values then you can do
 * the following:
 * let param: ServicePlacementPolicyType =
 * <ServicePlacementPolicyType>"someUnknownValueThatWillStillBeValid";
 * @readonly
 * @enum {string}
 */
export enum ServicePlacementPolicyType {
  /**
   * Indicates the type of the placement policy is invalid. All Service Fabric
   * enumerations have the invalid type. The value is zero.
   */
  Invalid = 'Invalid',
  /**
   * Indicates that the ServicePlacementPolicyDescription is of type
   * ServicePlacementInvalidDomainPolicyDescription, which indicates that a
   * particular fault or upgrade domain cannot be used for placement of this
   * service. The value is 1.
   */
  InvalidDomain = 'InvalidDomain',
  /**
   * Indicates that the ServicePlacementPolicyDescription is of type
   * ServicePlacementRequireDomainDistributionPolicyDescription indicating that
   * the replicas of the service must be placed in a specific domain. The value
   * is 2.
   */
  RequiredDomain = 'RequiredDomain',
  /**
   * Indicates that the ServicePlacementPolicyDescription is of type
   * ServicePlacementPreferPrimaryDomainPolicyDescription, which indicates that
   * if possible the Primary replica for the partitions of the service should
   * be located in a particular domain as an optimization. The value is 3.
   */
  PreferredPrimaryDomain = 'PreferredPrimaryDomain',
  /**
   * Indicates that the ServicePlacementPolicyDescription is of type
   * ServicePlacementRequireDomainDistributionPolicyDescription, indicating
   * that the system will disallow placement of any two replicas from the same
   * partition in the same domain at any time. The value is 4.
   */
  RequiredDomainDistribution = 'RequiredDomainDistribution',
  /**
   * Indicates that the ServicePlacementPolicyDescription is of type
   * ServicePlacementNonPartiallyPlaceServicePolicyDescription, which indicates
   * that if possible all replicas of a particular partition of the service
   * should be placed atomically. The value is 5.
   */
  NonPartiallyPlaceService = 'NonPartiallyPlaceService',
}

/**
 * Defines values for ServiceLoadMetricWeight.
 * Possible values include: 'Zero', 'Low', 'Medium', 'High'
 * There could be more values for this enum apart from the ones defined here.If
 * you want to set a value that is not from the known values then you can do
 * the following:
 * let param: ServiceLoadMetricWeight =
 * <ServiceLoadMetricWeight>"someUnknownValueThatWillStillBeValid";
 * @readonly
 * @enum {string}
 */
export enum ServiceLoadMetricWeight {
  /**
   * Disables resource balancing for this metric. This value is zero.
   */
  Zero = 'Zero',
  /**
   * Specifies the metric weight of the service load as Low. The value is 1.
   */
  Low = 'Low',
  /**
   * Specifies the metric weight of the service load as Medium. The value is 2.
   */
  Medium = 'Medium',
  /**
   * Specifies the metric weight of the service load as High. The value is 3.
   */
  High = 'High',
}

/**
 * Defines values for HostType.
 * Possible values include: 'Invalid', 'ExeHost', 'ContainerHost'
 * There could be more values for this enum apart from the ones defined here.If
 * you want to set a value that is not from the known values then you can do
 * the following:
 * let param: HostType = <HostType>"someUnknownValueThatWillStillBeValid";
 * @readonly
 * @enum {string}
 */
export enum HostType {
  /**
   * Indicates the type of host is not known or invalid. The value is 0.
   */
  Invalid = 'Invalid',
  /**
   * Indicates the host is an executable. The value is 1.
   */
  ExeHost = 'ExeHost',
  /**
   * Indicates the host is a container. The value is 2.
   */
  ContainerHost = 'ContainerHost',
}

/**
 * Defines values for HostIsolationMode.
 * Possible values include: 'None', 'Process', 'HyperV'
 * There could be more values for this enum apart from the ones defined here.If
 * you want to set a value that is not from the known values then you can do
 * the following:
 * let param: HostIsolationMode =
 * <HostIsolationMode>"someUnknownValueThatWillStillBeValid";
 * @readonly
 * @enum {string}
 */
export enum HostIsolationMode {
  /**
   * Indicates the isolation mode is not applicable for given HostType. The
   * value is 0.
   */
  None = 'None',
  /**
   * This is the default isolation mode for a ContainerHost. The value is 1.
   */
  Process = 'Process',
  /**
   * Indicates the ContainerHost is a Hyper-V container. This applies to only
   * Windows containers. The value is 2.
   */
  HyperV = 'HyperV',
}

/**
 * Defines values for DeploymentStatus.
 * Possible values include: 'Invalid', 'Downloading', 'Activating', 'Active',
 * 'Upgrading', 'Deactivating'
 * There could be more values for this enum apart from the ones defined here.If
 * you want to set a value that is not from the known values then you can do
 * the following:
 * let param: DeploymentStatus =
 * <DeploymentStatus>"someUnknownValueThatWillStillBeValid";
 * @readonly
 * @enum {string}
 */
export enum DeploymentStatus {
  /**
   * Indicates status of the application or service package is not known or
   * invalid. The value is 0.
   */
  Invalid = 'Invalid',
  /**
   * Indicates the application or service package is being downloaded to the
   * node from the ImageStore. The value is 1.
   */
  Downloading = 'Downloading',
  /**
   * Indicates the application or service package is being activated. The value
   * is 2.
   */
  Activating = 'Activating',
  /**
   * Indicates the application or service package is active the node. The value
   * is 3.
   */
  Active = 'Active',
  /**
   * Indicates the application or service package is being upgraded. The value
   * is 4.
   */
  Upgrading = 'Upgrading',
  /**
   * Indicates the application or service package is being deactivated. The
   * value is 5.
   */
  Deactivating = 'Deactivating',
}

/**
 * Defines values for EntryPointStatus.
 * Possible values include: 'Invalid', 'Pending', 'Starting', 'Started',
 * 'Stopping', 'Stopped'
 * There could be more values for this enum apart from the ones defined here.If
 * you want to set a value that is not from the known values then you can do
 * the following:
 * let param: EntryPointStatus =
 * <EntryPointStatus>"someUnknownValueThatWillStillBeValid";
 * @readonly
 * @enum {string}
 */
export enum EntryPointStatus {
  /**
   * Indicates status of entry point is not known or invalid. The value is 0.
   */
  Invalid = 'Invalid',
  /**
   * Indicates the entry point is scheduled to be started. The value is 1.
   */
  Pending = 'Pending',
  /**
   * Indicates the entry point is being started. The value is 2.
   */
  Starting = 'Starting',
  /**
   * Indicates the entry point was started successfully and is running. The
   * value is 3.
   */
  Started = 'Started',
  /**
   * Indicates the entry point is being stopped. The value is 4.
   */
  Stopping = 'Stopping',
  /**
   * Indicates the entry point is not running. The value is 5.
   */
  Stopped = 'Stopped',
}

/**
 * Defines values for ChaosStatus.
 * Possible values include: 'Invalid', 'Running', 'Stopped'
 * There could be more values for this enum apart from the ones defined here.If
 * you want to set a value that is not from the known values then you can do
 * the following:
 * let param: ChaosStatus =
 * <ChaosStatus>"someUnknownValueThatWillStillBeValid";
 * @readonly
 * @enum {string}
 */
export enum ChaosStatus {
  /**
   * Indicates an invalid Chaos status. All Service Fabric enumerations have
   * the invalid type. The valus is zero.
   */
  Invalid = 'Invalid',
  /**
   * Indicates that Chaos is not stopped. The value is one.
   */
  Running = 'Running',
  /**
   * Indicates that Chaos is not scheduling further faults. The value is two.
   */
  Stopped = 'Stopped',
}

/**
 * Defines values for ChaosScheduleStatus.
 * Possible values include: 'Invalid', 'Stopped', 'Active', 'Expired',
 * 'Pending'
 * There could be more values for this enum apart from the ones defined here.If
 * you want to set a value that is not from the known values then you can do
 * the following:
 * let param: ChaosScheduleStatus =
 * <ChaosScheduleStatus>"someUnknownValueThatWillStillBeValid";
 * @readonly
 * @enum {string}
 */
export enum ChaosScheduleStatus {
  /**
   * Indicates an invalid Chaos Schedule status. All Service Fabric
   * enumerations have the invalid type. The valus is zero.
   */
  Invalid = 'Invalid',
  /**
   * Indicates that the schedule is stopped and not being used to schedule runs
   * of chaos. The value is one.
   */
  Stopped = 'Stopped',
  /**
   * Indicates that the schedule is active and is being used to schedule runs
   * of Chaos. The value is two.
   */
  Active = 'Active',
  /**
   * Indicates that the schedule is expired and will no longer be used to
   * schedule runs of Chaos. The value is three.
   */
  Expired = 'Expired',
  /**
   * Indicates that the schedule is pending and is not yet being used to
   * schedule runs of Chaos but will be used when the start time is passed. The
   * value is four.
   */
  Pending = 'Pending',
}

/**
 * Defines values for ChaosEventKind.
 * Possible values include: 'Invalid', 'Started', 'ExecutingFaults', 'Waiting',
 * 'ValidationFailed', 'TestError', 'Stopped'
 * There could be more values for this enum apart from the ones defined here.If
 * you want to set a value that is not from the known values then you can do
 * the following:
 * let param: ChaosEventKind =
 * <ChaosEventKind>"someUnknownValueThatWillStillBeValid";
 * @readonly
 * @enum {string}
 */
export enum ChaosEventKind {
  /**
   * Indicates an invalid Chaos event kind. All Service Fabric enumerations
   * have the invalid type.
   */
  Invalid = 'Invalid',
  /**
   * Indicates a Chaos event that gets generated when Chaos is started.
   */
  Started = 'Started',
  /**
   * Indicates a Chaos event that gets generated when Chaos has decided on the
   * faults for an iteration. This Chaos event contains the details of the
   * faults as a list of strings.
   */
  ExecutingFaults = 'ExecutingFaults',
  /**
   * Indicates a Chaos event that gets generated when Chaos is waiting for the
   * cluster to become ready for faulting, for example, Chaos may be waiting
   * for the on-going upgrade to finish.
   */
  Waiting = 'Waiting',
  /**
   * Indicates a Chaos event that gets generated when the cluster entities do
   * not become stable and healthy within
   * ChaosParameters.MaxClusterStabilizationTimeoutInSeconds.
   */
  ValidationFailed = 'ValidationFailed',
  /**
   * Indicates a Chaos event that gets generated when an unexpected event has
   * occurred in the Chaos engine, for example, due to the cluster snapshot
   * being inconsistent, while faulting a faultable entity Chaos found that the
   * entity was already faulted.
   */
  TestError = 'TestError',
  /**
   * Indicates a Chaos event that gets generated when Chaos stops because
   * either the user issued a stop or the time to run was up.
   */
  Stopped = 'Stopped',
}

/**
 * Defines values for ComposeDeploymentStatus.
 * Possible values include: 'Invalid', 'Provisioning', 'Creating', 'Ready',
 * 'Unprovisioning', 'Deleting', 'Failed', 'Upgrading'
 * There could be more values for this enum apart from the ones defined here.If
 * you want to set a value that is not from the known values then you can do
 * the following:
 * let param: ComposeDeploymentStatus =
 * <ComposeDeploymentStatus>"someUnknownValueThatWillStillBeValid";
 * @readonly
 * @enum {string}
 */
export enum ComposeDeploymentStatus {
  /**
   * Indicates that the compose deployment status is invalid. The value is
   * zero.
   */
  Invalid = 'Invalid',
  /**
   * Indicates that the compose deployment is being provisioned in background.
   * The value is 1.
   */
  Provisioning = 'Provisioning',
  /**
   * Indicates that the compose deployment is being created in background. The
   * value is 2.
   */
  Creating = 'Creating',
  /**
   * Indicates that the compose deployment has been successfully created or
   * upgraded. The value is 3.
   */
  Ready = 'Ready',
  /**
   * Indicates that the compose deployment is being unprovisioned in
   * background. The value is 4.
   */
  Unprovisioning = 'Unprovisioning',
  /**
   * Indicates that the compose deployment is being deleted in background. The
   * value is 5.
   */
  Deleting = 'Deleting',
  /**
   * Indicates that the compose deployment was terminated due to persistent
   * failures. The value is 6.
   */
  Failed = 'Failed',
  /**
   * Indicates that the compose deployment is being upgraded in the background.
   * The value is 7.
   */
  Upgrading = 'Upgrading',
}

/**
 * Defines values for ComposeDeploymentUpgradeState.
 * Possible values include: 'Invalid', 'ProvisioningTarget',
 * 'RollingForwardInProgress', 'RollingForwardPending',
 * 'UnprovisioningCurrent', 'RollingForwardCompleted', 'RollingBackInProgress',
 * 'UnprovisioningTarget', 'RollingBackCompleted', 'Failed'
 * There could be more values for this enum apart from the ones defined here.If
 * you want to set a value that is not from the known values then you can do
 * the following:
 * let param: ComposeDeploymentUpgradeState =
 * <ComposeDeploymentUpgradeState>"someUnknownValueThatWillStillBeValid";
 * @readonly
 * @enum {string}
 */
export enum ComposeDeploymentUpgradeState {
  /**
   * Indicates the upgrade state is invalid. All Service Fabric enumerations
   * have the invalid type. The value is zero.
   */
  Invalid = 'Invalid',
  /**
   * The upgrade is in the progress of provisioning target application type
   * version. The value is 1.
   */
  ProvisioningTarget = 'ProvisioningTarget',
  /**
   * The upgrade is rolling forward to the target version but is not complete
   * yet. The value is 2.
   */
  RollingForwardInProgress = 'RollingForwardInProgress',
  /**
   * The current upgrade domain has finished upgrading. The overall upgrade is
   * waiting for an explicit move next request in UnmonitoredManual mode or
   * performing health checks in Monitored mode. The value is 3
   */
  RollingForwardPending = 'RollingForwardPending',
  /**
   * The upgrade is in the progress of unprovisioning current application type
   * version and rolling forward to the target version is completed. The value
   * is 4.
   */
  UnprovisioningCurrent = 'UnprovisioningCurrent',
  /**
   * The upgrade has finished rolling forward. The value is 5.
   */
  RollingForwardCompleted = 'RollingForwardCompleted',
  /**
   * The upgrade is rolling back to the previous version but is not complete
   * yet. The value is 6.
   */
  RollingBackInProgress = 'RollingBackInProgress',
  /**
   * The upgrade is in the progress of unprovisioning target application type
   * version and rolling back to the current version is completed. The value is
   * 7.
   */
  UnprovisioningTarget = 'UnprovisioningTarget',
  /**
   * The upgrade has finished rolling back. The value is 8.
   */
  RollingBackCompleted = 'RollingBackCompleted',
  /**
   * The upgrade has failed and is unable to execute FailureAction. The value
   * is 9.
   */
  Failed = 'Failed',
}

/**
 * Defines values for ServiceCorrelationScheme.
 * Possible values include: 'Invalid', 'Affinity', 'AlignedAffinity',
 * 'NonAlignedAffinity'
 * There could be more values for this enum apart from the ones defined here.If
 * you want to set a value that is not from the known values then you can do
 * the following:
 * let param: ServiceCorrelationScheme =
 * <ServiceCorrelationScheme>"someUnknownValueThatWillStillBeValid";
 * @readonly
 * @enum {string}
 */
export enum ServiceCorrelationScheme {
  /**
   * An invalid correlation scheme. Cannot be used. The value is zero.
   */
  Invalid = 'Invalid',
  /**
   * Indicates that this service has an affinity relationship with another
   * service. Provided for backwards compatibility, consider preferring the
   * Aligned or NonAlignedAffinity options. The value is 1.
   */
  Affinity = 'Affinity',
  /**
   * Aligned affinity ensures that the primaries of the partitions of the
   * affinitized services are collocated on the same nodes. This is the default
   * and is the same as selecting the Affinity scheme. The value is 2.
   */
  AlignedAffinity = 'AlignedAffinity',
  /**
   * Non-Aligned affinity guarantees that all replicas of each service will be
   * placed on the same nodes. Unlike Aligned Affinity, this does not guarantee
   * that replicas of particular role will be collocated. The value is 3.
   */
  NonAlignedAffinity = 'NonAlignedAffinity',
}

/**
 * Defines values for MoveCost.
 * Possible values include: 'Zero', 'Low', 'Medium', 'High'
 * There could be more values for this enum apart from the ones defined here.If
 * you want to set a value that is not from the known values then you can do
 * the following:
 * let param: MoveCost = <MoveCost>"someUnknownValueThatWillStillBeValid";
 * @readonly
 * @enum {string}
 */
export enum MoveCost {
  /**
   * Zero move cost. This value is zero.
   */
  Zero = 'Zero',
  /**
   * Specifies the move cost of the service as Low. The value is 1.
   */
  Low = 'Low',
  /**
   * Specifies the move cost of the service as Medium. The value is 2.
   */
  Medium = 'Medium',
  /**
   * Specifies the move cost of the service as High. The value is 3.
   */
  High = 'High',
}

/**
 * Defines values for PartitionScheme.
 * Possible values include: 'Invalid', 'Singleton', 'UniformInt64Range',
 * 'Named'
 * There could be more values for this enum apart from the ones defined here.If
 * you want to set a value that is not from the known values then you can do
 * the following:
 * let param: PartitionScheme =
 * <PartitionScheme>"someUnknownValueThatWillStillBeValid";
 * @readonly
 * @enum {string}
 */
export enum PartitionScheme {
  /**
   * Indicates the partition kind is invalid. All Service Fabric enumerations
   * have the invalid type. The value is zero.
   */
  Invalid = 'Invalid',
  /**
   * Indicates that the partition is based on string names, and is a
   * SingletonPartitionSchemeDescription object, The value is 1.
   */
  Singleton = 'Singleton',
  /**
   * Indicates that the partition is based on Int64 key ranges, and is a
   * UniformInt64RangePartitionSchemeDescription object. The value is 2.
   */
  UniformInt64Range = 'UniformInt64Range',
  /**
   * Indicates that the partition is based on string names, and is a
   * NamedPartitionSchemeDescription object. The value is 3
   */
  Named = 'Named',
}

/**
 * Defines values for ServiceOperationName.
 * Possible values include: 'Unknown', 'None', 'Open', 'ChangeRole', 'Close',
 * 'Abort'
 * There could be more values for this enum apart from the ones defined here.If
 * you want to set a value that is not from the known values then you can do
 * the following:
 * let param: ServiceOperationName =
 * <ServiceOperationName>"someUnknownValueThatWillStillBeValid";
 * @readonly
 * @enum {string}
 */
export enum ServiceOperationName {
  /**
   * Reserved for future use.
   */
  Unknown = 'Unknown',
  /**
   * The service replica or instance is not going through any life-cycle
   * changes.
   */
  None = 'None',
  /**
   * The service replica or instance is being opened.
   */
  Open = 'Open',
  /**
   * The service replica is changing roles.
   */
  ChangeRole = 'ChangeRole',
  /**
   * The service replica or instance is being closed.
   */
  Close = 'Close',
  /**
   * The service replica or instance is being aborted.
   */
  Abort = 'Abort',
}

/**
 * Defines values for ReplicatorOperationName.
 * Possible values include: 'Invalid', 'None', 'Open', 'ChangeRole',
 * 'UpdateEpoch', 'Close', 'Abort', 'OnDataLoss', 'WaitForCatchup', 'Build'
 * There could be more values for this enum apart from the ones defined here.If
 * you want to set a value that is not from the known values then you can do
 * the following:
 * let param: ReplicatorOperationName =
 * <ReplicatorOperationName>"someUnknownValueThatWillStillBeValid";
 * @readonly
 * @enum {string}
 */
export enum ReplicatorOperationName {
  /**
   * Default value if the replicator is not yet ready.
   */
  Invalid = 'Invalid',
  /**
   * Replicator is not running any operation from Service Fabric perspective.
   */
  None = 'None',
  /**
   * Replicator is opening.
   */
  Open = 'Open',
  /**
   * Replicator is in the process of changing its role.
   */
  ChangeRole = 'ChangeRole',
  /**
   * Due to a change in the replica set, replicator is being updated with its
   * Epoch.
   */
  UpdateEpoch = 'UpdateEpoch',
  /**
   * Replicator is closing.
   */
  Close = 'Close',
  /**
   * Replicator is being aborted.
   */
  Abort = 'Abort',
  /**
   * Replicator is handling the data loss condition, where the user service may
   * potentially be recovering state from an external source.
   */
  OnDataLoss = 'OnDataLoss',
  /**
   * Replicator is waiting for a quorum of replicas to be caught up to the
   * latest state.
   */
  WaitForCatchup = 'WaitForCatchup',
  /**
   * Replicator is in the process of building one or more replicas.
   */
  Build = 'Build',
}

/**
 * Defines values for PartitionAccessStatus.
 * Possible values include: 'Invalid', 'Granted', 'ReconfigurationPending',
 * 'NotPrimary', 'NoWriteQuorum'
 * There could be more values for this enum apart from the ones defined here.If
 * you want to set a value that is not from the known values then you can do
 * the following:
 * let param: PartitionAccessStatus =
 * <PartitionAccessStatus>"someUnknownValueThatWillStillBeValid";
 * @readonly
 * @enum {string}
 */
export enum PartitionAccessStatus {
  /**
   * Indicates that the read or write operation access status is not valid.
   * This value is not returned to the caller.
   */
  Invalid = 'Invalid',
  /**
   * Indicates that the read or write operation access is granted and the
   * operation is allowed.
   */
  Granted = 'Granted',
  /**
   * Indicates that the client should try again later, because a
   * reconfiguration is in progress.
   */
  ReconfigurationPending = 'ReconfigurationPending',
  /**
   * Indicates that this client request was received by a replica that is not a
   * Primary replica.
   */
  NotPrimary = 'NotPrimary',
  /**
   * Indicates that no write quorum is available and, therefore, no write
   * operation can be accepted.
   */
  NoWriteQuorum = 'NoWriteQuorum',
}

/**
 * Defines values for FabricReplicaStatus.
 * Possible values include: 'Invalid', 'Down', 'Up'
 * There could be more values for this enum apart from the ones defined here.If
 * you want to set a value that is not from the known values then you can do
 * the following:
 * let param: FabricReplicaStatus =
 * <FabricReplicaStatus>"someUnknownValueThatWillStillBeValid";
 * @readonly
 * @enum {string}
 */
export enum FabricReplicaStatus {
  /**
   * Indicates that the read or write operation access status is not valid.
   * This value is not returned to the caller.
   */
  Invalid = 'Invalid',
  /**
   * Indicates that the replica is down.
   */
  Down = 'Down',
  /**
   * Indicates that the replica is up.
   */
  Up = 'Up',
}

/**
 * Defines values for ReplicaKind.
 * Possible values include: 'Invalid', 'KeyValueStore'
 * There could be more values for this enum apart from the ones defined here.If
 * you want to set a value that is not from the known values then you can do
 * the following:
 * let param: ReplicaKind =
 * <ReplicaKind>"someUnknownValueThatWillStillBeValid";
 * @readonly
 * @enum {string}
 */
export enum ReplicaKind {
  /**
   * Represents an invalid replica kind. The value is zero.
   */
  Invalid = 'Invalid',
  /**
   * Represents a key value store replica. The value is 1
   */
  KeyValueStore = 'KeyValueStore',
}

/**
 * Defines values for ServiceTypeRegistrationStatus.
 * Possible values include: 'Invalid', 'Disabled', 'Enabled', 'Registered'
 * There could be more values for this enum apart from the ones defined here.If
 * you want to set a value that is not from the known values then you can do
 * the following:
 * let param: ServiceTypeRegistrationStatus =
 * <ServiceTypeRegistrationStatus>"someUnknownValueThatWillStillBeValid";
 * @readonly
 * @enum {string}
 */
export enum ServiceTypeRegistrationStatus {
  /**
   * Indicates the registration status is invalid. All Service Fabric
   * enumerations have the invalid type. The value is zero.
   */
  Invalid = 'Invalid',
  /**
   * Indicates that the service type is disabled on this node. A type gets
   * disabled when there are too many failures of the code package hosting the
   * service type. If the service type is disabled, new replicas of that
   * service type will not be placed on the node until it is enabled again. The
   * service type is enabled again after the process hosting it comes up and
   * re-registers the type or a preconfigured time interval has passed. The
   * value is 1.
   */
  Disabled = 'Disabled',
  /**
   * Indicates that the service type is enabled on this node. Replicas of this
   * service type can be placed on this node when the code package registers
   * the service type. The value is 2.
   */
  Enabled = 'Enabled',
  /**
   * Indicates that the service type is enabled and registered on the node by a
   * code package. Replicas of this service type can now be placed on this
   * node. The value is 3.
   */
  Registered = 'Registered',
}

/**
 * Defines values for ServiceEndpointRole.
 * Possible values include: 'Invalid', 'Stateless', 'StatefulPrimary',
 * 'StatefulSecondary'
 * There could be more values for this enum apart from the ones defined here.If
 * you want to set a value that is not from the known values then you can do
 * the following:
 * let param: ServiceEndpointRole =
 * <ServiceEndpointRole>"someUnknownValueThatWillStillBeValid";
 * @readonly
 * @enum {string}
 */
export enum ServiceEndpointRole {
  /**
   * Indicates the service endpoint role is invalid. All Service Fabric
   * enumerations have the invalid type. The value is zero.
   */
  Invalid = 'Invalid',
  /**
   * Indicates that the service endpoint is of a stateless service. The value
   * is 1.
   */
  Stateless = 'Stateless',
  /**
   * Indicates that the service endpoint is of a primary replica of a stateful
   * service. The value is 2.
   */
  StatefulPrimary = 'StatefulPrimary',
  /**
   * Indicates that the service endpoint is of a secondary replica of a
   * stateful service. The value is 3.
   */
  StatefulSecondary = 'StatefulSecondary',
}

/**
 * Defines values for OperationState.
 * Possible values include: 'Invalid', 'Running', 'RollingBack', 'Completed',
 * 'Faulted', 'Cancelled', 'ForceCancelled'
 * There could be more values for this enum apart from the ones defined here.If
 * you want to set a value that is not from the known values then you can do
 * the following:
 * let param: OperationState =
 * <OperationState>"someUnknownValueThatWillStillBeValid";
 * @readonly
 * @enum {string}
 */
export enum OperationState {
  /**
   * The operation state is invalid.
   */
  Invalid = 'Invalid',
  /**
   * The operation is in progress.
   */
  Running = 'Running',
  /**
   * The operation is rolling back internal system state because it encountered
   * a fatal error or was cancelled by the user.  "RollingBack"     does not
   * refer to user state.  For example, if CancelOperation is called on a
   * command of type PartitionDataLoss, state of "RollingBack" does not mean
   * service data is being restored (assuming the command has progressed far
   * enough to cause data loss). It means the system is rolling back/cleaning
   * up internal system state associated with the command.
   */
  RollingBack = 'RollingBack',
  /**
   * The operation has completed successfully and is no longer running.
   */
  Completed = 'Completed',
  /**
   * The operation has failed and is no longer running.
   */
  Faulted = 'Faulted',
  /**
   * The operation was cancelled by the user using CancelOperation, and is no
   * longer running.
   */
  Cancelled = 'Cancelled',
  /**
   * The operation was cancelled by the user using CancelOperation, with the
   * force parameter set to true.  It is no longer running.  Refer to
   * CancelOperation for more details.
   */
  ForceCancelled = 'ForceCancelled',
}

/**
 * Defines values for OperationType.
 * Possible values include: 'Invalid', 'PartitionDataLoss',
 * 'PartitionQuorumLoss', 'PartitionRestart', 'NodeTransition'
 * There could be more values for this enum apart from the ones defined here.If
 * you want to set a value that is not from the known values then you can do
 * the following:
 * let param: OperationType =
 * <OperationType>"someUnknownValueThatWillStillBeValid";
 * @readonly
 * @enum {string}
 */
export enum OperationType {
  /**
   * The operation state is invalid.
   */
  Invalid = 'Invalid',
  /**
   * An operation started using the StartDataLoss API.
   */
  PartitionDataLoss = 'PartitionDataLoss',
  /**
   * An operation started using the StartQuorumLoss API.
   */
  PartitionQuorumLoss = 'PartitionQuorumLoss',
  /**
   * An operation started using the StartPartitionRestart API.
   */
  PartitionRestart = 'PartitionRestart',
  /**
   * An operation started using the StartNodeTransition API.
   */
  NodeTransition = 'NodeTransition',
}

/**
 * Defines values for PackageSharingPolicyScope.
 * Possible values include: 'None', 'All', 'Code', 'Config', 'Data'
 * There could be more values for this enum apart from the ones defined here.If
 * you want to set a value that is not from the known values then you can do
 * the following:
 * let param: PackageSharingPolicyScope =
 * <PackageSharingPolicyScope>"someUnknownValueThatWillStillBeValid";
 * @readonly
 * @enum {string}
 */
export enum PackageSharingPolicyScope {
  /**
   * No package sharing policy scope. The value is 0.
   */
  None = 'None',
  /**
   * Share all code, config and data packages from corresponding service
   * manifest. The value is 1.
   */
  All = 'All',
  /**
   * Share all code packages from corresponding service manifest. The value is
   * 2.
   */
  Code = 'Code',
  /**
   * Share all config packages from corresponding service manifest. The value
   * is 3.
   */
  Config = 'Config',
  /**
   * Share all data packages from corresponding service manifest. The value is
   * 4.
   */
  Data = 'Data',
}

/**
 * Defines values for PropertyValueKind.
 * Possible values include: 'Invalid', 'Binary', 'Int64', 'Double', 'String',
 * 'Guid'
 * There could be more values for this enum apart from the ones defined here.If
 * you want to set a value that is not from the known values then you can do
 * the following:
 * let param: PropertyValueKind =
 * <PropertyValueKind>"someUnknownValueThatWillStillBeValid";
 * @readonly
 * @enum {string}
 */
export enum PropertyValueKind {
  /**
   * Indicates the property is invalid. All Service Fabric enumerations have
   * the invalid type. The value is zero.
   */
  Invalid = 'Invalid',
  /**
   * The data inside the property is a binary blob. The value is 1.
   */
  Binary = 'Binary',
  /**
   * The data inside the property is an int64. The value is 2.
   */
  Int64 = 'Int64',
  /**
   * The data inside the property is a double. The value is 3.
   */
  Double = 'Double',
  /**
   * The data inside the property is a string. The value is 4.
   */
  String = 'String',
  /**
   * The data inside the property is a guid. The value is 5.
   */
  Guid = 'Guid',
}

/**
 * Defines values for PropertyBatchOperationKind.
 * Possible values include: 'Invalid', 'Put', 'Get', 'CheckExists',
 * 'CheckSequence', 'Delete', 'CheckValue'
 * There could be more values for this enum apart from the ones defined here.If
 * you want to set a value that is not from the known values then you can do
 * the following:
 * let param: PropertyBatchOperationKind =
 * <PropertyBatchOperationKind>"someUnknownValueThatWillStillBeValid";
 * @readonly
 * @enum {string}
 */
export enum PropertyBatchOperationKind {
  /**
   * Indicates the property operation is invalid. All Service Fabric
   * enumerations have the invalid type. The value is zero.
   */
  Invalid = 'Invalid',
  /**
   * The operation will create or edit a property. The value is 1.
   */
  Put = 'Put',
  /**
   * The operation will get a property. The value is 2.
   */
  Get = 'Get',
  /**
   * The operation will check that a property exists or doesn't exists,
   * depending on the provided value. The value is 3.
   */
  CheckExists = 'CheckExists',
  /**
   * The operation will ensure that the sequence number is equal to the
   * provided value. The value is 4.
   */
  CheckSequence = 'CheckSequence',
  /**
   * The operation will delete a property. The value is 5.
   */
  Delete = 'Delete',
  /**
   * The operation will ensure that the value of a property is equal to the
   * provided value. The value is 7.
   */
  CheckValue = 'CheckValue',
}

/**
 * Defines values for PropertyBatchInfoKind.
 * Possible values include: 'Invalid', 'Successful', 'Failed'
 * There could be more values for this enum apart from the ones defined here.If
 * you want to set a value that is not from the known values then you can do
 * the following:
 * let param: PropertyBatchInfoKind =
 * <PropertyBatchInfoKind>"someUnknownValueThatWillStillBeValid";
 * @readonly
 * @enum {string}
 */
export enum PropertyBatchInfoKind {
  /**
   * Indicates the property batch info is invalid. All Service Fabric
   * enumerations have the invalid type.
   */
  Invalid = 'Invalid',
  /**
   * The property batch succeeded.
   */
  Successful = 'Successful',
  /**
   * The property batch failed.
   */
  Failed = 'Failed',
}

/**
 * Defines values for BackupStorageKind.
 * Possible values include: 'Invalid', 'FileShare', 'AzureBlobStore'
 * There could be more values for this enum apart from the ones defined here.If
 * you want to set a value that is not from the known values then you can do
 * the following:
 * let param: BackupStorageKind =
 * <BackupStorageKind>"someUnknownValueThatWillStillBeValid";
 * @readonly
 * @enum {string}
 */
export enum BackupStorageKind {
  /**
   * Indicates an invalid backup storage kind. All Service Fabric enumerations
   * have the invalid type.
   */
  Invalid = 'Invalid',
  /**
   * Indicates file/ SMB share to be used as backup storage.
   */
  FileShare = 'FileShare',
  /**
   * Indicates Azure blob store to be used as backup storage.
   */
  AzureBlobStore = 'AzureBlobStore',
}

/**
 * Defines values for BackupScheduleKind.
 * Possible values include: 'Invalid', 'TimeBased', 'FrequencyBased'
 * There could be more values for this enum apart from the ones defined here.If
 * you want to set a value that is not from the known values then you can do
 * the following:
 * let param: BackupScheduleKind =
 * <BackupScheduleKind>"someUnknownValueThatWillStillBeValid";
 * @readonly
 * @enum {string}
 */
export enum BackupScheduleKind {
  /**
   * Indicates an invalid backup schedule kind. All Service Fabric enumerations
   * have the invalid type.
   */
  Invalid = 'Invalid',
  /**
   * Indicates a time-based backup schedule.
   */
  TimeBased = 'TimeBased',
  /**
   * Indicates a frequency-based backup schedule.
   */
  FrequencyBased = 'FrequencyBased',
}

/**
 * Defines values for BackupPolicyScope.
 * Possible values include: 'Invalid', 'Partition', 'Service', 'Application'
 * There could be more values for this enum apart from the ones defined here.If
 * you want to set a value that is not from the known values then you can do
 * the following:
 * let param: BackupPolicyScope =
 * <BackupPolicyScope>"someUnknownValueThatWillStillBeValid";
 * @readonly
 * @enum {string}
 */
export enum BackupPolicyScope {
  /**
   * Indicates an invalid backup policy scope type. All Service Fabric
   * enumerations have the invalid type.
   */
  Invalid = 'Invalid',
  /**
   * Indicates the backup policy is applied at partition level. Hence
   * overriding any policy which may have applied at partition's service or
   * application level.
   */
  Partition = 'Partition',
  /**
   * Indicates the backup policy is applied at service level. All partitions of
   * the service inherit this policy unless explicitly overridden at partition
   * level.
   */
  Service = 'Service',
  /**
   * Indicates the backup policy is applied at application level. All services
   * and partitions of the application inherit this policy unless explicitly
   * overridden at service or partition level.
   */
  Application = 'Application',
}

/**
 * Defines values for BackupSuspensionScope.
 * Possible values include: 'Invalid', 'Partition', 'Service', 'Application'
 * There could be more values for this enum apart from the ones defined here.If
 * you want to set a value that is not from the known values then you can do
 * the following:
 * let param: BackupSuspensionScope =
 * <BackupSuspensionScope>"someUnknownValueThatWillStillBeValid";
 * @readonly
 * @enum {string}
 */
export enum BackupSuspensionScope {
  /**
   * Indicates an invalid backup suspension scope type also indicating entity
   * is not suspended. All Service Fabric enumerations have the invalid type.
   */
  Invalid = 'Invalid',
  /**
   * Indicates the backup suspension is applied at partition level.
   */
  Partition = 'Partition',
  /**
   * Indicates the backup suspension is applied at service level. All
   * partitions of the service are hence suspended for backup.
   */
  Service = 'Service',
  /**
   * Indicates the backup suspension is applied at application level. All
   * services and partitions of the application are hence suspended for backup.
   */
  Application = 'Application',
}

/**
 * Defines values for RestoreState.
 * Possible values include: 'Invalid', 'Accepted', 'RestoreInProgress',
 * 'Success', 'Failure', 'Timeout'
 * There could be more values for this enum apart from the ones defined here.If
 * you want to set a value that is not from the known values then you can do
 * the following:
 * let param: RestoreState =
 * <RestoreState>"someUnknownValueThatWillStillBeValid";
 * @readonly
 * @enum {string}
 */
export enum RestoreState {
  /**
   * Indicates an invalid restore state. All Service Fabric enumerations have
   * the invalid type.
   */
  Invalid = 'Invalid',
  /**
   * Operation has been validated and accepted. Restore is yet to be triggered.
   */
  Accepted = 'Accepted',
  /**
   * Restore operation has been triggered and is under process.
   */
  RestoreInProgress = 'RestoreInProgress',
  /**
   * Operation completed with success.
   */
  Success = 'Success',
  /**
   * Operation completed with failure.
   */
  Failure = 'Failure',
  /**
   * Operation timed out.
   */
  Timeout = 'Timeout',
}

/**
 * Defines values for BackupType.
 * Possible values include: 'Invalid', 'Full', 'Incremental'
 * There could be more values for this enum apart from the ones defined here.If
 * you want to set a value that is not from the known values then you can do
 * the following:
 * let param: BackupType = <BackupType>"someUnknownValueThatWillStillBeValid";
 * @readonly
 * @enum {string}
 */
export enum BackupType {
  /**
   * Indicates an invalid backup type. All Service Fabric enumerations have the
   * invalid type.
   */
  Invalid = 'Invalid',
  /**
   * Indicates a full backup.
   */
  Full = 'Full',
  /**
   * Indicates an incremental backup. A backup chain is comprised of a full
   * backup followed by 0 or more incremental backups.
   */
  Incremental = 'Incremental',
}

/**
 * Defines values for BackupScheduleFrequencyType.
 * Possible values include: 'Invalid', 'Daily', 'Weekly'
 * There could be more values for this enum apart from the ones defined here.If
 * you want to set a value that is not from the known values then you can do
 * the following:
 * let param: BackupScheduleFrequencyType =
 * <BackupScheduleFrequencyType>"someUnknownValueThatWillStillBeValid";
 * @readonly
 * @enum {string}
 */
export enum BackupScheduleFrequencyType {
  /**
   * Indicates an invalid backup schedule frequency type. All Service Fabric
   * enumerations have the invalid type.
   */
  Invalid = 'Invalid',
  /**
   * Indicates that the time based backup schedule is repeated at a daily
   * frequency.
   */
  Daily = 'Daily',
  /**
   * Indicates that the time based backup schedule is repeated at a weekly
   * frequency.
   */
  Weekly = 'Weekly',
}

/**
 * Defines values for DayOfWeek.
 * Possible values include: 'Sunday', 'Monday', 'Tuesday', 'Wednesday',
 * 'Thursday', 'Friday', 'Saturday'
 * There could be more values for this enum apart from the ones defined here.If
 * you want to set a value that is not from the known values then you can do
 * the following:
 * let param: DayOfWeek = <DayOfWeek>"someUnknownValueThatWillStillBeValid";
 * @readonly
 * @enum {string}
 */
export enum DayOfWeek {
  /**
   * Indicates the Day referred is Sunday.
   */
  Sunday = 'Sunday',
  /**
   * Indicates the Day referred is Monday.
   */
  Monday = 'Monday',
  /**
   * Indicates the Day referred is Tuesday.
   */
  Tuesday = 'Tuesday',
  /**
   * Indicates the Day referred is Wednesday.
   */
  Wednesday = 'Wednesday',
  /**
   * Indicates the Day referred is Thursday.
   */
  Thursday = 'Thursday',
  /**
   * Indicates the Day referred is Friday.
   */
  Friday = 'Friday',
  /**
   * Indicates the Day referred is Saturday.
   */
  Saturday = 'Saturday',
}

/**
 * Defines values for BackupState.
 * Possible values include: 'Invalid', 'Accepted', 'BackupInProgress',
 * 'Success', 'Failure', 'Timeout'
 * There could be more values for this enum apart from the ones defined here.If
 * you want to set a value that is not from the known values then you can do
 * the following:
 * let param: BackupState =
 * <BackupState>"someUnknownValueThatWillStillBeValid";
 * @readonly
 * @enum {string}
 */
export enum BackupState {
  /**
   * Indicates an invalid backup state. All Service Fabric enumerations have
   * the invalid type.
   */
  Invalid = 'Invalid',
  /**
   * Operation has been validated and accepted. Backup is yet to be triggered.
   */
  Accepted = 'Accepted',
  /**
   * Backup operation has been triggered and is under process.
   */
  BackupInProgress = 'BackupInProgress',
  /**
   * Operation completed with success.
   */
  Success = 'Success',
  /**
   * Operation completed with failure.
   */
  Failure = 'Failure',
  /**
   * Operation timed out.
   */
  Timeout = 'Timeout',
}

/**
 * Defines values for BackupEntityKind.
 * Possible values include: 'Invalid', 'Partition', 'Service', 'Application'
 * There could be more values for this enum apart from the ones defined here.If
 * you want to set a value that is not from the known values then you can do
 * the following:
 * let param: BackupEntityKind =
 * <BackupEntityKind>"someUnknownValueThatWillStillBeValid";
 * @readonly
 * @enum {string}
 */
export enum BackupEntityKind {
  /**
   * Indicates an invalid entity kind. All Service Fabric enumerations have the
   * invalid type.
   */
  Invalid = 'Invalid',
  /**
   * Indicates the entity is a Service Fabric partition.
   */
  Partition = 'Partition',
  /**
   * Indicates the entity is a Service Fabric service.
   */
  Service = 'Service',
  /**
   * Indicates the entity is a Service Fabric application.
   */
  Application = 'Application',
}

/**
 * Defines values for ImpactLevel.
 * Possible values include: 'Invalid', 'None', 'Restart', 'RemoveData',
 * 'RemoveNode'
 * There could be more values for this enum apart from the ones defined here.If
 * you want to set a value that is not from the known values then you can do
 * the following:
 * let param: ImpactLevel =
 * <ImpactLevel>"someUnknownValueThatWillStillBeValid";
 * @readonly
 * @enum {string}
 */
export enum ImpactLevel {
  Invalid = 'Invalid',
  None = 'None',
  Restart = 'Restart',
  RemoveData = 'RemoveData',
  RemoveNode = 'RemoveNode',
}

/**
 * Defines values for RepairImpactKind.
 * Possible values include: 'Invalid', 'Node'
 * There could be more values for this enum apart from the ones defined here.If
 * you want to set a value that is not from the known values then you can do
 * the following:
 * let param: RepairImpactKind =
 * <RepairImpactKind>"someUnknownValueThatWillStillBeValid";
 * @readonly
 * @enum {string}
 */
export enum RepairImpactKind {
  /**
   * The repair impact is not valid or is of an unknown type.
   */
  Invalid = 'Invalid',
  /**
   * The repair impact affects a set of Service Fabric nodes.
   */
  Node = 'Node',
}

/**
 * Defines values for RepairTargetKind.
 * Possible values include: 'Invalid', 'Node'
 * There could be more values for this enum apart from the ones defined here.If
 * you want to set a value that is not from the known values then you can do
 * the following:
 * let param: RepairTargetKind =
 * <RepairTargetKind>"someUnknownValueThatWillStillBeValid";
 * @readonly
 * @enum {string}
 */
export enum RepairTargetKind {
  /**
   * The repair target is not valid or is of an unknown type.
   */
  Invalid = 'Invalid',
  /**
   * The repair target is a set of Service Fabric nodes.
   */
  Node = 'Node',
}

/**
 * Defines values for State.
 * Possible values include: 'Invalid', 'Created', 'Claimed', 'Preparing',
 * 'Approved', 'Executing', 'Restoring', 'Completed'
 * There could be more values for this enum apart from the ones defined here.If
 * you want to set a value that is not from the known values then you can do
 * the following:
 * let param: State = <State>"someUnknownValueThatWillStillBeValid";
 * @readonly
 * @enum {string}
 */
export enum State {
  /**
   * Indicates that the repair task state is invalid. All Service Fabric
   * enumerations have the invalid value.
   */
  Invalid = 'Invalid',
  /**
   * Indicates that the repair task has been created.
   */
  Created = 'Created',
  /**
   * Indicates that the repair task has been claimed by a repair executor.
   */
  Claimed = 'Claimed',
  /**
   * Indicates that the Repair Manager is preparing the system to handle the
   * impact of the repair task, usually by taking resources offline gracefully.
   */
  Preparing = 'Preparing',
  /**
   * Indicates that the repair task has been approved by the Repair Manager and
   * is safe to execute.
   */
  Approved = 'Approved',
  /**
   * Indicates that execution of the repair task is in progress.
   */
  Executing = 'Executing',
  /**
   * Indicates that the Repair Manager is restoring the system to its
   * pre-repair state, usually by bringing resources back online.
   */
  Restoring = 'Restoring',
  /**
   * Indicates that the repair task has completed, and no further state changes
   * will occur.
   */
  Completed = 'Completed',
}

/**
 * Defines values for ResultStatus.
 * Possible values include: 'Invalid', 'Succeeded', 'Cancelled', 'Interrupted',
 * 'Failed', 'Pending'
 * There could be more values for this enum apart from the ones defined here.If
 * you want to set a value that is not from the known values then you can do
 * the following:
 * let param: ResultStatus =
 * <ResultStatus>"someUnknownValueThatWillStillBeValid";
 * @readonly
 * @enum {string}
 */
export enum ResultStatus {
  /**
   * Indicates that the repair task result is invalid. All Service Fabric
   * enumerations have the invalid value.
   */
  Invalid = 'Invalid',
  /**
   * Indicates that the repair task completed execution successfully.
   */
  Succeeded = 'Succeeded',
  /**
   * Indicates that the repair task was cancelled prior to execution.
   */
  Cancelled = 'Cancelled',
  /**
   * Indicates that execution of the repair task was interrupted by a
   * cancellation request after some work had already been performed.
   */
  Interrupted = 'Interrupted',
  /**
   * Indicates that there was a failure during execution of the repair task.
   * Some work may have been performed.
   */
  Failed = 'Failed',
  /**
   * Indicates that the repair task result is not yet available, because the
   * repair task has not finished executing.
   */
  Pending = 'Pending',
}

/**
 * Defines values for RepairTaskHealthCheckState.
 * Possible values include: 'NotStarted', 'InProgress', 'Succeeded', 'Skipped',
 * 'TimedOut'
 * There could be more values for this enum apart from the ones defined here.If
 * you want to set a value that is not from the known values then you can do
 * the following:
 * let param: RepairTaskHealthCheckState =
 * <RepairTaskHealthCheckState>"someUnknownValueThatWillStillBeValid";
 * @readonly
 * @enum {string}
 */
export enum RepairTaskHealthCheckState {
  /**
   * Indicates that the health check has not started.
   */
  NotStarted = 'NotStarted',
  /**
   * Indicates that the health check is in progress.
   */
  InProgress = 'InProgress',
  /**
   * Indicates that the health check succeeded.
   */
  Succeeded = 'Succeeded',
  /**
   * Indicates that the health check was skipped.
   */
  Skipped = 'Skipped',
  /**
   * Indicates that the health check timed out.
   */
  TimedOut = 'TimedOut',
}

/**
 * Defines values for ScalingTriggerKind.
 * Possible values include: 'Invalid', 'AveragePartitionLoad',
 * 'AverageServiceLoad'
 * There could be more values for this enum apart from the ones defined here.If
 * you want to set a value that is not from the known values then you can do
 * the following:
 * let param: ScalingTriggerKind =
 * <ScalingTriggerKind>"someUnknownValueThatWillStillBeValid";
 * @readonly
 * @enum {string}
 */
export enum ScalingTriggerKind {
  /**
   * Indicates the scaling trigger is invalid. All Service Fabric enumerations
   * have the invalid type. The value is zero.
   */
  Invalid = 'Invalid',
  /**
   * Indicates a trigger where scaling decisions are made based on average load
   * of a partition. The value is 1.
   */
  AveragePartitionLoad = 'AveragePartitionLoad',
  /**
   * Indicates a trigger where scaling decisions are made based on average load
   * of a service. The value is 2.
   */
  AverageServiceLoad = 'AverageServiceLoad',
}

/**
 * Defines values for ScalingMechanismKind.
 * Possible values include: 'Invalid', 'PartitionInstanceCount',
 * 'AddRemoveIncrementalNamedPartition'
 * There could be more values for this enum apart from the ones defined here.If
 * you want to set a value that is not from the known values then you can do
 * the following:
 * let param: ScalingMechanismKind =
 * <ScalingMechanismKind>"someUnknownValueThatWillStillBeValid";
 * @readonly
 * @enum {string}
 */
export enum ScalingMechanismKind {
  /**
   * Indicates the scaling mechanism is invalid. All Service Fabric
   * enumerations have the invalid type. The value is zero.
   */
  Invalid = 'Invalid',
  /**
   * Indicates a mechanism for scaling where new instances are added or removed
   * from a partition. The value is 1.
   */
  PartitionInstanceCount = 'PartitionInstanceCount',
  /**
   * Indicates a mechanism for scaling where new named partitions are added or
   * removed from a service. The value is 2.
   */
  AddRemoveIncrementalNamedPartition = 'AddRemoveIncrementalNamedPartition',
}

/**
 * Defines values for ServiceResourceStatus.
 * Possible values include: 'Unknown', 'Active', 'Upgrading', 'Deleting',
 * 'Creating', 'Failed'
 * There could be more values for this enum apart from the ones defined here.If
 * you want to set a value that is not from the known values then you can do
 * the following:
 * let param: ServiceResourceStatus =
 * <ServiceResourceStatus>"someUnknownValueThatWillStillBeValid";
 * @readonly
 * @enum {string}
 */
export enum ServiceResourceStatus {
  Unknown = 'Unknown',
  Active = 'Active',
  Upgrading = 'Upgrading',
  Deleting = 'Deleting',
  Creating = 'Creating',
  Failed = 'Failed',
}

/**
 * Defines values for ApplicationResourceStatus.
 * Possible values include: 'Invalid', 'Ready', 'Upgrading', 'Creating',
 * 'Deleting', 'Failed'
 * There could be more values for this enum apart from the ones defined here.If
 * you want to set a value that is not from the known values then you can do
 * the following:
 * let param: ApplicationResourceStatus =
 * <ApplicationResourceStatus>"someUnknownValueThatWillStillBeValid";
 * @readonly
 * @enum {string}
 */
export enum ApplicationResourceStatus {
  Invalid = 'Invalid',
  Ready = 'Ready',
  Upgrading = 'Upgrading',
  Creating = 'Creating',
  Deleting = 'Deleting',
  Failed = 'Failed',
}

/**
 * Defines values for DiagnosticsSinkKind.
 * Possible values include: 'Invalid', 'AzureInternalMonitoringPipeline'
 * There could be more values for this enum apart from the ones defined here.If
 * you want to set a value that is not from the known values then you can do
 * the following:
 * let param: DiagnosticsSinkKind =
 * <DiagnosticsSinkKind>"someUnknownValueThatWillStillBeValid";
 * @readonly
 * @enum {string}
 */
export enum DiagnosticsSinkKind {
  /**
   * Indicates an invalid sink kind. All Service Fabric enumerations have the
   * invalid type.
   */
  Invalid = 'Invalid',
  /**
   * Diagnostics settings for Geneva.
   */
  AzureInternalMonitoringPipeline = 'AzureInternalMonitoringPipeline',
}

/**
 * Defines values for OperatingSystemTypes.
 * Possible values include: 'Linux', 'Windows'
 * There could be more values for this enum apart from the ones defined here.If
 * you want to set a value that is not from the known values then you can do
 * the following:
 * let param: OperatingSystemTypes =
 * <OperatingSystemTypes>"someUnknownValueThatWillStillBeValid";
 * @readonly
 * @enum {string}
 */
export enum OperatingSystemTypes {
  Linux = 'Linux',
  Windows = 'Windows',
}

/**
 * Defines values for NodeStatusFilter.
 * Possible values include: 'default', 'all', 'up', 'down', 'enabling',
 * 'disabling', 'disabled', 'unknown', 'removed'
 * There could be more values for this enum apart from the ones defined here.If
 * you want to set a value that is not from the known values then you can do
 * the following:
 * let param: NodeStatusFilter =
 * <NodeStatusFilter>"someUnknownValueThatWillStillBeValid";
 * @readonly
 * @enum {string}
 */
export enum NodeStatusFilter {
  /**
   * This filter value will match all of the nodes excepts the ones with with
   * status as Unknown or Removed.
   */
  Default = 'default',
  /**
   * This filter value will match all of the nodes.
   */
  All = 'all',
  /**
   * This filter value will match nodes that are Up.
   */
  Up = 'up',
  /**
   * This filter value will match nodes that are Down.
   */
  Down = 'down',
  /**
   * This filter value will match nodes that are in the process of being
   * enabled with status as Enabling.
   */
  Enabling = 'enabling',
  /**
   * This filter value will match nodes that are in the process of being
   * disabled with status as Disabling.
   */
  Disabling = 'disabling',
  /**
   * This filter value will match nodes that are Disabled.
   */
  Disabled = 'disabled',
  /**
   * This filter value will match nodes whose status is Unknown. A node would
   * be in Unknown state if Service Fabric does not have authoritative
   * information about that node. This can happen if the system learns about a
   * node at runtime.
   */
  Unknown = 'unknown',
  /**
   * This filter value will match nodes whose status is Removed. These are the
   * nodes that are removed from the cluster using the RemoveNodeState API.
   */
  Removed = 'removed',
}

/**
 * Defines values for ReplicaHealthReportServiceKind.
 * Possible values include: 'Stateless', 'Stateful'
 * There could be more values for this enum apart from the ones defined here.If
 * you want to set a value that is not from the known values then you can do
 * the following:
 * let param: ReplicaHealthReportServiceKind =
 * <ReplicaHealthReportServiceKind>"someUnknownValueThatWillStillBeValid";
 * @readonly
 * @enum {string}
 */
export enum ReplicaHealthReportServiceKind {
  /**
   * Does not use Service Fabric to make its state highly available or
   * reliable. The value is 1
   */
  Stateless = 'Stateless',
  /**
   * Uses Service Fabric to make its state or part of its state highly
   * available and reliable. The value is 2.
   */
  Stateful = 'Stateful',
}

/**
 * Defines values for DataLossMode.
 * Possible values include: 'Invalid', 'PartialDataLoss', 'FullDataLoss'
 * There could be more values for this enum apart from the ones defined here.If
 * you want to set a value that is not from the known values then you can do
 * the following:
 * let param: DataLossMode =
 * <DataLossMode>"someUnknownValueThatWillStillBeValid";
 * @readonly
 * @enum {string}
 */
export enum DataLossMode {
  /**
   * Reserved.  Do not pass into API.
   */
  Invalid = 'Invalid',
  /**
   * PartialDataLoss option will cause a quorum of replicas to go down,
   * triggering an OnDataLoss event in the system for the given partition.
   */
  PartialDataLoss = 'PartialDataLoss',
  /**
   * FullDataLoss option will drop all the replicas which means that all the
   * data will be lost.
   */
  FullDataLoss = 'FullDataLoss',
}

/**
 * Defines values for NodeTransitionType.
 * Possible values include: 'Invalid', 'Start', 'Stop'
 * There could be more values for this enum apart from the ones defined here.If
 * you want to set a value that is not from the known values then you can do
 * the following:
 * let param: NodeTransitionType =
 * <NodeTransitionType>"someUnknownValueThatWillStillBeValid";
 * @readonly
 * @enum {string}
 */
export enum NodeTransitionType {
  /**
   * Reserved.  Do not pass into API.
   */
  Invalid = 'Invalid',
  /**
   * Transition a stopped node to up.
   */
  Start = 'Start',
  /**
   * Transition an up node to stopped.
   */
  Stop = 'Stop',
}

/**
 * Defines values for QuorumLossMode.
 * Possible values include: 'Invalid', 'QuorumReplicas', 'AllReplicas'
 * There could be more values for this enum apart from the ones defined here.If
 * you want to set a value that is not from the known values then you can do
 * the following:
 * let param: QuorumLossMode =
 * <QuorumLossMode>"someUnknownValueThatWillStillBeValid";
 * @readonly
 * @enum {string}
 */
export enum QuorumLossMode {
  /**
   * Reserved.  Do not pass into API.
   */
  Invalid = 'Invalid',
  /**
   * Partial Quorum loss mode : Minimum number of replicas for a partition will
   * be down that will cause a quorum loss.
   */
  QuorumReplicas = 'QuorumReplicas',
  AllReplicas = 'AllReplicas',
}

/**
 * Defines values for RestartPartitionMode.
 * Possible values include: 'Invalid', 'AllReplicasOrInstances',
 * 'OnlyActiveSecondaries'
 * There could be more values for this enum apart from the ones defined here.If
 * you want to set a value that is not from the known values then you can do
 * the following:
 * let param: RestartPartitionMode =
 * <RestartPartitionMode>"someUnknownValueThatWillStillBeValid";
 * @readonly
 * @enum {string}
 */
export enum RestartPartitionMode {
  /**
   * Reserved.  Do not pass into API.
   */
  Invalid = 'Invalid',
  /**
   * All replicas or instances in the partition are restarted at once.
   */
  AllReplicasOrInstances = 'AllReplicasOrInstances',
  /**
   * Only the secondary replicas are restarted.
   */
  OnlyActiveSecondaries = 'OnlyActiveSecondaries',
}

/**
 * Contains response data for the getClusterManifest operation.
 */
export type GetClusterManifestResponse = ClusterManifest & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;
      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: ClusterManifest;
    };
};

/**
 * Contains response data for the getClusterHealth operation.
 */
export type GetClusterHealthResponse = ClusterHealth & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;
      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: ClusterHealth;
    };
};

/**
 * Contains response data for the getClusterHealthUsingPolicy operation.
 */
export type GetClusterHealthUsingPolicyResponse = ClusterHealth & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;
      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: ClusterHealth;
    };
};

/**
 * Contains response data for the getClusterHealthChunk operation.
 */
export type GetClusterHealthChunkResponse = ClusterHealthChunk & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;
      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: ClusterHealthChunk;
    };
};

/**
 * Contains response data for the getClusterHealthChunkUsingPolicyAndAdvancedFilters operation.
 */
export type GetClusterHealthChunkUsingPolicyAndAdvancedFiltersResponse = ClusterHealthChunk & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;
      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: ClusterHealthChunk;
    };
};

/**
 * Contains response data for the getProvisionedFabricCodeVersionInfoList operation.
 */
export type GetProvisionedFabricCodeVersionInfoListResponse = Array<FabricCodeVersionInfo> & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;
      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: FabricCodeVersionInfo[];
    };
};

/**
 * Contains response data for the getProvisionedFabricConfigVersionInfoList operation.
 */
export type GetProvisionedFabricConfigVersionInfoListResponse = Array<FabricConfigVersionInfo> & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;
      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: FabricConfigVersionInfo[];
    };
};

/**
 * Contains response data for the getClusterUpgradeProgress operation.
 */
export type GetClusterUpgradeProgressResponse = ClusterUpgradeProgressObject & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;
      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: ClusterUpgradeProgressObject;
    };
};

/**
 * Contains response data for the getClusterConfiguration operation.
 */
export type GetClusterConfigurationResponse = ClusterConfiguration & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;
      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: ClusterConfiguration;
    };
};

/**
 * Contains response data for the getClusterConfigurationUpgradeStatus operation.
 */
export type GetClusterConfigurationUpgradeStatusResponse = ClusterConfigurationUpgradeStatusInfo & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;
      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: ClusterConfigurationUpgradeStatusInfo;
    };
};

/**
 * Contains response data for the getUpgradeOrchestrationServiceState operation.
 */
export type GetUpgradeOrchestrationServiceStateResponse = UpgradeOrchestrationServiceState & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;
      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: UpgradeOrchestrationServiceState;
    };
};

/**
 * Contains response data for the setUpgradeOrchestrationServiceState operation.
 */
export type SetUpgradeOrchestrationServiceStateResponse = UpgradeOrchestrationServiceStateSummary & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;
      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: UpgradeOrchestrationServiceStateSummary;
    };
};

/**
 * Contains response data for the getAadMetadata operation.
 */
export type GetAadMetadataResponse = AadMetadataObject & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;
      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: AadMetadataObject;
    };
};

/**
 * Contains response data for the getNodeInfoList operation.
 */
export type GetNodeInfoListResponse = PagedNodeInfoList & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;
      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: PagedNodeInfoList;
    };
};

/**
 * Contains response data for the getNodeInfo operation.
 */
export type GetNodeInfoResponse = NodeInfo & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;
      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: NodeInfo;
    };
};

/**
 * Contains response data for the getNodeHealth operation.
 */
export type GetNodeHealthResponse = NodeHealth & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;
      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: NodeHealth;
    };
};

/**
 * Contains response data for the getNodeHealthUsingPolicy operation.
 */
export type GetNodeHealthUsingPolicyResponse = NodeHealth & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;
      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: NodeHealth;
    };
};

/**
 * Contains response data for the getNodeLoadInfo operation.
 */
export type GetNodeLoadInfoResponse = NodeLoadInfo & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;
      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: NodeLoadInfo;
    };
};

/**
 * Contains response data for the getApplicationTypeInfoList operation.
 */
export type GetApplicationTypeInfoListResponse = PagedApplicationTypeInfoList & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;
      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: PagedApplicationTypeInfoList;
    };
};

/**
 * Contains response data for the getApplicationTypeInfoListByName operation.
 */
export type GetApplicationTypeInfoListByNameResponse = PagedApplicationTypeInfoList & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;
      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: PagedApplicationTypeInfoList;
    };
};

/**
 * Contains response data for the getServiceTypeInfoList operation.
 */
export type GetServiceTypeInfoListResponse = Array<ServiceTypeInfo> & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;
      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: ServiceTypeInfo[];
    };
};

/**
 * Contains response data for the getServiceTypeInfoByName operation.
 */
export type GetServiceTypeInfoByNameResponse = ServiceTypeInfo & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;
      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: ServiceTypeInfo;
    };
};

/**
 * Contains response data for the getServiceManifest operation.
 */
export type GetServiceManifestResponse = ServiceTypeManifest & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;
      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: ServiceTypeManifest;
    };
};

/**
 * Contains response data for the getDeployedServiceTypeInfoList operation.
 */
export type GetDeployedServiceTypeInfoListResponse = Array<DeployedServiceTypeInfo> & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;
      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: DeployedServiceTypeInfo[];
    };
};

/**
 * Contains response data for the getDeployedServiceTypeInfoByName operation.
 */
export type GetDeployedServiceTypeInfoByNameResponse = Array<DeployedServiceTypeInfo> & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;
      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: DeployedServiceTypeInfo[];
    };
};

/**
 * Contains response data for the getApplicationLoadInfo operation.
 */
export type GetApplicationLoadInfoResponse = ApplicationLoadInfo & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;
      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: ApplicationLoadInfo;
    };
};

/**
 * Contains response data for the getApplicationInfoList operation.
 */
export type GetApplicationInfoListResponse = PagedApplicationInfoList & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;
      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: PagedApplicationInfoList;
    };
};

/**
 * Contains response data for the getApplicationInfo operation.
 */
export type GetApplicationInfoResponse = ApplicationInfo & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;
      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: ApplicationInfo;
    };
};

/**
 * Contains response data for the getApplicationHealth operation.
 */
export type GetApplicationHealthResponse = ApplicationHealth & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;
      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: ApplicationHealth;
    };
};

/**
 * Contains response data for the getApplicationHealthUsingPolicy operation.
 */
export type GetApplicationHealthUsingPolicyResponse = ApplicationHealth & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;
      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: ApplicationHealth;
    };
};

/**
 * Contains response data for the getApplicationUpgrade operation.
 */
export type GetApplicationUpgradeResponse = ApplicationUpgradeProgressInfo & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;
      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: ApplicationUpgradeProgressInfo;
    };
};

/**
 * Contains response data for the getDeployedApplicationInfoList operation.
 */
export type GetDeployedApplicationInfoListResponse = PagedDeployedApplicationInfoList & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;
      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: PagedDeployedApplicationInfoList;
    };
};

/**
 * Contains response data for the getDeployedApplicationInfo operation.
 */
export type GetDeployedApplicationInfoResponse = DeployedApplicationInfo & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;
      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: DeployedApplicationInfo;
    };
};

/**
 * Contains response data for the getDeployedApplicationHealth operation.
 */
export type GetDeployedApplicationHealthResponse = DeployedApplicationHealth & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;
      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: DeployedApplicationHealth;
    };
};

/**
 * Contains response data for the getDeployedApplicationHealthUsingPolicy operation.
 */
export type GetDeployedApplicationHealthUsingPolicyResponse = DeployedApplicationHealth & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;
      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: DeployedApplicationHealth;
    };
};

/**
 * Contains response data for the getApplicationManifest operation.
 */
export type GetApplicationManifestResponse = ApplicationTypeManifest & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;
      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: ApplicationTypeManifest;
    };
};

/**
 * Contains response data for the getServiceInfoList operation.
 */
export type GetServiceInfoListResponse = PagedServiceInfoList & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;
      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: PagedServiceInfoList;
    };
};

/**
 * Contains response data for the getServiceInfo operation.
 */
export type GetServiceInfoResponse = ServiceInfoUnion & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;
      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: ServiceInfoUnion;
    };
};

/**
 * Contains response data for the getApplicationNameInfo operation.
 */
export type GetApplicationNameInfoResponse = ApplicationNameInfo & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;
      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: ApplicationNameInfo;
    };
};

/**
 * Contains response data for the getServiceDescription operation.
 */
export type GetServiceDescriptionResponse = ServiceDescriptionUnion & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;
      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: ServiceDescriptionUnion;
    };
};

/**
 * Contains response data for the getServiceHealth operation.
 */
export type GetServiceHealthResponse = ServiceHealth & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;
      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: ServiceHealth;
    };
};

/**
 * Contains response data for the getServiceHealthUsingPolicy operation.
 */
export type GetServiceHealthUsingPolicyResponse = ServiceHealth & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;
      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: ServiceHealth;
    };
};

/**
 * Contains response data for the resolveService operation.
 */
export type ResolveServiceResponse = ResolvedServicePartition & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;
      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: ResolvedServicePartition;
    };
};

/**
 * Contains response data for the getPartitionInfoList operation.
 */
export type GetPartitionInfoListResponse = PagedServicePartitionInfoList & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;
      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: PagedServicePartitionInfoList;
    };
};

/**
 * Contains response data for the getPartitionInfo operation.
 */
export type GetPartitionInfoResponse = ServicePartitionInfoUnion & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;
      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: ServicePartitionInfoUnion;
    };
};

/**
 * Contains response data for the getServiceNameInfo operation.
 */
export type GetServiceNameInfoResponse = ServiceNameInfo & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;
      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: ServiceNameInfo;
    };
};

/**
 * Contains response data for the getPartitionHealth operation.
 */
export type GetPartitionHealthResponse = PartitionHealth & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;
      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: PartitionHealth;
    };
};

/**
 * Contains response data for the getPartitionHealthUsingPolicy operation.
 */
export type GetPartitionHealthUsingPolicyResponse = PartitionHealth & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;
      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: PartitionHealth;
    };
};

/**
 * Contains response data for the getPartitionLoadInformation operation.
 */
export type GetPartitionLoadInformationResponse = PartitionLoadInformation & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;
      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: PartitionLoadInformation;
    };
};

/**
 * Contains response data for the createRepairTask operation.
 */
export type CreateRepairTaskResponse = RepairTaskUpdateInfo & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;
      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: RepairTaskUpdateInfo;
    };
};

/**
 * Contains response data for the cancelRepairTask operation.
 */
export type CancelRepairTaskResponse = RepairTaskUpdateInfo & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;
      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: RepairTaskUpdateInfo;
    };
};

/**
 * Contains response data for the getRepairTaskList operation.
 */
export type GetRepairTaskListResponse = Array<RepairTask> & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;
      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: RepairTask[];
    };
};

/**
 * Contains response data for the forceApproveRepairTask operation.
 */
export type ForceApproveRepairTaskResponse = RepairTaskUpdateInfo & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;
      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: RepairTaskUpdateInfo;
    };
};

/**
 * Contains response data for the updateRepairTaskHealthPolicy operation.
 */
export type UpdateRepairTaskHealthPolicyResponse = RepairTaskUpdateInfo & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;
      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: RepairTaskUpdateInfo;
    };
};

/**
 * Contains response data for the updateRepairExecutionState operation.
 */
export type UpdateRepairExecutionStateResponse = RepairTaskUpdateInfo & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;
      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: RepairTaskUpdateInfo;
    };
};

/**
 * Contains response data for the getReplicaInfoList operation.
 */
export type GetReplicaInfoListResponse = PagedReplicaInfoList & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;
      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: PagedReplicaInfoList;
    };
};

/**
 * Contains response data for the getReplicaInfo operation.
 */
export type GetReplicaInfoResponse = ReplicaInfoUnion & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;
      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: ReplicaInfoUnion;
    };
};

/**
 * Contains response data for the getReplicaHealth operation.
 */
export type GetReplicaHealthResponse = ReplicaHealthUnion & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;
      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: ReplicaHealthUnion;
    };
};

/**
 * Contains response data for the getReplicaHealthUsingPolicy operation.
 */
export type GetReplicaHealthUsingPolicyResponse = ReplicaHealthUnion & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;
      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: ReplicaHealthUnion;
    };
};

/**
 * Contains response data for the getDeployedServiceReplicaInfoList operation.
 */
export type GetDeployedServiceReplicaInfoListResponse = Array<DeployedServiceReplicaInfoUnion> & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;
      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: DeployedServiceReplicaInfoUnion[];
    };
};

/**
 * Contains response data for the getDeployedServiceReplicaDetailInfo operation.
 */
export type GetDeployedServiceReplicaDetailInfoResponse = DeployedServiceReplicaDetailInfoUnion & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;
      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: DeployedServiceReplicaDetailInfoUnion;
    };
};

/**
 * Contains response data for the getDeployedServiceReplicaDetailInfoByPartitionId operation.
 */
export type GetDeployedServiceReplicaDetailInfoByPartitionIdResponse = DeployedServiceReplicaDetailInfoUnion & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;
      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: DeployedServiceReplicaDetailInfoUnion;
    };
};

/**
 * Contains response data for the getDeployedServicePackageInfoList operation.
 */
export type GetDeployedServicePackageInfoListResponse = Array<DeployedServicePackageInfo> & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;
      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: DeployedServicePackageInfo[];
    };
};

/**
 * Contains response data for the getDeployedServicePackageInfoListByName operation.
 */
export type GetDeployedServicePackageInfoListByNameResponse = Array<DeployedServicePackageInfo> & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;
      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: DeployedServicePackageInfo[];
    };
};

/**
 * Contains response data for the getDeployedServicePackageHealth operation.
 */
export type GetDeployedServicePackageHealthResponse = DeployedServicePackageHealth & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;
      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: DeployedServicePackageHealth;
    };
};

/**
 * Contains response data for the getDeployedServicePackageHealthUsingPolicy operation.
 */
export type GetDeployedServicePackageHealthUsingPolicyResponse = DeployedServicePackageHealth & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;
      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: DeployedServicePackageHealth;
    };
};

/**
 * Contains response data for the getDeployedCodePackageInfoList operation.
 */
export type GetDeployedCodePackageInfoListResponse = Array<DeployedCodePackageInfo> & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;
      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: DeployedCodePackageInfo[];
    };
};

/**
 * Contains response data for the getContainerLogsDeployedOnNode operation.
 */
export type GetContainerLogsDeployedOnNodeResponse = ContainerLogs & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;
      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: ContainerLogs;
    };
};

/**
 * Contains response data for the invokeContainerApi operation.
 */
export type InvokeContainerApiResponse = ContainerApiResponse & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;
      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: ContainerApiResponse;
    };
};

/**
 * Contains response data for the getComposeDeploymentStatus operation.
 */
export type GetComposeDeploymentStatusResponse = ComposeDeploymentStatusInfo & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;
      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: ComposeDeploymentStatusInfo;
    };
};

/**
 * Contains response data for the getComposeDeploymentStatusList operation.
 */
export type GetComposeDeploymentStatusListResponse = PagedComposeDeploymentStatusInfoList & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;
      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: PagedComposeDeploymentStatusInfoList;
    };
};

/**
 * Contains response data for the getComposeDeploymentUpgradeProgress operation.
 */
export type GetComposeDeploymentUpgradeProgressResponse = ComposeDeploymentUpgradeProgressInfo & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;
      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: ComposeDeploymentUpgradeProgressInfo;
    };
};

/**
 * Contains response data for the getChaos operation.
 */
export type GetChaosResponse = Chaos & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;
      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: Chaos;
    };
};

/**
 * Contains response data for the getChaosEvents operation.
 */
export type GetChaosEventsResponse = ChaosEventsSegment & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;
      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: ChaosEventsSegment;
    };
};

/**
 * Contains response data for the getChaosSchedule operation.
 */
export type GetChaosScheduleResponse = ChaosScheduleDescription & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;
      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: ChaosScheduleDescription;
    };
};

/**
 * Contains response data for the getImageStoreContent operation.
 */
export type GetImageStoreContentResponse = ImageStoreContent & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;
      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: ImageStoreContent;
    };
};

/**
 * Contains response data for the getImageStoreRootContent operation.
 */
export type GetImageStoreRootContentResponse = ImageStoreContent & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;
      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: ImageStoreContent;
    };
};

/**
 * Contains response data for the getImageStoreUploadSessionById operation.
 */
export type GetImageStoreUploadSessionByIdResponse = UploadSession & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;
      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: UploadSession;
    };
};

/**
 * Contains response data for the getImageStoreUploadSessionByPath operation.
 */
export type GetImageStoreUploadSessionByPathResponse = UploadSession & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;
      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: UploadSession;
    };
};

/**
 * Contains response data for the invokeInfrastructureCommand operation.
 */
export type InvokeInfrastructureCommandResponse = {
  /**
   * The parsed response body.
   */
  body: string;
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;
      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: string;
    };
};

/**
 * Contains response data for the invokeInfrastructureQuery operation.
 */
export type InvokeInfrastructureQueryResponse = {
  /**
   * The parsed response body.
   */
  body: string;
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;
      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: string;
    };
};

/**
 * Contains response data for the getDataLossProgress operation.
 */
export type GetDataLossProgressResponse = PartitionDataLossProgress & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;
      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: PartitionDataLossProgress;
    };
};

/**
 * Contains response data for the getQuorumLossProgress operation.
 */
export type GetQuorumLossProgressResponse = PartitionQuorumLossProgress & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;
      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: PartitionQuorumLossProgress;
    };
};

/**
 * Contains response data for the getPartitionRestartProgress operation.
 */
export type GetPartitionRestartProgressResponse = PartitionRestartProgress & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;
      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: PartitionRestartProgress;
    };
};

/**
 * Contains response data for the getNodeTransitionProgress operation.
 */
export type GetNodeTransitionProgressResponse = NodeTransitionProgress & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;
      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: NodeTransitionProgress;
    };
};

/**
 * Contains response data for the getFaultOperationList operation.
 */
export type GetFaultOperationListResponse = Array<OperationStatus> & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;
      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: OperationStatus[];
    };
};

/**
 * Contains response data for the getBackupPolicyList operation.
 */
export type GetBackupPolicyListResponse = PagedBackupPolicyDescriptionList & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;
      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: PagedBackupPolicyDescriptionList;
    };
};

/**
 * Contains response data for the getBackupPolicyByName operation.
 */
export type GetBackupPolicyByNameResponse = BackupPolicyDescription & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;
      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: BackupPolicyDescription;
    };
};

/**
 * Contains response data for the getAllEntitiesBackedUpByPolicy operation.
 */
export type GetAllEntitiesBackedUpByPolicyResponse = PagedBackupEntityList & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;
      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: PagedBackupEntityList;
    };
};

/**
 * Contains response data for the getApplicationBackupConfigurationInfo operation.
 */
export type GetApplicationBackupConfigurationInfoResponse = PagedBackupConfigurationInfoList & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;
      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: PagedBackupConfigurationInfoList;
    };
};

/**
 * Contains response data for the getApplicationBackupList operation.
 */
export type GetApplicationBackupListResponse = PagedBackupInfoList & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;
      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: PagedBackupInfoList;
    };
};

/**
 * Contains response data for the getServiceBackupConfigurationInfo operation.
 */
export type GetServiceBackupConfigurationInfoResponse = PagedBackupConfigurationInfoList & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;
      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: PagedBackupConfigurationInfoList;
    };
};

/**
 * Contains response data for the getServiceBackupList operation.
 */
export type GetServiceBackupListResponse = PagedBackupInfoList & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;
      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: PagedBackupInfoList;
    };
};

/**
 * Contains response data for the getPartitionBackupConfigurationInfo operation.
 */
export type GetPartitionBackupConfigurationInfoResponse = PartitionBackupConfigurationInfo & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;
      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: PartitionBackupConfigurationInfo;
    };
};

/**
 * Contains response data for the getPartitionBackupList operation.
 */
export type GetPartitionBackupListResponse = PagedBackupInfoList & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;
      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: PagedBackupInfoList;
    };
};

/**
 * Contains response data for the getPartitionBackupProgress operation.
 */
export type GetPartitionBackupProgressResponse = BackupProgressInfo & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;
      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: BackupProgressInfo;
    };
};

/**
 * Contains response data for the getPartitionRestoreProgress operation.
 */
export type GetPartitionRestoreProgressResponse = RestoreProgressInfo & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;
      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: RestoreProgressInfo;
    };
};

/**
 * Contains response data for the getBackupsFromBackupLocation operation.
 */
export type GetBackupsFromBackupLocationResponse = PagedBackupInfoList & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;
      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: PagedBackupInfoList;
    };
};

/**
 * Contains response data for the getSubNameInfoList operation.
 */
export type GetSubNameInfoListResponse = PagedSubNameInfoList & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;
      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: PagedSubNameInfoList;
    };
};

/**
 * Contains response data for the getPropertyInfoList operation.
 */
export type GetPropertyInfoListResponse = PagedPropertyInfoList & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;
      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: PagedPropertyInfoList;
    };
};

/**
 * Contains response data for the getPropertyInfo operation.
 */
export type GetPropertyInfoResponse = PropertyInfo & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;
      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: PropertyInfo;
    };
};

/**
 * Contains response data for the submitPropertyBatch operation.
 */
export type SubmitPropertyBatchResponse = PropertyBatchInfoUnion & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;
      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: PropertyBatchInfoUnion;
    };
};

/**
 * Contains response data for the getClusterEventList operation.
 */
export type GetClusterEventListResponse = Array<ClusterEventUnion> & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;
      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: ClusterEventUnion[];
    };
};

/**
 * Contains response data for the getContainersEventList operation.
 */
export type GetContainersEventListResponse = Array<ContainerInstanceEvent> & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;
      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: ContainerInstanceEvent[];
    };
};

/**
 * Contains response data for the getNodeEventList operation.
 */
export type GetNodeEventListResponse = Array<NodeEventUnion> & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;
      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: NodeEventUnion[];
    };
};

/**
 * Contains response data for the getNodesEventList operation.
 */
export type GetNodesEventListResponse = Array<NodeEventUnion> & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;
      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: NodeEventUnion[];
    };
};

/**
 * Contains response data for the getApplicationEventList operation.
 */
export type GetApplicationEventListResponse = Array<ApplicationEventUnion> & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;
      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: ApplicationEventUnion[];
    };
};

/**
 * Contains response data for the getApplicationsEventList operation.
 */
export type GetApplicationsEventListResponse = Array<ApplicationEventUnion> & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;
      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: ApplicationEventUnion[];
    };
};

/**
 * Contains response data for the getServiceEventList operation.
 */
export type GetServiceEventListResponse = Array<ServiceEventUnion> & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;
      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: ServiceEventUnion[];
    };
};

/**
 * Contains response data for the getServicesEventList operation.
 */
export type GetServicesEventListResponse = Array<ServiceEventUnion> & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;
      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: ServiceEventUnion[];
    };
};

/**
 * Contains response data for the getPartitionEventList operation.
 */
export type GetPartitionEventListResponse = Array<PartitionEventUnion> & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;
      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: PartitionEventUnion[];
    };
};

/**
 * Contains response data for the getPartitionsEventList operation.
 */
export type GetPartitionsEventListResponse = Array<PartitionEventUnion> & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;
      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: PartitionEventUnion[];
    };
};

/**
 * Contains response data for the getPartitionReplicaEventList operation.
 */
export type GetPartitionReplicaEventListResponse = Array<ReplicaEventUnion> & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;
      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: ReplicaEventUnion[];
    };
};

/**
 * Contains response data for the getPartitionReplicasEventList operation.
 */
export type GetPartitionReplicasEventListResponse = Array<ReplicaEventUnion> & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;
      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: ReplicaEventUnion[];
    };
};

/**
 * Contains response data for the getCorrelatedEventList operation.
 */
export type GetCorrelatedEventListResponse = Array<FabricEventUnion> & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;
      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: FabricEventUnion[];
    };
};

/**
 * Contains response data for the getApplicationResource operation.
 */
export type GetApplicationResourceResponse = ApplicationResourceDescription & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;
      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: ApplicationResourceDescription;
    };
};

/**
 * Contains response data for the getServices operation.
 */
export type GetServicesResponse = PagedServiceResourceDescriptionList & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;
      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: PagedServiceResourceDescriptionList;
    };
};

/**
 * Contains response data for the getService operation.
 */
export type GetServiceResponse = ServiceResourceDescription & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;
      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: ServiceResourceDescription;
    };
};

/**
 * Contains response data for the getReplicas operation.
 */
export type GetReplicasResponse = PagedServiceResourceReplicaDescriptionList & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;
      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: PagedServiceResourceReplicaDescriptionList;
    };
};

/**
 * Contains response data for the getReplica operation.
 */
export type GetReplicaResponse = ServiceResourceReplicaDescription & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;
      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: ServiceResourceReplicaDescription;
    };
};

/**
 * Contains response data for the getVolumeResource operation.
 */
export type GetVolumeResourceResponse = VolumeResourceDescription & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;
      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: VolumeResourceDescription;
    };
};
