/*
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for
 * license information.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is
 * regenerated.
 */

import * as msRest from "ms-rest-js";


export const SpellingTokenSuggestion: msRest.CompositeMapper = {
  serializedName: "Spelling/TokenSuggestion",
  type: {
    name: "Composite",
    className: "SpellingTokenSuggestion",
    modelProperties: {
      suggestion: {
        required: true,
        serializedName: "suggestion",
        type: {
          name: "String"
        }
      },
      score: {
        readOnly: true,
        serializedName: "score",
        type: {
          name: "Number"
        }
      },
      pingUrlSuffix: {
        readOnly: true,
        serializedName: "pingUrlSuffix",
        type: {
          name: "String"
        }
      }
    }
  }
};

export const SpellingFlaggedToken: msRest.CompositeMapper = {
  serializedName: "Spelling/FlaggedToken",
  type: {
    name: "Composite",
    className: "SpellingFlaggedToken",
    modelProperties: {
      offset: {
        required: true,
        serializedName: "offset",
        type: {
          name: "Number"
        }
      },
      token: {
        required: true,
        serializedName: "token",
        type: {
          name: "String"
        }
      },
      type: {
        required: true,
        serializedName: "type",
        defaultValue: 'UnknownToken',
        type: {
          name: "String"
        }
      },
      suggestions: {
        readOnly: true,
        serializedName: "suggestions",
        type: {
          name: "Sequence",
          element: {
            type: {
              name: "Composite",
              className: "SpellingTokenSuggestion"
            }
          }
        }
      },
      pingUrlSuffix: {
        readOnly: true,
        serializedName: "pingUrlSuffix",
        type: {
          name: "String"
        }
      }
    }
  }
};

export const ResponseBase: msRest.CompositeMapper = {
  serializedName: "ResponseBase",
  type: {
    name: "Composite",
    polymorphicDiscriminator: {
      serializedName: "_type",
      clientName: "_type"
    },
    uberParent: "ResponseBase",
    className: "ResponseBase",
    modelProperties: {
      _type: {
        required: true,
        serializedName: "_type",
        type: {
          name: "String"
        }
      }
    }
  }
};

export const Identifiable: msRest.CompositeMapper = {
  serializedName: "Identifiable",
  type: {
    name: "Composite",
    polymorphicDiscriminator: ResponseBase.type.polymorphicDiscriminator,
    uberParent: "ResponseBase",
    className: "Identifiable",
    modelProperties: {
      ...ResponseBase.type.modelProperties,
      id: {
        readOnly: true,
        serializedName: "id",
        type: {
          name: "String"
        }
      }
    }
  }
};

export const Response: msRest.CompositeMapper = {
  serializedName: "Response",
  type: {
    name: "Composite",
    polymorphicDiscriminator: ResponseBase.type.polymorphicDiscriminator,
    uberParent: "ResponseBase",
    className: "Response",
    modelProperties: {
      ...Identifiable.type.modelProperties
    }
  }
};

export const Answer: msRest.CompositeMapper = {
  serializedName: "Answer",
  type: {
    name: "Composite",
    polymorphicDiscriminator: ResponseBase.type.polymorphicDiscriminator,
    uberParent: "ResponseBase",
    className: "Answer",
    modelProperties: {
      ...Response.type.modelProperties
    }
  }
};

export const SpellCheck: msRest.CompositeMapper = {
  serializedName: "SpellCheck",
  type: {
    name: "Composite",
    polymorphicDiscriminator: ResponseBase.type.polymorphicDiscriminator,
    uberParent: "ResponseBase",
    className: "SpellCheck",
    modelProperties: {
      ...Answer.type.modelProperties,
      flaggedTokens: {
        required: true,
        serializedName: "flaggedTokens",
        type: {
          name: "Sequence",
          element: {
            type: {
              name: "Composite",
              className: "SpellingFlaggedToken"
            }
          }
        }
      }
    }
  }
};

export const ErrorModel: msRest.CompositeMapper = {
  serializedName: "Error",
  type: {
    name: "Composite",
    className: "ErrorModel",
    modelProperties: {
      code: {
        required: true,
        serializedName: "code",
        defaultValue: 'None',
        type: {
          name: "String"
        }
      },
      subCode: {
        readOnly: true,
        serializedName: "subCode",
        type: {
          name: "String"
        }
      },
      message: {
        required: true,
        serializedName: "message",
        type: {
          name: "String"
        }
      },
      moreDetails: {
        readOnly: true,
        serializedName: "moreDetails",
        type: {
          name: "String"
        }
      },
      parameter: {
        readOnly: true,
        serializedName: "parameter",
        type: {
          name: "String"
        }
      },
      value: {
        readOnly: true,
        serializedName: "value",
        type: {
          name: "String"
        }
      }
    }
  }
};

export const ErrorResponse: msRest.CompositeMapper = {
  serializedName: "ErrorResponse",
  type: {
    name: "Composite",
    polymorphicDiscriminator: ResponseBase.type.polymorphicDiscriminator,
    uberParent: "ResponseBase",
    className: "ErrorResponse",
    modelProperties: {
      ...Response.type.modelProperties,
      errors: {
        required: true,
        serializedName: "errors",
        type: {
          name: "Sequence",
          element: {
            type: {
              name: "Composite",
              className: "ErrorModel"
            }
          }
        }
      }
    }
  }
};

export const discriminators = {
  'ResponseBase.SpellCheck' : SpellCheck,
  'ResponseBase.Answer' : Answer,
  'ResponseBase.Response' : Response,
  'ResponseBase.Identifiable' : Identifiable,
  'ResponseBase.ErrorResponse' : ErrorResponse,
  'ResponseBase' : ResponseBase
};
